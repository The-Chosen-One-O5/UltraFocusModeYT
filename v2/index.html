<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Focus Mode YouTube Player</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #4169e1;
      --primary-dark: #1e3a8a;
      --secondary: #8e2de2;
      --accent: #ff4500;
      --accent-alt: #ff8c00;
      --bg-dark: #0f0f1b;
      --bg-medium: #1a1a2e;
      --bg-light: #252538;
      --text: #e0e0ff;
      --text-dim: #9090b0;
    }

    body {
      background-color: var(--bg-dark);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace;
      color: var(--text);
      overflow: hidden;
      font-size: 18px;
      line-height: 1.4;
    }

    .game-container {
      width: 100%;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background-image: radial-gradient(circle at 10% 20%, rgba(142, 45, 226, 0.1) 0%, transparent 20%),
        radial-gradient(circle at 90% 80%, rgba(65, 105, 225, 0.1) 0%, transparent 20%),
        linear-gradient(to bottom, var(--bg-dark), var(--bg-medium));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
      transition: filter 0.3s ease-in-out; /* Added for blur transition */
    }

    .game-container.blur-background {
       filter: blur(5px); /* Apply blur when pomodoro is active */
       pointer-events: none; /* Disable interaction with background */
    }


    .game-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.05' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 5v1H5V0zm1 5v1H5v-1h1z'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 2;
    }

    #landingPage,
    #signinForm,
    #inputForm {
      text-align: center;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
      position: relative;
      z-index: 10;
      background-color: rgba(15, 15, 27, 0.8);
      border: 2px solid var(--secondary);
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(142, 45, 226, 0.3);
      pointer-events: auto;
    }

    .title {
      font-family: monospace;
      font-size: 32px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 20px;
      text-shadow: 3px 3px 0px var(--primary-dark);
      letter-spacing: 2px;
    }

    .title span {
      color: var(--secondary);
      position: relative;
      display: inline-block;
    }

    .title span::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    .subtitle {
      font-size: 20px;
      color: var(--text-dim);
      margin-bottom: 30px;
    }

    button {
      display: inline-block;
      padding: 12px 30px;
      font-size: 18px;
      font-family: monospace;
      font-weight: 600;
      background: var(--secondary);
      border: none;
      color: var(--text);
      border-radius: 0;
      cursor: pointer;
      margin: 0 10px 15px;
      transition: all 0.3s;
      position: relative;
      box-shadow: 4px 4px 0 var(--primary-dark);
      text-transform: uppercase;
      font-size: 14px;
      letter-spacing: 1px;
      z-index: 11;
      pointer-events: auto;
    }

    button:hover {
      background: var(--primary);
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 var(--primary-dark);
    }

    button:active {
      transform: translate(4px, 4px);
      box-shadow: none;
    }

    .github-btn {
      background: var(--bg-light);
      box-shadow: 4px 4px 0 var(--bg-medium);
    }

    .github-btn:hover {
      background: var(--bg-medium);
      box-shadow: 2px 2px 0 var(--bg-medium);
    }

    #features {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 40px;
      flex-wrap: wrap;
      z-index: 10;
    }

    .feature {
      background: var(--bg-light);
      padding: 15px 20px;
      border-radius: 0;
      width: 200px;
      box-shadow: 4px 4px 0 var(--bg-medium);
      border: 2px solid var(--primary);
      position: relative;
      overflow: hidden;
      z-index: 10;
    }

    .feature::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }

    .feature i {
      font-size: 24px;
      color: var(--secondary);
      margin-bottom: 10px;
    }

    .feature p {
      font-size: 16px;
      color: var(--text);
    }

    input,
    select {
      display: block;
      width: 100%;
      max-width: 320px;
      margin: 10px auto;
      padding: 12px;
      border-radius: 0;
      font-size: 16px;
      font-family: monospace;
      background: var(--bg-light);
      border: 2px solid var(--primary);
      color: var(--text);
      outline: none;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
      z-index: 11;
      pointer-events: auto;
    }

    input:focus,
    select:focus {
      border-color: var(--secondary);
      box-shadow: 0 0 0 2px rgba(142, 45, 226, 0.3);
    }

    #inputForm {
      max-height: 80vh;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--secondary) var(--bg-medium);
    }

    #inputForm::-webkit-scrollbar {
      width: 8px;
    }

    #inputForm::-webkit-scrollbar-track {
      background: var(--bg-medium);
    }

    #inputForm::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 0;
      border: 2px solid var(--bg-medium);
    }

    #player {
      width: 100%;
      max-width: 1200px;
      aspect-ratio: 16 / 9;
      border-radius: 0;
      overflow: hidden;
      display: none;
      background: #000;
      border: 4px solid var(--primary);
      box-shadow: 0 0 20px rgba(65, 105, 225, 0.5);
      z-index: 5;
    }

    #timerDisplay {
      position: fixed;
      top: 10px;
      left: 10px;
      color: var(--text);
      font-size: 24px;
      z-index: 101;
      cursor: move;
      padding: 10px;
      background: var(--bg-medium);
      border: 2px solid var(--primary);
      font-family: monospace;
      font-size: 16px;
      pointer-events: auto;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
    }

    #timerDisplay button {
      pointer-events: auto;
      padding: 5px 10px;
      margin: 0 5px;
      font-size: 12px;
      z-index: 102;
    }

    #pointsDisplay {
      position: fixed;
      top: 50px;
      left: 10px;
      font-size: 18px;
      color: var(--text);
      font-family: monospace;
      font-weight: 600;
      z-index: 101;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }

    #clockDisplay {
      position: fixed;
      top: 90px;
      left: 10px;
      font-size: 20px;
      font-family: monospace;
      font-weight: bold;
      z-index: 101;
      padding: 8px 12px;
      background: var(--bg-medium);
      border: 2px solid var(--primary);
      display: none;
      pointer-events: none;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
    }

    #clockDisplay .time {
      color: var(--primary);
    }

    #clockDisplay .period {
      color: var(--secondary);
    }

    #progressBar {
      width: 200px;
      height: 10px;
      background: var(--bg-light);
      display: none;
      margin-top: 5px;
      border: 2px solid var(--primary);
      z-index: 101;
    }

    #progressFill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }

    /* Removed #sitesBox and #sitesPopup styles */

    #restartBtn {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--accent);
      z-index: 103;
      pointer-events: auto;
    }

    #videoSidebar {
      position: fixed;
      right: -320px;
      top: 0;
      width: 300px;
      height: 100%;
      background: var(--bg-medium);
      transition: right 0.3s ease;
      padding: 20px;
      overflow-y: auto;
      z-index: 102;
      border-left: 4px solid var(--primary);
      pointer-events: auto;
    }

    .thumbnail {
      width: 100%;
      margin-bottom: 15px;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 0;
      transition: all 0.3s;
      image-rendering: pixelated;
      pointer-events: auto;
    }

    .thumbnail:hover {
      border-color: var(--secondary);
      transform: scale(1.05);
    }

    #minimizeBtn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: var(--accent);
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
      padding: 2px 6px;
      margin: 0;
      box-shadow: none;
      z-index: 102;
    }

    .url-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .url-container button {
      margin-left: 10px;
      padding: 5px 10px;
      background: var(--accent);
      font-size: 14px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      z-index: 11;
    }

    #statsBtn,
    #todoBtn,
    #pyqBtn {
      padding: 8px 16px;
      font-size: 12px;
      margin: 0 5px 15px;
      z-index: 11;
    }

    #analytics,
    #todoList {
      position: absolute;
      left: 10px;
      background: var(--bg-medium);
      padding: 15px;
      border: 2px solid var(--secondary);
      display: none;
      z-index: 100;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: auto;
    }

    #analytics {
      top: 90px;
    }

    #todoList {
      top: 50px;
      width: 300px;
      max-height: 400px;
    }

    #tasks {
      overflow-y: auto;
      max-height: 320px;
      margin-bottom: 10px;
      background: none;
    }

    #analytics h3,
    #todoList h3 {
      font-size: 20px;
      margin-bottom: 10px;
      color: var(--secondary);
      font-family: monospace;
      font-size: 16px;
      text-align: center;
    }

    #analytics p {
      font-size: 16px;
      margin: 5px 0;
      border-bottom: 1px solid var(--bg-light);
      padding-bottom: 5px;
    }

    .task-line {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      background: var(--bg-light);
      padding: 5px;
      border: 1px solid var(--primary);
      pointer-events: auto;
    }

    .task-line input[type="checkbox"] {
      margin-right: 10px;
      width: 16px;
      height: 16px;
      appearance: none;
      border: 2px solid var(--primary);
      background: var(--bg-medium);
      position: relative;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line input[type="checkbox"]:checked {
      background: var(--secondary);
    }

    .task-line input[type="checkbox"]:checked::after {
      content: "‚úì";
      position: absolute;
      color: var(--text);
      font-size: 12px;
      top: -2px;
      left: 2px;
    }

    .task-line input[type="text"] {
      flex-grow: 1;
      font-size: 16px;
      font-family: monospace;
      color: var(--text);
      background: transparent;
      border: none;
      border-bottom: 1px solid var(--text-dim);
      padding: 2px 0;
      outline: none;
      box-shadow: none;
      margin: 0;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line input[type="text"]:focus {
      border-bottom: 1px solid var(--secondary);
      box-shadow: none;
    }

    .task-line .remove-task {
      margin-left: 10px;
      color: var(--accent);
      font-size: 16px;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      line-height: 1;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line .set-deadline {
      margin-left: 5px;
      color: var(--primary);
      font-size: 14px;
      cursor: pointer;
      background: none;
      border: none;
      padding: 2px 5px;
      border: 1px solid var(--primary);
      pointer-events: auto;
      z-index: 11;
    }

    .task-line .set-deadline:hover {
      background: var(--primary);
      color: var(--text);
    }

    .task-line .deadline-info {
      margin-left: 5px;
      font-size: 12px;
      color: var(--accent-alt);
    }

    .task-line .points-info {
      margin-left: 5px;
      font-size: 12px;
      color: var(--secondary);
    }

    #lofiPlayer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 101;
      display: none;
      background: var(--bg-medium);
      padding: 10px;
      border: 2px solid var(--primary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: auto;
    }

    #lofiPlayer button {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 5px 10px;
      margin: 0 2px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      font-family: monospace;
      z-index: 102;
    }

    #achievementOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      color: gold;
      font-size: 32px;
      font-weight: bold;
      z-index: 104;
      display: none;
      font-family: monospace;
      text-align: center;
      text-shadow: 3px 3px 0 var(--primary-dark);
      background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.1' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
    }

    #achievementLevel {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 20px;
      font-weight: bold;
      z-index: 101;
      font-family: monospace;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }

    #streakDisplay {
      position: fixed;
      top: 60px;
      right: 10px;
      font-size: 16px;
      color: var(--text);
      z-index: 101;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
      font-family: monospace;
    }

    .glow {
      text-shadow: 0 0 10px var(--text);
      animation: pulse 2s infinite;
    }

    .box-glow {
      border: 2px solid gold;
      padding: 5px;
      box-shadow: 0 0 10px gold;
      animation: pulse 2s infinite;
    }

    .rainbow {
      background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 3s infinite;
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #confirmationDialog,
    #streakShieldDialog,
    #doublePointsDialog,
    #deadlineDialog,
    #sessionCompleteDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid var(--accent);
      box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
    }

    #confirmationDialog p,
    #streakShieldDialog p,
    #doublePointsDialog p,
    #deadlineDialog p,
    #sessionCompleteDialog p {
      font-size: 16px;
      margin-bottom: 20px;
    }

    #confirmationDialog button,
    #streakShieldDialog button,
    #doublePointsDialog button,
    #deadlineDialog button,
    #sessionCompleteDialog button {
      padding: 8px 20px;
      margin: 0 10px;
      font-size: 14px;
      pointer-events: auto;
      z-index: 106;
    }

    #confirmBtn,
    #streakShieldConfirmBtn,
    #doublePointsConfirmBtn,
    #deadlineConfirmBtn,
    #sessionContinueBtn {
      background: var(--accent);
    }

    #cancelBtn,
    #streakShieldCancelBtn,
    #doublePointsCancelBtn,
    #deadlineCancelBtn,
    #sessionEndBtn {
      background: var(--primary);
    }

    #deadlineDialog input,
    #deadlineDialog select {
      margin: 10px auto;
      width: 100%;
      max-width: 250px;
    }

    #pdfToggle {
      display: none;
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: var(--primary);
      z-index: 101;
      cursor: pointer;
      pointer-events: auto;
    }

    #pdfViewer {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 500px;
      background: var(--bg-medium);
      padding: 15px;
      border: 4px solid var(--primary);
      box-shadow: 0 0 20px rgba(65, 105, 225, 0.5);
      z-index: 101;
      pointer-events: auto;
    }

    #pdfInput {
      margin-bottom: 10px;
      width: 100%;
      pointer-events: auto;
      z-index: 102;
    }

    #pdfFrame {
      width: 100%;
      height: 90%;
      border: none;
      background: #fff;
    }

    #fireBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: var(--primary);
      border-radius: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      border: 2px solid var(--secondary);
      pointer-events: auto;
    }

    #fireBox:hover {
      background: var(--secondary);
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
    }

    #aiPopup {
      position: fixed;
      bottom: 60px;
      left: 10px;
      width: 300px;
      height: 400px;
      background: var(--bg-medium);
      border-radius: 0;
      padding: 5px;
      display: none;
      z-index: 101;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      border: 4px solid var(--primary);
      pointer-events: auto;
    }

    #aiPopup iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .game-sidebar {
      position: fixed;
      left: -250px;
      top: 0;
      width: 250px;
      height: 100vh;
      background: var(--bg-medium);
      border-right: 4px solid var(--primary);
      z-index: 200;
      transition: left 0.3s ease;
      padding: 20px 0;
      box-shadow: 4px 0 10px rgba(0, 0, 0, 0.3);
      overflow-y: auto;
      pointer-events: auto;
    }

    .sidebar-trigger:hover + .game-sidebar,
    .game-sidebar:hover {
      left: 0;
    }

    .sidebar-trigger {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 80px;
      background: var(--primary);
      z-index: 199;
      border-radius: 0 5px 5px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text);
      font-weight: bold;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 12px;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .sidebar-section {
      padding: 15px;
      border-bottom: 2px solid var(--bg-dark);
    }

    .sidebar-section h3 {
      color: var(--secondary);
      font-size: 16px;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .sidebar-section a,
    .sidebar-section button {
      display: block;
      width: 100%;
      padding: 8px 10px;
      margin: 5px 0;
      background: var(--bg-light);
      color: var(--text);
      border: 1px solid var(--primary);
      text-align: left;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
      z-index: 201;
       box-shadow: none; /* Reset button shadow for sidebar */
       font-weight: normal; /* Reset button weight */
       text-transform: none; /* Reset text transform */
       letter-spacing: normal;
       margin: 5px 0; /* Reset margin */
    }

     .sidebar-section button:hover {
      background: var(--primary);
      transform: translateX(5px);
      box-shadow: none; /* Ensure no shadow on hover */
    }
     .sidebar-section button:active {
       transform: translateX(5px) translateY(1px); /* Subtle active effect */
       box-shadow: none;
    }


    .dashboard-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .dashboard-info p {
      font-size: 14px;
      display: flex;
      justify-content: space-between;
    }

    .dashboard-info p span:first-child {
      font-weight: bold;
      color: var(--primary);
    }

    #mysteryBoxPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid gold;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
      width: 300px;
    }

    #mysteryBoxPopup h3 {
      color: gold;
      font-size: 20px;
      margin-bottom: 15px;
    }

    #mysteryBoxPopup p {
      font-size: 16px;
      margin-bottom: 20px;
    }

    #mysteryBoxPopup button {
      padding: 8px 20px;
      background: var(--accent);
      font-size: 14px;
      pointer-events: auto;
    }

    /* Audio tracks store styles */
    #audioTracksStore {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      max-height: 500px;
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid var(--secondary);
      box-shadow: 0 0 20px rgba(142, 45, 226, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
      overflow-y: auto;
    }

    #audioTracksStore h3 {
      color: var(--secondary);
      font-size: 20px;
      margin-bottom: 15px;
    }

    .audio-track-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--bg-light);
      border: 1px solid var(--primary);
    }

    .audio-track-item.locked .track-name {
      color: var(--text-dim);
    }

    .audio-track-item.unlocked .track-name {
      color: var(--accent-alt);
    }

    .unlock-track-btn {
      padding: 5px 10px;
      background: var(--secondary);
      font-size: 12px;
      margin: 0; /* Override default button margin */
       box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3); /* Keep a small shadow */
    }
     .unlock-track-btn:hover {
         background: var(--primary);
         transform: translate(1px, 1px);
         box-shadow: 1px 1px 0 rgba(0, 0, 0, 0.3);
     }

    .unlock-track-btn:disabled {
      background: var(--bg-light);
      color: var(--text-dim);
      cursor: not-allowed;
       box-shadow: none;
       transform: none;
    }

    /* Quiet Pomodoro Styles */
    #pomodoroOverlay {
       position: fixed;
       top: 0;
       left: 0;
       width: 100vw;
       height: 100vh;
       background-color: rgba(15, 15, 27, 0.7); /* Semi-transparent dark background */
       backdrop-filter: blur(5px); /* Apply blur to background via overlay */
       display: none; /* Hidden by default */
       justify-content: center;
       align-items: center;
       z-index: 250; /* Ensure it's above sidebar trigger but below modals */
       pointer-events: auto; /* Allow interaction with overlay content */
       flex-direction: column; /* Center content vertically */
       font-family: monospace;
    }

     #pomodoroTimerDisplay {
       font-size: 6rem; /* Large timer display */
       color: var(--text);
       margin-bottom: 20px;
       text-shadow: 3px 3px 0px var(--primary-dark);
    }

     #pomodoroStatus {
        font-size: 1.5rem;
        color: var(--secondary);
        margin-bottom: 30px;
        text-transform: uppercase;
        letter-spacing: 2px;
     }

    #pomodoroControls button {
       padding: 10px 25px;
       font-size: 1rem;
       margin: 0 15px;
       /* Use default button styles */
    }
     #pomodoroStartBtn {
        background-color: var(--primary);
     }
      #pomodoroStartBtn:hover {
         background-color: var(--primary-dark);
     }
      #pomodoroResetBtn {
        background-color: var(--accent);
     }
      #pomodoroResetBtn:hover {
         background-color: var(--accent-alt);
     }

    @media (max-width: 800px) {
      .title { font-size: 24px; }
      button { padding: 8px 16px; font-size: 12px; margin: 0 5px 10px; }
      #features { flex-direction: column; align-items: center; }
      .feature { width: 90%; max-width: 250px; }
      #timerDisplay, #pointsDisplay, #clockDisplay { font-size: 14px; padding: 5px 8px; }
      #achievementLevel, #streakDisplay { font-size: 14px; padding: 5px 8px; }
      #videoSidebar { width: 250px; }
      #lofiPlayer button { padding: 3px 6px; font-size: 10px; }
      #confirmationDialog, #streakShieldDialog, #doublePointsDialog { width: 90%; max-width: 300px; }
      #confirmationDialog p, #streakShieldDialog p, #doublePointsDialog p { font-size: 14px; }
      #pdfViewer { width: 90%; height: 80%; max-height: 500px; }
      #aiPopup { width: 90%; max-width: 300px; height: 350px; }
      #mysteryBoxPopup { width: 90%; max-width: 280px; }
      #audioTracksStore { width: 90%; max-width: 350px; }
      #pomodoroTimerDisplay { font-size: 4rem; } /* Adjust pomodoro timer size */
      #pomodoroStatus { font-size: 1rem; }
      #pomodoroControls button { padding: 8px 15px; font-size: 0.9rem; margin: 0 10px; }
    }
  </style>
</head>
<body>
  <div class="game-container" id="gameContainer">
    <div class="sidebar-trigger">MENU</div>
    <div class="game-sidebar">
      <div class="sidebar-section">
        <h3>Dashboard</h3>
        <div class="dashboard-info">
          <p><span>Hero:</span> <span id="sidebarUsername">Guest</span></p>
          <p><span>Level:</span> <span id="sidebarLevel">Mortal</span></p>
          <p><span>XP:</span> <span id="sidebarXP">0</span></p>
          <p><span>Streak:</span> <span id="sidebarStreak">0 days</span></p>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Allied Realms</h3>
        <a href="https://forestquest.vercel.app/" target="_blank" rel="noreferrer">FOREST QUEST - TASK MANAGEMENT</a>
        <a href="https://focuswithpomodoro.netlify.app/" target="_blank" rel="noreferrer">POMODORO REALM</a>
        <a href="https://the-chosen-one-o5.github.io/Daily-Schedule/" target="_blank" rel="noreferrer">DAILY QUEST PLANNER</a>
      </div>
       <div class="sidebar-section">
          <h3>Focus Tools</h3>
          <button id="quietPomodoroBtn">QUIET POMODORO</button>
          <!-- Add other tools here -->
       </div>
      <div class="sidebar-section">
        <h3>Shop</h3>
        <button id="streakShieldBtn">STREAK SHIELD</button>
        <button id="doublePointsBtn">DOUBLE POINTS POWER-UP</button>
        <button id="audioStoreBtn">AUDIO TRACKS STORE</button>
      </div>
      <div class="sidebar-section">
        <h3>Account</h3>
        <button id="logoutBtn">LOGOUT</button>
      </div>
    </div>
    <div id="landingPage">
      <div class="title">QUEST FOR <span>FOCUS</span></div>
      <div class="subtitle">Begin your learning adventure!</div>
      <button data-action="start-game">START GAME</button>
      <button class="github-btn" data-action="github">GITHUB REPO</button>
      <div id="features">
        <div class="feature">
          <i class="fas fa-ad"></i>
          <p>Ad Free<br>No distractions on your quest</p>
        </div>
        <div class="feature">
          <i class="fas fa-moon"></i>
          <p>Dark Mode<br>Save your vision for the final boss</p>
        </div>
      </div>
    </div>

    <div id="signinForm" style="display: none;">
      <div class="title">CREATE YOUR <span>ACCOUNT</span></div>
      <div class="subtitle">Sign in to track your progress</div>
      <input type="text" id="username" placeholder="Hero Name" required />
      <input type="password" id="password" placeholder="Secret Code" required />
      <button data-action="sign-in">ENTER REALM</button>
      <p>New adventurer? <button data-action="create-account">CREATE ACCOUNT</button></p>
    </div>

    <div id="inputForm" style="display: none;">
      <div id="achievementLevel"></div>
      <div id="streakDisplay"></div>
      <button id="todoBtn">TO-DO</button>
      <button id="statsBtn">HERO STATS</button>
      <button id="pyqBtn">TRAINING GROUNDS</button>

      <div id="todoList">
        <h3>TO-DO</h3>
        <div id="tasks">
          <div class="task-line">
            <input type="checkbox" class="task-check" />
            <input type="text" class="task-text" placeholder="Add a quest..." />
            <button class="set-deadline">‚è∞</button>
            <span class="remove-task">x</span>
          </div>
        </div>
        <button data-action="save-tasks">SAVE QUESTS</button>
      </div>

      <div id="analytics">
        <h3>HERO STATS</h3>
        <p>Focus Time: <span id="totalFocusTime">0</span> min</p>
        <p>Distractions Defeated: <span id="totalDistractions">0</span></p>
        <p>Videos Completed: <span id="totalVideosWatched">0</span></p>
      </div>

      <div class="title">ENTER YOUR <span>YOUTUBE URL</span></div>
      <div class="subtitle"></div>
      <select id="playlistSelect">
        <option value="">Select a Saved Path</option>
      </select>
      <input type="text" id="playlistName" placeholder="Save Path As..." />
      <button data-action="save-playlist">SAVE PLAYLIST</button>
      <button data-action="remove-playlist">DELETE PLAYLIST</button>

      <div id="urlInputs">
        <div class="url-container">
          <input type="text" class="youtube-url" placeholder="YouTube URL (Videos or Live Streams)" required />
        </div>
      </div>

      <button data-action="add-url">ADD URL</button>
      <button data-action="start-playback">BEGIN FOCUS</button>
    </div>

    <div id="player" style="display: none;"></div>

    <div id="timerDisplay">
      <button id="minimizeBtn">-</button>
      <span id="timerText"></span>
      <div id="progressBar">
        <div id="progressFill"></div>
      </div>
    </div>

    <div id="pointsDisplay"><span style="color: #8e2de2;">‚≠ê</span> XP: 0</div>
    <div id="clockDisplay"></div>

    <!-- Removed #sitesBox and #sitesPopup HTML elements -->

    <button id="restartBtn" style="display: none;">EXIT</button>

    <div id="videoSidebar"></div>

    <div id="lofiPlayer">
      <div style="text-align: center; margin-bottom: 5px;">LOFI MUSIC ‚ô¨</div>
      <button id="lofiPrev">‚óÑ</button>
      <button id="lofiPlay">‚ñ∂</button>
      <button id="lofiPause">‚ùö‚ùö</button>
      <button id="lofiNext">‚ñ∫</button>
    </div>

    <div id="achievementOverlay"></div>

    <div id="confirmationDialog" style="display: none;">
      <p>Are you sure you want to abandon your quest?</p>
      <button id="confirmBtn">YES</button>
      <button id="cancelBtn">NO</button>
    </div>

    <div id="streakShieldDialog" style="display: none;">
      <p>Are you sure you want to buy Streak Shield for 800 XP? (Protects streak for 1 week)</p>
      <button id="streakShieldConfirmBtn">YES</button>
      <button id="streakShieldCancelBtn">NO</button>
    </div>

    <div id="doublePointsDialog" style="display: none;">
      <p>Are you sure you want to buy Double Points Power-Up for 800 XP? (Doubles points for 24 hours)</p>
      <button id="doublePointsConfirmBtn">YES</button>
      <button id="doublePointsCancelBtn">NO</button>
    </div>

    <div id="deadlineDialog" style="display: none;">
      <h3>Set Task Deadline</h3>
      <p>Set a deadline for your task to earn points!</p>
      <input type="date" id="deadlineDate" />
      <input type="time" id="deadlineTime" />
      <select id="taskDifficulty">
        <option value="50">Easy (50 points)</option>
        <option value="100">Medium (100 points)</option>
        <option value="200">Hard (200 points)</option>
        <option value="300">Very Hard (300 points)</option>
      </select>
      <button id="deadlineConfirmBtn">SET DEADLINE</button>
      <button id="deadlineCancelBtn">CANCEL</button>
    </div>

    <div id="sessionCompleteDialog" style="display: none;">
      <h3>Session Complete!</h3>
      <p>Great work! You've completed a focus session.</p>
      <p>One more session for +100 bonus points?</p>
      <button id="sessionContinueBtn">CONTINUE (+100 XP)</button>
      <button id="sessionEndBtn">END SESSION</button>
    </div>

    <button id="pdfToggle">PDF UPLOAD</button>

    <div id="pdfViewer">
      <input type="file" id="pdfInput" accept=".pdf" />
      <iframe id="pdfFrame"></iframe>
      <button onclick="togglePDFViewer()" style="background: #ff4444; margin-top: 10px;">CLOSE</button>
    </div>

    <div id="fireBox">üßô</div>
    <div id="aiPopup">
      <iframe src="https://www.chatbase.co/chatbot-iframe/3dSdpryiYZlWipHUL8dNK" frameBorder="0"></iframe>
    </div>

    <div id="mysteryBoxPopup" style="display: none;">
      <h3>Focus Mystery Box</h3>
      <p id="mysteryRewardText">Click to reveal your reward!</p>
      <button id="openMysteryBox">OPEN</button>
    </div>

    <div id="audioTracksStore" style="display: none;">
      <h3>AUDIO TRACKS STORE</h3>
      <p>Unlock exclusive Lo-Fi tracks to enhance your focus sessions!</p>
      <div id="audioTracksList"></div>
      <button id="closeAudioStore" style="background: #ff4444; margin-top: 15px;">CLOSE</button>
    </div>

    <!-- Quiet Pomodoro Overlay -->
    <div id="pomodoroOverlay">
      <div id="pomodoroStatus">WORK</div>
      <div id="pomodoroTimerDisplay">25:00</div>
      <div id="pomodoroControls">
        <button id="pomodoroStartBtn">START</button>
        <button id="pomodoroResetBtn">RESET</button>
      </div>
    </div>


    <audio id="focusAudio" preload="none" src="https://the-chosen-one-o5.github.io/UltraFocusModeYT/focus.mp3"></audio>
    <audio id="lofiAudio" preload="none" loop></audio>
    <audio id="pomodoroCompleteAudio" preload="none" src="https://www.dropbox.com/scl/fi/ihrcv1s3o4m4abhn6oa5z/level-up-4-243762.mp3?rlkey=qkaf4zrhipxtxpu51an0do45r&st=boipxpb5&dl=1"></audio>

  </div>

  <script>
    ;(() => {
      let currentVideoIndex = 0
      let player
      let videoIds = []
      let isFocusModeActive = false
      let countdownInterval
      let distractionCount = 0
      let points = 0
      let isSignedIn = false
      let currentUser = null
      const focusDuration = 50 * 60 * 1000 // 50 minutes
      const firstBreakDuration = 15 * 60 * 1000 // 15 minutes - Kept for potential future use or logic extension
      const secondBreakDuration = 10 * 60 * 1000 // 10 minutes - Current break time after focus
      let timerMode = "Focus Time"
      let timerRemaining = focusDuration / 1000
      let completedVideos = new Set()
      let allVideosCompleted = false
      let totalFocusTime = 0 // Stored in seconds
      let totalDistractions = 0
      let totalVideosWatched = 0
      let playlists = JSON.parse(localStorage.getItem("playlists") || "[]")
      let tasks = JSON.parse(localStorage.getItem("tasks") || "[]")
      let previousPoints = 0
      let streakDays = 0
      let lastFocusDate = null
      let isYouTubeAPILoaded = false
      let lofiAudio
      let pomodoroCompleteAudio; // Added for pomodoro sound
      let lofiSongs = [ // Initial free tracks - Keep original URLs here
        "https://www.dropbox.com/scl/fi/7qrgbk6vpej7x0ih7vev2/1-6_XRwBX7NX-1.mp3?rlkey=m3gntnys7az2hoq0iokkajucj&st=bmrhzjy8&dl=1",
        "https://www.dropbox.com/scl/fi/ykeun00q1t03kzpeow819/music-to-make-your-brain-shut-up-a-dark-academia-playlist-4.mp3?rlkey=3hnw2vk2ck0yjnr9oekk2xqld&st=hh77z1k0&dl=1",
        "https://www.dropbox.com/scl/fi/pe09xx1c680gzymsa2gdf/NEOTIC-Calm-Your-Anxiety.mp3?rlkey=2hp7su9j541mpcdkw4ccavx58&st=yles17dd&dl=1",
        "https://www.dropbox.com/scl/fi/lb5f47widcz8mwhg79jiz/Kate-Grove-SKYRIM-THEME-skyrim-elderscrolls-ocarina.mp3?rlkey=f8kpm1ipyowc1wv998myu06us&st=bm9qmodf&dl=1",
        "https://www.dropbox.com/scl/fi/8wf64nv0rwubt7hbs5x20/Kurate-Music-Best-of-Gibran-Alcocer-Beautiful-Piano-Mix.mp3?rlkey=i776feuxag0ebullqe0kjo0gp&st=bb3uyo3h&dl=1",
        "https://www.dropbox.com/scl/fi/7xoemzmrgq0wzbxc9i9tp/Jumping-_brick-Sidewalks-and-skeletons-goth-slowed-reverb-best-part-loop.mp3?rlkey=d4dt6rv6sdzteextqek29geug&st=4umnyp0c&dl=1",
        "https://www.dropbox.com/scl/fi/macw47c2kvur0yfi4r9up/St3phen-If-Youre-A-Gamer-This-Song-FOUND-You.mp3?rlkey=qudky54311tppavhvnpra89ff&st=7dgshk5k&dl=1",
        "https://www.dropbox.com/scl/fi/c1iy5yjmf3d57jrb1aokc/KestrelTapes-what-nostalgia-sounds-like...mp3?rlkey=qcdj1vpdnzwdb03fxp0vk0661&st=fyqrl6ge&dl=1",
        "https://www.dropbox.com/scl/fi/p303xk68pvu8sfrmtwzj2/rhawn-there-is-hopecore.mp3?rlkey=m6tva7g4dsva39ii1l0e8tnu0&st=6z218pii&dl=1",
        "https://www.dropbox.com/scl/fi/bw4n0ne8nli4dkp7p26po/Jaob-not-just-another-hopecore-playlist.mp3?rlkey=jy0umwkadkxj9cju1yf2wz7hw&st=yjxhzw0s&dl=1",
        "https://www.dropbox.com/scl/fi/evhrjdri6a9n9bk05qhcu/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=lauo50rz3indg5n3to5gfks1y&st=gcqmonsf&dl=1",
      ]
      
      // Premium audio tracks that can be unlocked - UPDATED URLs
      const premiumLofiTracks = [
        { id: "track1", name: "Celestial Dreams", url: "https://www.dropbox.com/scl/fi/3xkks3j4tcmnloz46o03m/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=6w97eurecqph68b8f2r7zn5pf&st=epeucz72&dl=1", unlocked: false, cost: 100 },
        { id: "track2", name: "Midnight Study", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=ui3kdsq5&dl=1", unlocked: false, cost: 100 },
        { id: "track3", name: "Rainy Day Focus", url: "https://www.dropbox.com/scl/fi/iaouozc1osse7h5ea9lon/thunder-chosic.com.mp3?rlkey=o7u0rarnh4kk657qhmcgyiolz&st=2r9f625j&dl=1", unlocked: false, cost: 100 },
        { id: "track4", name: "Epic Concentration", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=cq8j3dij&dl=1", unlocked: false, cost: 100 },
        // { id: "track5", name: "Zen Garden", url: "...", unlocked: false, cost: 100 }, // Keep placeholder if 5th track URL wasn't provided
      ];
      
      let currentLofiIndex = 0
      let currentTaskForDeadline = null

      // Reminder feature variables
      let reminderInterval
      let timeOnInputForm = 0
      const reminderIntervalTime = 20 * 60 * 1000 // 20 minutes in milliseconds
      const reminderThreshold = 20 * 60 * 1000 // 20 minutes threshold

      // Mystery Box and Power-Up feature variables
      let mysteryBoxCount = 0
      let activePowerUps = {
        doublePoints: { active: false, expiry: null },
        streakShield: { active: false, used: false, expiry: null },
      }
      const STREAK_SHIELD_COST = 800
      const STREAK_SHIELD_DURATION = 7 * 24 * 60 * 60 * 1000 // 1 week in milliseconds
      const DOUBLE_POINTS_COST = 800
      const DOUBLE_POINTS_DURATION = 24 * 60 * 60 * 1000 // 24 hours in milliseconds
      const MYSTERY_BOX_STREAK_INTERVAL = 14 // Earn a box every 14 days of streak
      const mysteryBoxRewards = [
        { type: "points", value: () => Math.floor(Math.random() * 451) + 50, message: (val) => `+${val} XP` },
        { type: "doublePoints", value: DOUBLE_POINTS_DURATION, message: () => "Double Points for 24 Hours" },
        { type: "streakShield", value: 1, message: () => "1-Day Streak Shield" }, // Simplified: grants one shield use
      ]

      const achievementLevels = [
        { points: 0, level: "Mortal", color: "white" },
        { points: 1000, level: "Soldier", color: "#4169E1" },
        { points: 2000, level: "Knight", color: "white", glow: true },
        { points: 3000, level: "KING", color: "#FF8C00", glow: true },
        { points: 4000, level: "GIGACHAD", color: "#FF4500", glow: true },
        { points: 5000, level: "Demigod", color: "gold", glow: true },
        { points: 6000, level: "Titan", color: "gold", glow: true, box: true },
        { points: 7000, level: "Immortal", color: "gold", glow: true, box: true, boxGlow: true },
        { points: 8000, level: "Celestial", color: "gold", glow: true, box: true, boxGlow: true },
        { points: 9000, level: "Divine", color: "rainbow" },
        { points: 10000, level: "Omnipotent", color: "rainbow", glow: true },
      ]

      // --- Quiet Pomodoro State Variables ---
      let pomodoroInterval = null;
      let isPomodoroRunning = false;
      let pomodoroMode = 'Work'; // 'Work' or 'Break'
      const POMODORO_WORK_MINS = 25;
      const POMODORO_BREAK_MINS = 5;
      let pomodoroTimeRemaining = POMODORO_WORK_MINS * 60; // in seconds
      // --- End Pomodoro Variables ---


      function initAudio() {
          lofiAudio = document.getElementById("lofiAudio");
          pomodoroCompleteAudio = document.getElementById("pomodoroCompleteAudio"); // Get pomodoro audio element

          // Build the initial lofiSongs array including unlocked premium tracks
          const baseLofiSongs = [ // Keep original free tracks definition separate
               "https://www.dropbox.com/scl/fi/7qrgbk6vpej7x0ih7vev2/1-6_XRwBX7NX-1.mp3?rlkey=m3gntnys7az2hoq0iokkajucj&st=bmrhzjy8&dl=1",
               "https://www.dropbox.com/scl/fi/ykeun00q1t03kzpeow819/music-to-make-your-brain-shut-up-a-dark-academia-playlist-4.mp3?rlkey=3hnw2vk2ck0yjnr9oekk2xqld&st=hh77z1k0&dl=1",
               "https://www.dropbox.com/scl/fi/pe09xx1c680gzymsa2gdf/NEOTIC-Calm-Your-Anxiety.mp3?rlkey=2hp7su9j541mpcdkw4ccavx58&st=yles17dd&dl=1",
               "https://www.dropbox.com/scl/fi/lb5f47widcz8mwhg79jiz/Kate-Grove-SKYRIM-THEME-skyrim-elderscrolls-ocarina.mp3?rlkey=f8kpm1ipyowc1wv998myu06us&st=bm9qmodf&dl=1",
               "https://www.dropbox.com/scl/fi/8wf64nv0rwubt7hbs5x20/Kurate-Music-Best-of-Gibran-Alcocer-Beautiful-Piano-Mix.mp3?rlkey=i776feuxag0ebullqe0kjo0gp&st=bb3uyo3h&dl=1",
               "https://www.dropbox.com/scl/fi/7xoemzmrgq0wzbxc9i9tp/Jumping-_brick-Sidewalks-and-skeletons-goth-slowed-reverb-best-part-loop.mp3?rlkey=d4dt6rv6sdzteextqek29geug&st=4umnyp0c&dl=1",
               "https://www.dropbox.com/scl/fi/macw47c2kvur0yfi4r9up/St3phen-If-Youre-A-Gamer-This-Song-FOUND-You.mp3?rlkey=qudky54311tppavhvnpra89ff&st=7dgshk5k&dl=1",
               "https://www.dropbox.com/scl/fi/c1iy5yjmf3d57jrb1aokc/KestrelTapes-what-nostalgia-sounds-like...mp3?rlkey=qcdj1vpdnzwdb03fxp0vk0661&st=fyqrl6ge&dl=1",
               "https://www.dropbox.com/scl/fi/p303xk68pvu8sfrmtwzj2/rhawn-there-is-hopecore.mp3?rlkey=m6tva7g4dsva39ii1l0e8tnu0&st=6z218pii&dl=1",
               "https://www.dropbox.com/scl/fi/bw4n0ne8nli4dkp7p26po/Jaob-not-just-another-hopecore-playlist.mp3?rlkey=jy0umwkadkxj9cju1yf2wz7hw&st=yjxhzw0s&dl=1",
               "https://www.dropbox.com/scl/fi/evhrjdri6a9n9bk05qhcu/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=lauo50rz3indg5n3to5gfks1y&st=gcqmonsf&dl=1",
          ];
          
          const unlockedPremiumUrls = premiumLofiTracks
              .filter(track => track.unlocked) // Get only unlocked tracks
              .map(track => track.url); // Get their URLs
          
          lofiSongs = [...new Set([...baseLofiSongs, ...unlockedPremiumUrls])]; // Combine and remove duplicates

          
          if (lofiAudio && lofiSongs.length > 0) {
              // Ensure currentLofiIndex is valid
              currentLofiIndex = currentLofiIndex % lofiSongs.length;
              lofiAudio.src = lofiSongs[currentLofiIndex];
          } else if (lofiAudio) {
              console.warn("No LoFi songs available.");
              lofiAudio.src = ""; // Clear source if no songs
          }
      }


      function getAchievementLevel(currentPoints) {
        let currentLevel = achievementLevels[0]
        for (const level of achievementLevels) {
          if (currentPoints >= level.points) currentLevel = level
          else break
        }
        return currentLevel
      }

      function updateAchievementLevel() {
        const achievementDiv = document.getElementById("achievementLevel")
        if (!achievementDiv) return

        const level = getAchievementLevel(points)
        let style = `color: ${level.color}; font-weight: bold;`
        if (level.glow) style += " text-shadow: 0 0 10px;"
        if (level.box) style += " border: 2px solid gold; padding: 5px;"
        if (level.boxGlow) style += " box-shadow: 0 0 10px gold;"
        
        achievementDiv.classList.remove("rainbow", "glow", "box-glow"); // Reset classes
        if (level.color === "rainbow") achievementDiv.classList.add("rainbow");
        if (level.glow) achievementDiv.classList.add("glow");
        if (level.boxGlow) achievementDiv.classList.add("box-glow");

        achievementDiv.innerHTML = level.level;
        achievementDiv.style = style; // Apply color and base styles
        updateSidebarDashboard();
      }


      function showAchievementOverlay(level) {
        const overlay = document.getElementById("achievementOverlay")
        if (!overlay) return

        overlay.textContent = `LEVEL UP! ${level.toUpperCase()} UNLOCKED!`
        overlay.style.display = "flex"
        setTimeout(() => overlay.style.display = "none", 5000)
      }

      function updateClock() {
        const clockDisplay = document.getElementById("clockDisplay")
        if (!clockDisplay) return

        const now = new Date()
        let hours = now.getHours()
        const minutes = now.getMinutes().toString().padStart(2, "0")
        const seconds = now.getSeconds().toString().padStart(2, "0")
        const period = hours >= 12 ? "PM" : "AM"
        hours = hours % 12 || 12
        hours = hours.toString().padStart(2, "0")
        clockDisplay.innerHTML = `<span class="time">${hours}:${minutes}:${seconds}</span> <span class="period">${period}</span>`
      }

      function playLofi() {
        if (!lofiAudio || lofiSongs.length === 0) return;
        lofiAudio.play().catch((err) => console.error("Lofi play error:", err))
      }

      function pauseLofi() {
        if (!lofiAudio) return;
        lofiAudio.pause()
      }

      function prevLofi() {
        if (!lofiAudio || lofiSongs.length === 0) return;
        currentLofiIndex = (currentLofiIndex - 1 + lofiSongs.length) % lofiSongs.length
        lofiAudio.src = lofiSongs[currentLofiIndex]
        playLofi()
      }

      function nextLofi() {
        if (!lofiAudio || lofiSongs.length === 0) return;
        currentLofiIndex = (currentLofiIndex + 1) % lofiSongs.length
        lofiAudio.src = lofiSongs[currentLofiIndex]
        playLofi()
      }

      // Removed toggleSitesPopup and closeSitesPopup functions as elements are removed

      function updateStreak() {
          const streakDisplay = document.getElementById("streakDisplay");
          if (!streakDisplay) return;

          const today = new Date().toDateString();
          const lastDateStr = localStorage.getItem("lastFocusDate");
          let shouldUpdateStorage = false;

          if (lastDateStr) {
              const last = new Date(lastDateStr);
              const diffTime = new Date(today).setHours(0, 0, 0, 0) - last.setHours(0, 0, 0, 0); // Compare dates only
              const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

              if (diffDays === 1) {
                  streakDays++;
                  checkMysteryBoxMilestone(); // Check *after* incrementing
                  shouldUpdateStorage = true;
              } else if (diffDays > 1) {
                  // Streak potentially broken
                  if (activePowerUps.streakShield.active && !activePowerUps.streakShield.used && Date.now() < activePowerUps.streakShield.expiry) {
                       // Use the shield
                       activePowerUps.streakShield.used = true;
                       streakDays++; // Maintain and increment streak
                       alert("Streak Shield protected your streak!");
                       shouldUpdateStorage = true;
                   } else {
                       // Reset streak if no shield or expired/used
                       streakDays = 1; // Reset to 1 for today's session
                       shouldUpdateStorage = true;
                   }
              } else if (diffDays === 0) {
                  // Focused multiple times today, don't change streak or date yet
                  // But maybe update storage if other things changed? (Handled elsewhere by saveState)
              } else {
                 // Edge case (e.g., system time changed backwards) - reset?
                 streakDays = 1;
                 shouldUpdateStorage = true;
              }
          } else {
              // First focus session ever for this user/device
              streakDays = 1;
              shouldUpdateStorage = true;
          }

          if (shouldUpdateStorage) {
             localStorage.setItem("lastFocusDate", today);
          }
          
          streakDisplay.innerHTML = `<span style="color: #8e2de2;">üî•</span> ${streakDays} day${streakDays === 1 ? "" : "s"} of focus`;

          saveState(); // Save state including potentially updated streak/shield status

          const sidebarStreak = document.getElementById("sidebarStreak");
          if (sidebarStreak) sidebarStreak.textContent = `${streakDays} day${streakDays === 1 ? "" : "s"}`;
      }


      function checkMysteryBoxMilestone() {
        if (streakDays > 0 && streakDays % MYSTERY_BOX_STREAK_INTERVAL === 0) {
          mysteryBoxCount++
          showMysteryBoxPopup()
          saveState() // Save the incremented count
        }
      }

      function showMysteryBoxPopup() {
        const popup = document.getElementById("mysteryBoxPopup")
        const rewardText = document.getElementById("mysteryRewardText")
        if (!popup || !rewardText) return

        rewardText.textContent = `You earned a Focus Mystery Box! (${mysteryBoxCount} available)`
        popup.style.display = "block"
      }

      function openMysteryBox() {
        if (mysteryBoxCount <= 0) return

        const popup = document.getElementById("mysteryBoxPopup")
        const rewardText = document.getElementById("mysteryRewardText")
        if (!popup || !rewardText) return

        const reward = mysteryBoxRewards[Math.floor(Math.random() * mysteryBoxRewards.length)]
        let rewardValue = reward.value instanceof Function ? reward.value() : reward.value

        let messagePrefix = "Reward: ";
        switch (reward.type) {
          case "points":
            points += rewardValue;
            break;
          case "doublePoints":
            if (!activePowerUps.doublePoints.active || Date.now() > activePowerUps.doublePoints.expiry) {
                activePowerUps.doublePoints.active = true;
                activePowerUps.doublePoints.expiry = Date.now() + rewardValue;
            } else {
                // Extend existing duration
                activePowerUps.doublePoints.expiry += rewardValue;
                messagePrefix = "Extended! ";
            }
            setTimeout(() => {
              activePowerUps.doublePoints.active = false
              saveState()
              // Maybe alert user? Decided against alert spam
            }, activePowerUps.doublePoints.expiry - Date.now());
            break;
          case "streakShield":
            // Give one shield charge (simplification from original duration)
            activePowerUps.streakShield.active = true; // Mark shield system as potentially active
            activePowerUps.streakShield.used = false; // Give a fresh charge
            activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION; // Set expiry for this charge
             setTimeout(() => {
                // Expire this specific charge if unused
                 if (!activePowerUps.streakShield.used && activePowerUps.streakShield.expiry <= Date.now()) {
                     activePowerUps.streakShield.active = false; // Deactivate if this was the only charge
                     activePowerUps.streakShield.expiry = null;
                 }
                 saveState();
             }, STREAK_SHIELD_DURATION);
            break;
        }

        rewardText.textContent = `${messagePrefix}${reward.message(rewardValue)}`
        mysteryBoxCount--
        document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`
        saveState()

        setTimeout(() => {
          if (mysteryBoxCount > 0) showMysteryBoxPopup() // Show again if more boxes exist
          else popup.style.display = "none"
        }, 2000)
      }

      function applyPowerUps(pointsEarned) {
        if (activePowerUps.doublePoints.active && Date.now() < activePowerUps.doublePoints.expiry) {
          return pointsEarned * 2;
        }
        return pointsEarned;
      }

      function showStreakShieldDialog() {
        const dialog = document.getElementById("streakShieldDialog")
        if (!dialog) return
        if (points < STREAK_SHIELD_COST) {
          alert(`Not enough XP! You need ${STREAK_SHIELD_COST} XP to buy a Streak Shield.`)
          return
        }
        // Check if already active and not used
        if(activePowerUps.streakShield.active && !activePowerUps.streakShield.used && Date.now() < activePowerUps.streakShield.expiry) {
          alert("You already have an active Streak Shield charge!");
          return;
        }
        dialog.style.display = "block"
      }

      function handleStreakShieldConfirmation(choice) {
        const dialog = document.getElementById("streakShieldDialog")
        if (!dialog) return

        dialog.style.display = "none"
        if (choice === "yes") {
            if (points >= STREAK_SHIELD_COST) {
                points -= STREAK_SHIELD_COST
                activePowerUps.streakShield.active = true // Enable shield system
                activePowerUps.streakShield.used = false // Grant one charge
                activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION // Set expiry for this charge
                document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`
                alert("Streak Shield activated! It will protect your next missed day within 1 week.")
                saveState()
                 // Set timeout to expire this specific charge
                 setTimeout(() => {
                     if (!activePowerUps.streakShield.used && activePowerUps.streakShield.expiry <= Date.now()) {
                         activePowerUps.streakShield.active = false; // Deactivate if this was the only charge
                         activePowerUps.streakShield.expiry = null;
                         alert("Your purchased Streak Shield charge has expired!");
                     }
                     saveState();
                 }, STREAK_SHIELD_DURATION);
            } else {
                 alert(`Not enough XP! You need ${STREAK_SHIELD_COST} XP.`);
            }
        }
      }

      function showDoublePointsDialog() {
        const dialog = document.getElementById("doublePointsDialog")
        if (!dialog) return
        if (points < DOUBLE_POINTS_COST) {
          alert(`Not enough XP! You need ${DOUBLE_POINTS_COST} XP to buy Double Points Power-Up.`)
          return
        }
        dialog.style.display = "block"
      }

      function handleDoublePointsConfirmation(choice) {
        const dialog = document.getElementById("doublePointsDialog")
        if (!dialog) return

        dialog.style.display = "none"
        if (choice === "yes") {
            if(points >= DOUBLE_POINTS_COST) {
                points -= DOUBLE_POINTS_COST;
                let message = "Double Points Power-Up activated for 24 hours!";
                const now = Date.now();

                if (activePowerUps.doublePoints.active && now < activePowerUps.doublePoints.expiry) {
                    // Extend duration
                    activePowerUps.doublePoints.expiry += DOUBLE_POINTS_DURATION;
                    message = "Double Points duration extended by 24 hours!";
                } else {
                    // Activate new
                    activePowerUps.doublePoints.active = true;
                    activePowerUps.doublePoints.expiry = now + DOUBLE_POINTS_DURATION;
                }

                document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                alert(message);
                saveState();

                // Clear previous timeout if extending, set new one
                // Note: Simple setTimeout might not be robust for browser closing/reopening. 
                // Relying on expiry check is safer. This timeout is just for the expiry alert.
                setTimeout(() => {
                    if (activePowerUps.doublePoints.active && Date.now() >= activePowerUps.doublePoints.expiry) {
                        activePowerUps.doublePoints.active = false;
                        saveState();
                        alert("Your Double Points Power-Up has expired!");
                    }
                }, activePowerUps.doublePoints.expiry - now + 1000); // Check slightly after expiry
            } else {
                 alert(`Not enough XP! You need ${DOUBLE_POINTS_COST} XP.`);
            }
        }
      }

      // Reminder feature functions
      function startReminderTimer() {
        stopReminderTimer(); // Clear existing timer first
        const inputForm = document.getElementById("inputForm");
        // Only start if the input form is visible
        if (!inputForm || inputForm.style.display !== "block") {
            timeOnInputForm = 0;
            return;
        }

        timeOnInputForm = 0; // Reset timer
        reminderInterval = setInterval(() => {
            // Only count time if the input form is *still* visible
            const currentInputForm = document.getElementById("inputForm");
            if (currentInputForm && currentInputForm.style.display === "block") {
                timeOnInputForm += reminderIntervalTime; // Increment by interval duration
                if (timeOnInputForm >= reminderThreshold) {
                    // Trigger reminder
                    if ("Notification" in window && Notification.permission === "granted") {
                        new Notification("Check Your To-Do List!", {
                            body: "Hey hero, don't forget to review your quests!",
                            icon: "https://img.icons8.com/ios-filled/50/ffffff/checklist.png", // Example icon
                        });
                    } else if ("Notification" in window && Notification.permission !== "denied") {
                        Notification.requestPermission().then((permission) => {
                            if (permission === "granted") {
                                new Notification("Check Your To-Do List!", {
                                    body: "Hey hero, don't forget to review your quests!",
                                    icon: "https://img.icons8.com/ios-filled/50/ffffff/checklist.png",
                                });
                            } else {
                                alert("Reminder: Check your to-do list!");
                            }
                        });
                    } else {
                        alert("Reminder: Check your to-do list!");
                    }
                    timeOnInputForm = 0; // Reset after showing reminder
                }
            } else {
                // Input form became hidden, stop the timer
                stopReminderTimer();
                timeOnInputForm = 0;
            }
        }, reminderIntervalTime); // Check every interval
      }

      function stopReminderTimer() {
        if (reminderInterval) {
          clearInterval(reminderInterval)
          reminderInterval = null
        }
        // timeOnInputForm = 0; // Optionally reset counter when stopping
      }

      // Task deadline functions
      function showDeadlineDialog(taskElement) {
        const dialog = document.getElementById("deadlineDialog")
        if (!dialog) return
        
        currentTaskForDeadline = taskElement;
        const taskIndex = Array.from(document.querySelectorAll(".task-line")).indexOf(currentTaskForDeadline);
        const currentTaskData = tasks[taskIndex] || {};

        
        // Set default date/time or load existing
        const dateInput = document.getElementById("deadlineDate");
        const timeInput = document.getElementById("deadlineTime");
        const difficultySelect = document.getElementById("taskDifficulty");

        if (currentTaskData.deadline) {
            const deadline = new Date(currentTaskData.deadline);
            dateInput.value = deadline.toISOString().split('T')[0];
            timeInput.value = `${deadline.getHours().toString().padStart(2, '0')}:${deadline.getMinutes().toString().padStart(2, '0')}`;
            difficultySelect.value = currentTaskData.points || 50;
        } else {
            // Set default date to tomorrow
            const tomorrow = new Date()
            tomorrow.setDate(tomorrow.getDate() + 1)
            dateInput.value = tomorrow.toISOString().split('T')[0]
            
            // Set default time to current time
            const now = new Date()
            timeInput.value = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`
            difficultySelect.value = 50; // Default difficulty
        }
                
        dialog.style.display = "block";
      }

      function handleDeadlineConfirmation(choice) {
        const dialog = document.getElementById("deadlineDialog")
        if (!dialog || !currentTaskForDeadline) return

        dialog.style.display = "none"
        
        if (choice === "yes") {
          const dateInput = document.getElementById("deadlineDate").value
          const timeInput = document.getElementById("deadlineTime").value
          const difficultySelect = document.getElementById("taskDifficulty")
          const taskPoints = difficultySelect.value
          
          if(!dateInput || !timeInput) {
              alert("Please select both date and time for the deadline.");
              currentTaskForDeadline = null; // Reset context
              return;
          }

          const deadlineDate = new Date(`${dateInput}T${timeInput}`);
          if (isNaN(deadlineDate.getTime())) {
              alert("Invalid date or time selected.");
              currentTaskForDeadline = null; // Reset context
              return;
          }
          
          // Remove existing deadline info if any
          const existingDeadline = currentTaskForDeadline.querySelector(".deadline-info")
          if (existingDeadline) existingDeadline.remove()
          const existingPoints = currentTaskForDeadline.querySelector(".points-info")
          if (existingPoints) existingPoints.remove()

          // Add deadline info to the task element
          const deadlineInfo = document.createElement("span")
          deadlineInfo.className = "deadline-info"
          deadlineInfo.textContent = `Due: ${deadlineDate.toLocaleDateString()} ${deadlineDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`
          
          const pointsInfo = document.createElement("span")
          pointsInfo.className = "points-info"
          pointsInfo.textContent = `+${taskPoints}pts`
          
          // Insert before the remove button
          const removeBtn = currentTaskForDeadline.querySelector(".remove-task");
          if (removeBtn) {
             currentTaskForDeadline.insertBefore(deadlineInfo, removeBtn);
             currentTaskForDeadline.insertBefore(pointsInfo, removeBtn);
          } else {
             currentTaskForDeadline.appendChild(deadlineInfo);
             currentTaskForDeadline.appendChild(pointsInfo);
          }

          
          // Store deadline in task data
          const taskIndex = Array.from(document.querySelectorAll(".task-line")).indexOf(currentTaskForDeadline)
          if (taskIndex !== -1 && tasks[taskIndex]) {
            tasks[taskIndex].deadline = deadlineDate.getTime();
            tasks[taskIndex].points = parseInt(taskPoints);
            tasks[taskIndex].deadlineChecked = false; // Reset checked status if deadline is updated
            saveTasks();
          }
        }
        
        currentTaskForDeadline = null; // Reset context
      }

      function checkTaskDeadlines() {
        const now = Date.now();
        let tasksUpdated = false;
        let pointsChanged = false; // Track if points actually changed
        
        tasks.forEach((task, index) => {
            // Skip tasks without deadlines or already checked past deadline
            if (!task.deadline || task.deadlineChecked) return;
            
            if (now > task.deadline) {
                // Deadline passed
                const basePoints = task.points || 50; // Use task points or default
                if (task.completed) {
                    // Task was completed before or exactly at deadline (let's assume completion marks it)
                    const earnedPoints = applyPowerUps(basePoints); // Apply potential double points
                    points += earnedPoints;
                    // alert(`Quest "${task.text}" completed on time! +${earnedPoints} XP`); // Reduced alerts
                    pointsChanged = true;
                } else {
                    // Task was not completed on time
                    const lostPoints = Math.floor(basePoints / 2); // Lose half base points
                    // alert(`Quest "${task.text}" deadline missed! -${lostPoints} XP`); // Reduced alerts
                    points = Math.max(0, points - lostPoints); // Don't go below 0
                    pointsChanged = true;
                }
                
                // Mark as checked so we don't process it again
                tasks[index].deadlineChecked = true;
                tasksUpdated = true;
            }
        });
        
        if (pointsChanged) {
             document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
             checkLevelUp(); // Check for level up if points changed
        }

        if (tasksUpdated) {
            saveTasks(); // Save the deadlineChecked status
            saveState(); // Save the overall state including points
        }
      }

      // Audio tracks store functions
      function showAudioTracksStore() {
        const store = document.getElementById("audioTracksStore");
        const tracksList = document.getElementById("audioTracksList");
        if (!store || !tracksList) return;
        
        tracksList.innerHTML = ""; // Clear previous list
        
        premiumLofiTracks.forEach(track => {
            const trackItem = document.createElement("div");
            // Use the track's current unlocked status
            trackItem.className = `audio-track-item ${track.unlocked ? 'unlocked' : 'locked'}`;
            
            const trackName = document.createElement("div");
            trackName.className = "track-name";
            trackName.textContent = track.name;
            
            const unlockBtn = document.createElement("button");
            unlockBtn.className = "unlock-track-btn";
            
            if (track.unlocked) {
                unlockBtn.textContent = "UNLOCKED";
                unlockBtn.disabled = true;
            } else {
                unlockBtn.textContent = `UNLOCK (${track.cost} XP)`;
                unlockBtn.disabled = points < track.cost; // Disable if not enough points
                unlockBtn.onclick = () => unlockAudioTrack(track.id); // Set click handler
            }
            
            trackItem.appendChild(trackName);
            trackItem.appendChild(unlockBtn);
            tracksList.appendChild(trackItem);
        });
        
        store.style.display = "block";
      }


      function closeAudioTracksStore() {
        const store = document.getElementById("audioTracksStore")
        if (store) store.style.display = "none"
      }

      function unlockAudioTrack(trackId) {
        const track = premiumLofiTracks.find(t => t.id === trackId)
        // Ensure track exists, is not already unlocked, and user has enough points
        if (!track || track.unlocked || points < track.cost) {
            if(track && !track.unlocked && points < track.cost) {
                alert("Not enough XP to unlock this track!");
            }
            return;
        }
        
        // Deduct points and unlock the track
        points -= track.cost;
        track.unlocked = true; // Update the track object status
        
        // Re-initialize audio to update the lofiSongs list
        initAudio(); 
        
        // Update UI
        document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
        alert(`Successfully unlocked "${track.name}"!`);
        
        // Refresh the store display to show the updated status and disable button
        showAudioTracksStore();
        saveState(); // Save the new points and unlocked track status
      }


      // Session complete dialog
      function showSessionCompleteDialog() {
        const dialog = document.getElementById("sessionCompleteDialog")
        if (!dialog) return
        dialog.style.display = "block"
      }

      function handleSessionContinue(choice) {
        const dialog = document.getElementById("sessionCompleteDialog")
        if (!dialog) return
        
        dialog.style.display = "none"
        
        if (choice === "continue") {
          // Award bonus points
          const bonusPoints = applyPowerUps(100); // Apply potential double points
          points += bonusPoints;
          document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
          checkLevelUp(); // Check level up after adding points
          
          // Start a new focus session
          startTimer(focusDuration, "Focus Time"); // Use the main focus duration
        } else {
          // End the session (effectively means do nothing further here, timer already stopped)
          endFocusSession(); // Ensure state is clean
        }
        
        saveState(); // Save points and potentially other state changes
      }

      function loadSavedState() {
        try {
          const savedState = localStorage.getItem("focusModeState");
          
           // Always hide progress bar on initial load, timer will show it if needed
           const progressBar = document.getElementById("progressBar");
           if (progressBar) progressBar.style.display = "none";

          if (savedState) {
            const state = JSON.parse(savedState);
            videoIds = state.videoIds || [];
            currentVideoIndex = state.currentVideoIndex || 0;
            distractionCount = state.distractionCount || 0; // May not be used actively, but load it
            points = state.points || 0;
            previousPoints = points; // Sync previous points for level up check
            timerMode = state.timerMode || "Focus Time";
            timerRemaining = state.timerRemaining || focusDuration / 1000;
            isFocusModeActive = state.isFocusModeActive || false;
            isSignedIn = state.isSignedIn || false;
            currentUser = state.currentUser || null;
            completedVideos = new Set(state.completedVideos || []);
            allVideosCompleted = state.allVideosCompleted || false;
            totalFocusTime = state.totalFocusTime || 0; // In seconds
            totalDistractions = state.totalDistractions || 0;
            totalVideosWatched = state.totalVideosWatched || 0;
            streakDays = state.streakDays || 0;
            lastFocusDate = localStorage.getItem("lastFocusDate") || null; // Load separately
            mysteryBoxCount = state.mysteryBoxCount || 0;
            activePowerUps = state.activePowerUps || {
              doublePoints: { active: false, expiry: null },
              streakShield: { active: false, used: false, expiry: null },
            };
            
            // Load premium tracks state and update the master list
            if (state.premiumLofiTracks) {
                state.premiumLofiTracks.forEach(savedTrack => {
                    const track = premiumLofiTracks.find(t => t.id === savedTrack.id);
                    if (track) {
                        track.unlocked = savedTrack.unlocked; // Update master track object
                    }
                });
            }
            initAudio(); // Rebuild lofiSongs array based on loaded unlock status


            updateAnalytics();
            updateAchievementLevel();
            updateStreak(); // Recalculate streak based on loaded lastFocusDate
            
            if (isSignedIn && currentUser) {
              // User was logged in
              document.getElementById("landingPage").style.display = "none";
              document.getElementById("signinForm").style.display = "none";
              document.getElementById("inputForm").style.display = "block";
              document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
              document.getElementById("clockDisplay").style.display = "block";
              // Removed sitesBox display toggle
              document.getElementById("lofiPlayer").style.display = "block";
              restoreUrlInputs(); // Restore URLs if they were in input mode
              populatePlaylistSelect();
              restoreTasks();
              startReminderTimer(); // Start reminder if on input form
              if (mysteryBoxCount > 0) showMysteryBoxPopup();
              updateSidebarDashboard(); // Update sidebar with user info
            } else {
              // User was not logged in or state is corrupted
               document.getElementById("landingPage").style.display = "block";
               document.getElementById("signinForm").style.display = "none";
               document.getElementById("inputForm").style.display = "none";
               document.getElementById("clockDisplay").style.display = "none";
               // Removed sitesBox display toggle
               document.getElementById("lofiPlayer").style.display = "none";
               stopReminderTimer();
               updateAnalytics(); // Update with default/zero values if needed
               updateAchievementLevel(); // Show default level
               updateStreak(); // Show default streak
               restoreTasks(); // Restore default task line
               updateSidebarDashboard(); // Show Guest in sidebar
            }

            if (isFocusModeActive && videoIds.length > 0) {
              // User was in an active focus session
              document.getElementById("inputForm").style.display = "none";
              document.getElementById("player").style.display = "block";
              document.getElementById("restartBtn").style.display = "block";
              document.getElementById("pdfToggle").style.display = "block";
              document.getElementById("clockDisplay").style.display = "none"; // Hide clock during focus
              // Removed sitesBox display toggle
              document.getElementById("lofiPlayer").style.display = "none"; // Hide lofi player during focus video
              stopReminderTimer(); // Stop input form reminder

              loadYouTubeAPI()
                .then(() => {
                  setupYouTubePlayer();
                  // Resume timer with remaining time
                  startTimer(timerRemaining * 1000, timerMode); 
                })
                .catch((err) => {
                     console.error("YouTube API load failed on resume:", err);
                     alert("Failed to resume YouTube player. Restarting session.");
                     handleRestartConfirmation("yes"); // Force restart if API fails
                });
            } else if (!isSignedIn && !isFocusModeActive) {
                 // Ensure landing page is shown if not signed in and not focusing
                 document.getElementById("landingPage").style.display = "block";
                 document.getElementById("signinForm").style.display = "none";
                 document.getElementById("inputForm").style.display = "none";
            }

          } else {
            // No saved state found, show landing page
            document.getElementById("landingPage").style.display = "block";
            document.getElementById("signinForm").style.display = "none";
            document.getElementById("inputForm").style.display = "none";
            document.getElementById("clockDisplay").style.display = "none";
            // Removed sitesBox display toggle
            document.getElementById("lofiPlayer").style.display = "none";
            stopReminderTimer();
            updateAnalytics();
            updateAchievementLevel();
            updateStreak();
            restoreTasks(); // Add the initial task line
            initAudio(); // Init with default tracks
             updateSidebarDashboard(); // Show Guest
          }
        } catch (err) {
          console.error("Load saved state error:", err);
          // Attempt to reset to a clean state
           localStorage.removeItem("focusModeState");
           localStorage.removeItem("users"); // Consider clearing users too, or handle more gracefully
           logout(); // Use logout function to reset UI to default logged-out state
           alert("Error loading saved data. Resetting application state.");
        }
      }


      function redirectToPYQs() {
        window.open("https://room.examgoal.com/", "_blank")
      }

      function showSignIn() {
        document.getElementById("landingPage").style.display = "none"
        document.getElementById("signinForm").style.display = "block"
        document.getElementById("inputForm").style.display = "none"
        document.getElementById("clockDisplay").style.display = "none"
        // Removed sitesBox display toggle
        document.getElementById("lofiPlayer").style.display = "none"
        stopReminderTimer()
      }

      function signIn() {
        try {
          const usernameInput = document.getElementById("username");
          const passwordInput = document.getElementById("password");
          const username = usernameInput.value.trim();
          const password = passwordInput.value; // No trim on password

          if (!username || !password) {
              alert("Please enter both Hero Name and Secret Code.");
              return;
          }

          const users = JSON.parse(localStorage.getItem("users") || "{}");

          if (users[username] && users[username].password === password) {
            // Successful login
            isSignedIn = true;
            currentUser = username;
            const userData = users[username];
            points = userData.points || 0;
            previousPoints = points; // Sync for level check
            totalFocusTime = userData.totalFocusTime || 0;
            totalDistractions = userData.totalDistractions || 0;
            totalVideosWatched = userData.totalVideosWatched || 0;
            tasks = userData.tasks || [];
            streakDays = userData.streakDays || 0;
            // Ensure lastFocusDate is loaded from localStorage for accurate streak check
            lastFocusDate = localStorage.getItem("lastFocusDate") || null; 
            mysteryBoxCount = userData.mysteryBoxCount || 0;
            activePowerUps = userData.activePowerUps || {
              doublePoints: { active: false, expiry: null },
              streakShield: { active: false, used: false, expiry: null },
            };
            
            // Load premium tracks unlock status for this user
            if (userData.premiumLofiTracks) {
                userData.premiumLofiTracks.forEach(savedTrack => {
                    const track = premiumLofiTracks.find(t => t.id === savedTrack.id);
                    if (track) {
                        track.unlocked = savedTrack.unlocked;
                    }
                });
            } else {
                 // If user data doesn't have track info, reset premium tracks to locked
                 premiumLofiTracks.forEach(track => track.unlocked = false);
            }
            initAudio(); // Rebuild song list based on user's unlocked tracks

            
            // Update UI
            document.getElementById("landingPage").style.display = "none";
            document.getElementById("signinForm").style.display = "none";
            document.getElementById("inputForm").style.display = "block";
            document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
            document.getElementById("clockDisplay").style.display = "block";
            // Removed sitesBox display toggle
            document.getElementById("lofiPlayer").style.display = "block";
            
            updateAnalytics();
            updateAchievementLevel();
            updateStreak(); // Crucial to call after loading user data and lastFocusDate
            saveState(); // Save the current logged-in state
            populatePlaylistSelect(); // Load user's playlists if stored per user, or global ones
            restoreTasks(); // Load user's tasks
            startReminderTimer(); // Start reminder now that input form is shown
            if (mysteryBoxCount > 0) showMysteryBoxPopup();
            updateSidebarDashboard(); // Update sidebar with user's name, level etc.

             // Clear password field after successful login
             passwordInput.value = "";

          } else {
              alert("Invalid Hero Name or Secret Code.");
               passwordInput.value = ""; // Clear password field on failure
          }
        } catch (err) {
          console.error("Sign-in error:", err)
          alert("Error during sign-in. Please try again.")
        }
      }

      function createAccount() {
        try {
          const usernameInput = document.getElementById("username");
          const passwordInput = document.getElementById("password");
          const username = usernameInput.value.trim();
          const password = passwordInput.value;

           if (!username || !password) {
              alert("Please enter both a Hero Name and a Secret Code.");
              return;
           }
           if (password.length < 4) { // Example minimum length
              alert("Secret Code must be at least 4 characters long.");
              return;
           }


          const users = JSON.parse(localStorage.getItem("users") || "{}");

          if (users[username]) {
              alert("Hero Name already exists. Please choose another.");
          } else {
             // Create new user entry
            users[username] = {
              password, // Store the password (consider hashing in a real app)
              points: 0,
              totalFocusTime: 0,
              totalDistractions: 0,
              totalVideosWatched: 0,
              tasks: [],
              streakDays: 0,
              // lastFocusDate: null, // Managed globally for simplicity, or store per user if needed
              mysteryBoxCount: 0,
              activePowerUps: {
                doublePoints: { active: false, expiry: null },
                streakShield: { active: false, used: false, expiry: null },
              },
              // Initialize premium tracks as locked for the new user
              premiumLofiTracks: premiumLofiTracks.map(track => ({
                id: track.id,
                unlocked: false // Ensure all start locked
              }))
            };
            localStorage.setItem("users", JSON.stringify(users));

            // Automatically sign in the new user
            isSignedIn = true;
            currentUser = username;
            points = 0;
            previousPoints = 0;
            totalFocusTime = 0;
            totalDistractions = 0;
            totalVideosWatched = 0;
            tasks = [];
            streakDays = 0;
            lastFocusDate = null; // Reset last focus date for new user
            localStorage.removeItem("lastFocusDate"); // Clear global last focus date too
            mysteryBoxCount = 0;
            activePowerUps = {
              doublePoints: { active: false, expiry: null },
              streakShield: { active: false, used: false, expiry: null },
            };
             // Reset premium tracks in memory to locked state for the new user session
             premiumLofiTracks.forEach(track => track.unlocked = false);
             initAudio(); // Initialize audio with only free tracks

            // Update UI for the newly created and logged-in user
            document.getElementById("landingPage").style.display = "none";
            document.getElementById("signinForm").style.display = "none";
            document.getElementById("inputForm").style.display = "block";
            document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
            document.getElementById("clockDisplay").style.display = "block";
            // Removed sitesBox display toggle
            document.getElementById("lofiPlayer").style.display = "block";

            updateAnalytics();
            updateAchievementLevel();
            updateStreak(); // Should show 0 days initially
            saveState(); // Save the initial state for the new user
            populatePlaylistSelect(); // Populate with global playlists
            restoreTasks(); // Show empty task list or default line
            startReminderTimer();
            updateSidebarDashboard();

            // Clear form fields
            usernameInput.value = "";
            passwordInput.value = "";

            alert(`Account "${username}" created successfully! Welcome, hero!`);

          }
        } catch (err) {
          console.error("Account creation error:", err)
          alert("Error creating account. Please try again.")
        }
      }

      function addUrlInput() {
        const urlInputs = document.getElementById("urlInputs")
        if (!urlInputs) return

        const container = document.createElement("div")
        container.className = "url-container"
        
        const newInput = document.createElement("input")
        newInput.type = "text"
        newInput.className = "youtube-url"
        newInput.placeholder = "YouTube URL (Videos or Live Streams)"
        
        const removeBtn = document.createElement("button")
        removeBtn.textContent = "X"
        removeBtn.onclick = () => {
          // Only allow removal if it's not the last input field
          if (urlInputs.children.length > 1) {
              urlInputs.removeChild(container);
          } else {
              alert("You must have at least one URL input field.");
          }
        }
        
        container.appendChild(newInput)
        container.appendChild(removeBtn) // Add remove button next to the input
        urlInputs.appendChild(container)
        newInput.focus(); // Focus the newly added input field
      }

      function restoreUrlInputs() {
        const urlInputs = document.getElementById("urlInputs")
        if (!urlInputs) return

        urlInputs.innerHTML = "" // Clear existing inputs
        
        if (videoIds.length === 0) {
            // If no video IDs are loaded, show one empty input field
             addUrlInput(); // Use the function to create the initial input correctly
             // Ensure the first input doesn't have a remove button or disable it
             const firstRemoveBtn = urlInputs.querySelector('.url-container button');
             if(firstRemoveBtn) firstRemoveBtn.remove(); // Or disable: firstRemoveBtn.disabled = true;

        } else {
            // Restore inputs based on loaded videoIds
            videoIds.forEach((id, index) => {
                const container = document.createElement("div");
                container.className = "url-container";
                
                const input = document.createElement("input");
                input.type = "text";
                input.className = "youtube-url";
                input.placeholder = "YouTube URL (Videos or Live Streams)";
                // Reconstruct the full URL for display, might be null if ID was added directly
                input.value = id ? `https://www.youtube.com/watch?v=${id}` : ""; 
                container.appendChild(input);

                // Add remove button for all except the first one
                if (index > 0 || videoIds.length > 1) { // Add button if it's not the *only* one
                    const removeBtn = document.createElement("button");
                    removeBtn.textContent = "X";
                    removeBtn.onclick = () => {
                        if (urlInputs.children.length > 1) {
                             urlInputs.removeChild(container);
                             // Optional: Update videoIds array immediately after removing UI element
                             // videoIds = Array.from(urlInputs.querySelectorAll(".youtube-url"))
                             //                 .map(inp => extractVideoId(inp.value))
                             //                 .filter(vidId => vidId);
                             // saveState(); // If immediate update is desired
                        } else {
                             alert("You must have at least one URL input field.");
                        }
                    };
                    container.appendChild(removeBtn);
                }
                 urlInputs.appendChild(container);
            });
            // If after restoring, there's only one input, remove its delete button
            if(urlInputs.children.length === 1) {
                 const firstRemoveBtn = urlInputs.querySelector('.url-container button');
                 if(firstRemoveBtn) firstRemoveBtn.remove();
            }
        }
      }


      function addTaskLine(taskData = { text: "", completed: false }) {
          const tasksDiv = document.getElementById("tasks");
          if (!tasksDiv) return null;

          const container = document.createElement("div");
          container.className = "task-line";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "task-check";
          checkbox.checked = taskData.completed;
          checkbox.onchange = () => saveTasks(); // Save on check/uncheck

          const input = document.createElement("input");
          input.type = "text";
          input.className = "task-text";
          input.value = taskData.text;
          input.placeholder = "Add a quest...";
          input.onkeydown = (e) => {
              if (e.key === "Enter" && !e.shiftKey) { // Enter adds new task
                  e.preventDefault();
                  const nextInput = addTaskLine(); // Add a new empty line
                  if (nextInput) nextInput.focus();
                  saveTasks(); // Save current task text before moving
              }
          };
          input.onblur = () => saveTasks(); // Save when focus is lost

          const deadlineBtn = document.createElement("button");
          deadlineBtn.className = "set-deadline";
          deadlineBtn.textContent = "‚è∞";
          deadlineBtn.title = "Set Deadline & Points"; // Tooltip
          deadlineBtn.onclick = () => showDeadlineDialog(container);

          const removeBtn = document.createElement("span");
          removeBtn.className = "remove-task";
          removeBtn.textContent = "x";
          removeBtn.title = "Remove Task"; // Tooltip
          removeBtn.onclick = () => {
                if (tasksDiv.children.length > 1) { // Prevent removing the last line
                    tasksDiv.removeChild(container);
                    saveTasks(); // Save after removing
                } else {
                     // Clear the text of the last line instead of removing it
                     input.value = "";
                     checkbox.checked = false;
                     const deadlineInfo = container.querySelector(".deadline-info");
                     const pointsInfo = container.querySelector(".points-info");
                     if(deadlineInfo) deadlineInfo.remove();
                     if(pointsInfo) pointsInfo.remove();
                     saveTasks(); // Save the cleared state
                }
          };

          container.appendChild(checkbox);
          container.appendChild(input);
          container.appendChild(deadlineBtn); // Add deadline button

           // Add deadline/points info if it exists in taskData
           if (taskData.deadline) {
               const deadlineDate = new Date(taskData.deadline);
               const deadlineInfo = document.createElement("span");
               deadlineInfo.className = "deadline-info";
               deadlineInfo.textContent = `Due: ${deadlineDate.toLocaleDateString()} ${deadlineDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
               container.appendChild(deadlineInfo); // Append after deadline button

               if(taskData.points) {
                    const pointsInfo = document.createElement("span");
                    pointsInfo.className = "points-info";
                    pointsInfo.textContent = `+${taskData.points}pts`;
                    container.appendChild(pointsInfo); // Append after deadline info
               }
           }

          container.appendChild(removeBtn); // Append remove button last
          tasksDiv.appendChild(container);
          return input; // Return the input element for potential focus
      }


      function removeTask(element) {
         // This function is now integrated into the logic within addTaskLine's removeBtn.onclick
         // It ensures the last line is cleared instead of removed.
         console.warn("removeTask(element) called directly, logic moved to button handler inside addTaskLine.");
         // Optional: Find the button and trigger its click event?
         // element.click(); // Might be problematic if 'element' isn't the button itself.
      }


      function restoreTasks() {
          const tasksDiv = document.getElementById("tasks");
          if (!tasksDiv) return;

          tasksDiv.innerHTML = ""; // Clear existing task lines

          if (!tasks || tasks.length === 0) {
              // If no tasks are loaded, add one empty default task line
              addTaskLine();
          } else {
              // Restore tasks from the loaded data
              tasks.forEach((task) => {
                  addTaskLine(task); // Use addTaskLine to create each row with its data
              });
              // Optional: Add an empty line at the end for easy new task entry?
              // addTaskLine(); 
          }
          
          // Check for any passed deadlines on load
          checkTaskDeadlines();
      }


      function saveTasks() {
          const taskLines = document.querySelectorAll("#tasks .task-line");
          if (!taskLines.length) {
              tasks = []; // Clear tasks if no lines exist
          } else {
               tasks = Array.from(taskLines)
                  .map((line, index) => {
                      const checkbox = line.querySelector(".task-check");
                      const input = line.querySelector(".task-text");
                      
                      // Preserve existing deadline data if it wasn't modified via dialog
                      // The deadline dialog updates the 'tasks' array directly now.
                      const existingTaskData = tasks[index] || {}; // Get potentially existing data
                      
                      const textValue = input ? input.value.trim() : "";
                      const completedValue = checkbox ? checkbox.checked : false;

                      // Only return the task if it has text
                      if (textValue) {
                           return {
                              text: textValue,
                              completed: completedValue,
                              deadline: existingTaskData.deadline || null, // Keep existing deadline
                              points: existingTaskData.points || null,     // Keep existing points
                              deadlineChecked: existingTaskData.deadlineChecked || false // Keep checked status
                           };
                      }
                      return null; // Return null for empty lines to filter them out
                  })
                  .filter(task => task !== null); // Remove null entries (empty lines)
          }

          // If all tasks were empty and filtered out, add one default empty task back
          if (tasks.length === 0 && taskLines.length > 0) {
               const firstLineInput = taskLines[0].querySelector('.task-text');
               if(firstLineInput && !firstLineInput.value.trim()) {
                  // Keep the single empty line object in the tasks array if it was the only line
                  tasks = [{ text: "", completed: false, deadline: null, points: null, deadlineChecked: false }];
               }
          } else if (tasks.length === 0 && taskLines.length === 0) {
               // If the div became empty, ensure at least one task object exists for restoreTasks
                tasks = [{ text: "", completed: false, deadline: null, points: null, deadlineChecked: false }];
                addTaskLine(); // Add the UI element back too
          }


          localStorage.setItem("tasks", JSON.stringify(tasks)); // Save globally (might be overwritten by user-specific save)
          
          saveState(); // Call saveState to handle user-specific saving if logged in
      }

      function toggleTodo() {
        const todoList = document.getElementById("todoList")
        if (!todoList) return
        const isVisible = todoList.style.display === "block";
        todoList.style.display = isVisible ? "none" : "block";
        
        // If opening the list, ensure there's at least one line and focus it if empty
        if (!isVisible) {
             const tasksDiv = document.getElementById("tasks");
             if (tasksDiv && tasksDiv.children.length === 0) {
                 addTaskLine(); // Add initial line if empty
             }
             const firstInput = tasksDiv.querySelector('.task-text');
             if (firstInput && !firstInput.value.trim()) {
                 //firstInput.focus(); // Focus the first empty input
             }
        }
      }

      function extractVideoId(url) {
        if (!url) return null;
        try {
          // Standard YouTube links
          let videoId = new URL(url).searchParams.get("v");
          if (videoId && videoId.length === 11) return videoId;

          // Shortened YouTube links (youtu.be/)
          if (url.includes("youtu.be/")) {
            videoId = url.split("youtu.be/")[1]?.split(/[?&]/)[0];
            if (videoId && videoId.length === 11) return videoId;
          }
          
          // YouTube Live links (/live/videoId)
          if (url.includes("/live/")) {
             videoId = url.split("/live/")[1]?.split(/[?&/]/)[0];
              if (videoId && videoId.length === 11) return videoId;
          }

          // YouTube Shorts links (/shorts/videoId)
          if (url.includes("/shorts/")) {
            videoId = url.split("/shorts/")[1]?.split(/[?&]/)[0];
            if (videoId && videoId.length === 11) return videoId;
          }

          // Embedded links (/embed/videoId)
          if (url.includes("/embed/")) {
            videoId = url.split("/embed/")[1]?.split(/[?&]/)[0];
            if (videoId && videoId.length === 11) return videoId;
          }

          console.warn("Could not extract video ID from URL:", url);
          return null; // Return null if no valid ID found

        } catch (e) {
          // Handle cases where URL parsing fails (e.g., just an ID entered)
           if(typeof url === 'string' && url.length === 11 && !url.includes('/')) {
               return url; // Assume it's a raw video ID
           }
          console.error("Error parsing URL:", url, e);
          return null;
        }
      }


      function startPlayback() {
        try {
          const urlInputs = document.querySelectorAll("#urlInputs .youtube-url");
          if (!urlInputs.length) {
              alert("URL input elements not found.");
              return;
          }

          const urls = Array.from(urlInputs)
                           .map((input) => input.value.trim())
                           .filter((url) => url); // Filter out empty inputs

          if (!urls.length) {
            alert("Please enter at least one YouTube URL.");
            return;
          }

          videoIds = urls.map((url) => extractVideoId(url)).filter((id) => id); // Extract and filter valid IDs

          if (videoIds.length === 0) {
            alert("No valid YouTube video IDs found in the provided URLs.");
            return;
          }
          
          // Reset playback state for the new list
          currentVideoIndex = 0;
          completedVideos.clear();
          allVideosCompleted = false;

          // Update UI
          document.getElementById("inputForm").style.display = "none";
          document.getElementById("player").style.display = "block";
          document.getElementById("restartBtn").style.display = "block";
          document.getElementById("pdfToggle").style.display = "block";
          document.getElementById("clockDisplay").style.display = "none"; // Hide clock
          // Removed sitesBox toggle
          document.getElementById("lofiPlayer").style.display = "none"; // Hide lofi during video
          stopReminderTimer(); // Stop input form reminder

          loadYouTubeAPI()
            .then(() => {
              setupYouTubePlayer(); // Setup player with the first video ID
              startTimer(focusDuration, "Focus Time"); // Start the focus timer
              saveState(); // Save the new state (videoIds, focus active)
            })
            .catch((err) => {
              console.error("YouTube API load failed:", err);
              alert("Failed to load YouTube player. Please check your connection and try again.");
              // Optionally revert UI back to input form
              handleRestartConfirmation("yes"); // Use restart logic to clean up UI
            });
        } catch (err) {
          console.error("Start playback error:", err);
          alert("An error occurred while starting playback.");
        }
      }


      function loadYouTubeAPI() {
          return new Promise((resolve, reject) => {
              // Check if the API is already loaded or loading
              if (typeof YT !== 'undefined' && YT.Player) {
                  console.log("YouTube API already loaded.");
                  isYouTubeAPILoaded = true;
                  resolve();
                  return;
              }
              
              // Check if the script tag already exists
              if (document.querySelector('script[src="https://www.youtube.com/iframe_api"]')) {
                   console.log("YouTube API script tag exists, waiting for ready...");
                   // If script exists but YT is not ready, wait for the callback
                   // This requires onYouTubeIframeAPIReady to be defined globally *before* this check might happen in edge cases
                   if (window.onYouTubeIframeAPIReady) {
                      // Temporarily override to resolve the promise
                      const originalCallback = window.onYouTubeIframeAPIReady;
                      window.onYouTubeIframeAPIReady = () => {
                           console.log("onYouTubeIframeAPIReady triggered (existing script).");
                           isYouTubeAPILoaded = true;
                           originalCallback && originalCallback(); // Call original if it existed
                           resolve();
                      };
                   } else {
                        // Define it to resolve the promise when ready
                         window.onYouTubeIframeAPIReady = () => {
                              console.log("onYouTubeIframeAPIReady triggered (existing script, new definition).");
                              isYouTubeAPILoaded = true;
                              resolve();
                         };
                   }
                   // It might already be ready, check again shortly
                   setTimeout(() => {
                       if (typeof YT !== 'undefined' && YT.Player) {
                            console.log("YouTube API became ready after short delay.");
                            isYouTubeAPILoaded = true;
                            resolve();
                       }
                   }, 500); // Wait 500ms
                   return; 
              }

              console.log("Loading YouTube API...");
              // Define the global callback function *before* adding the script tag
              window.onYouTubeIframeAPIReady = () => {
                   console.log("onYouTubeIframeAPIReady triggered (new script).");
                   isYouTubeAPILoaded = true;
                   resolve();
              };

              // Add the script tag to the page
              const tag = document.createElement("script");
              tag.src = "https://www.youtube.com/iframe_api";
              tag.onerror = (error) => {
                   console.error("Failed to load YouTube API script:", error);
                   reject(new Error("Failed to load YouTube API script"));
              };
              document.head.appendChild(tag);
          });
      }

      function setupYouTubePlayer() {
        if (!videoIds || videoIds.length === 0 || currentVideoIndex >= videoIds.length) {
             console.error("Cannot setup player: No valid video IDs or index out of bounds.");
             // Maybe trigger end of session or UI reset?
             handleRestartConfirmation("yes"); 
             return;
        }

        const playerDivId = "player"; // The ID of the div where the player should be embedded
        const playerDiv = document.getElementById(playerDivId);
        if (!playerDiv) {
            console.error(`Player div with ID "${playerDivId}" not found.`);
            return;
        }

        // If a player instance already exists, destroy it first
        if (player && typeof player.destroy === 'function') {
             console.log("Destroying existing player instance.");
             player.destroy();
             player = null; // Ensure the old reference is cleared
        }

         console.log(`Setting up player for video ID: ${videoIds[currentVideoIndex]} at index ${currentVideoIndex}`);
        
        try {
            player = new YT.Player(playerDivId, {
              // Setting height/width explicitly can sometimes override CSS aspect-ratio.
              // Rely on CSS for sizing if possible, but YT API might require dimensions.
              // height: "100%", // Let CSS handle this via aspect-ratio
              // width: "100%", 
              videoId: videoIds[currentVideoIndex],
              playerVars: {
                'autoplay': 1,        // Autoplay the video
                'controls': 1,        // Show player controls
                'modestbranding': 1,  // Reduce YouTube logo
                'rel': 0,             // Do not show related videos at the end
                'showinfo': 0,        // Hide video title and uploader (deprecated but good practice)
                'iv_load_policy': 3,  // Hide video annotations
                'fs': 1               // Allow fullscreen
              },
              events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange,
                'onError': onPlayerError // Add error handling
              },
            });
            console.log("YT.Player instance created.");
            setupVideoSidebar(); // Update sidebar with thumbnails
        } catch (error) {
             console.error("Error creating YT.Player instance:", error);
             alert("Could not create the YouTube player. Please try again.");
             handleRestartConfirmation("yes"); // Reset UI on critical player error
        }
      }

      function onPlayerReady(event) {
         console.log("Player ready for video:", event.target.getVideoData().title);
         // Autoplay is set in playerVars, but sometimes calling playVideo here helps consistency
         event.target.playVideo();
      }

      function onPlayerStateChange(event) {
         console.log("Player state changed:", event.data);
         const currentState = event.data;

         if (currentState === YT.PlayerState.ENDED) {
             console.log(`Video ended: ${videoIds[currentVideoIndex]}`);
             if (!completedVideos.has(videoIds[currentVideoIndex])) {
                 completedVideos.add(videoIds[currentVideoIndex]);
                 totalVideosWatched++;
                 const videoPoints = applyPowerUps(50); // Points for completing a video
                 points += videoPoints;
                 console.log(`Awarded ${videoPoints} XP for completing video. Total XP: ${points}`);
                 document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                 checkLevelUp();
                 updateAnalytics(); // Update stats display
                 saveState(); // Save progress
             } else {
                  console.log("Video rewatched, no additional points.");
             }

             currentVideoIndex++; // Move to the next video index

             if (currentVideoIndex < videoIds.length) {
                 // Load the next video
                 console.log(`Loading next video ID: ${videoIds[currentVideoIndex]} at index ${currentVideoIndex}`);
                 if (player && typeof player.loadVideoById === 'function') {
                    player.loadVideoById(videoIds[currentVideoIndex]);
                 } else {
                     console.error("Player object invalid, cannot load next video.");
                     handleRestartConfirmation("yes"); // Critical error, reset
                 }
             } else {
                 // All videos in the list have been played
                 console.log("All videos completed.");
                 allVideosCompleted = true;
                 endFocusSession(); // End the session gracefully
                 alert("Congratulations! You've completed all videos in this session.");
                 // Consider showing the input form again or a summary screen
                 handleRestartConfirmation("yes"); // Go back to input form for now
             }
         } else if (currentState === YT.PlayerState.PLAYING) {
             // Optional: Could add logic here if needed when playing starts/resumes
         } else if (currentState === YT.PlayerState.PAUSED) {
             // Optional: Could add logic for pausing, e.g., pausing timer? (Current setup doesn't)
         } else if (currentState === YT.PlayerState.BUFFERING) {
             // Optional: Handle buffering state if necessary
         } else if (currentState === YT.PlayerState.CUED) {
             // Optional: Video is cued and ready to play
         }
      }

      function onPlayerError(event) {
         console.error("YouTube Player Error:", event.data);
         // Handle different error codes
         let errorMessage = "An error occurred with the YouTube player.";
         switch (event.data) {
             case 2: // Invalid parameter
                 errorMessage = "Invalid video ID or player parameter. Skipping video.";
                 break;
             case 5: // HTML5 player error
                 errorMessage = "An error occurred in the HTML5 player. Skipping video.";
                 break;
             case 100: // Video not found or removed
                 errorMessage = "Video not found or removed by the uploader. Skipping video.";
                 break;
             case 101: // Playback forbidden by uploader
             case 150: // Playback forbidden by uploader (same as 101)
                 errorMessage = "The uploader has disabled playback on embedded players. Skipping video.";
                 break;
             default:
                 errorMessage = `Player error code: ${event.data}. Skipping video.`;
         }
         alert(errorMessage);

         // Attempt to recover by skipping to the next video
         currentVideoIndex++;
         if (currentVideoIndex < videoIds.length) {
             if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(videoIds[currentVideoIndex]);
             } else {
                handleRestartConfirmation("yes"); // Cannot recover if player is gone
             }
         } else {
             // Error on the last video
             allVideosCompleted = true; // Mark as completed since we can't play it
             endFocusSession();
             alert("Finished session due to error on the last video.");
             handleRestartConfirmation("yes"); // Go back to input form
         }
         saveState(); // Save state after handling error
      }


      function setupVideoSidebar() {
        const sidebar = document.getElementById("videoSidebar")
        if (!sidebar) return

        // Clear previous content except the minimize button
        sidebar.innerHTML = '<button id="minimizeBtn">-</button>'; // Keep/re-add minimize button
        const minimizeBtn = sidebar.querySelector("#minimizeBtn");
        if (minimizeBtn) minimizeBtn.onclick = toggleVideoSidebar; // Re-attach listener


        if(!videoIds || videoIds.length === 0) {
           sidebar.style.right = "-320px"; // Hide sidebar if no videos
           return;
        }

        videoIds.forEach((id, index) => {
          const thumbnail = document.createElement("img")
          thumbnail.src = `https://img.youtube.com/vi/${id}/mqdefault.jpg` // Medium quality thumbnail
          thumbnail.alt = `Video ${index + 1} Thumbnail`;
          thumbnail.className = "thumbnail"
          thumbnail.title = `Play Video ${index + 1}`; // Tooltip
          thumbnail.loading = "lazy"; // Lazy load images
          thumbnail.onclick = () => {
             if (player && typeof player.loadVideoById === 'function') {
                if (index !== currentVideoIndex) { // Only load if it's a different video
                    console.log(`Sidebar click: Loading video index ${index}, ID: ${id}`);
                    currentVideoIndex = index; // Update the current index
                    player.loadVideoById(id);
                    saveState(); // Save the new index
                } else {
                    console.log("Sidebar click: Clicked on the currently playing video.");
                    // Optional: Toggle play/pause?
                    // const state = player.getPlayerState();
                    // if (state === YT.PlayerState.PLAYING) player.pauseVideo();
                    // else if (state === YT.PlayerState.PAUSED) player.playVideo();
                }
             } else {
                console.error("Player not available to handle sidebar click.");
             }
          }
          sidebar.appendChild(thumbnail)
        });
        sidebar.style.right = "0"; // Ensure sidebar is visible
      }

      function startTimer(durationMs, mode) {
          const timerDisplay = document.getElementById("timerDisplay");
          const timerTextSpan = document.getElementById("timerText");
          const progressFill = document.getElementById("progressFill");
          const progressBar = document.getElementById("progressBar");
          if (!timerDisplay || !timerTextSpan || !progressFill || !progressBar) {
              console.error("Timer UI elements not found!");
              return;
          }

          clearInterval(countdownInterval); // Clear any existing timer interval

          isFocusModeActive = true;
          timerMode = mode;
          timerRemaining = Math.max(0, durationMs / 1000); // Ensure non-negative time in seconds
          const totalDurationSeconds = durationMs / 1000;

          progressBar.style.display = "block"; // Show progress bar

          if (mode === "Focus Time") {
               updateStreak(); // Update streak only when starting a focus session
          }

          console.log(`Starting timer: ${mode}, Duration: ${durationMs}ms (${timerRemaining}s)`);

          countdownInterval = setInterval(() => {
              const minutes = Math.floor(timerRemaining / 60);
              const seconds = Math.floor(timerRemaining % 60);
              timerTextSpan.textContent = `${timerMode}: ${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
              
              // Update progress bar
              const progress = totalDurationSeconds > 0 ? ((totalDurationSeconds - timerRemaining) / totalDurationSeconds) * 100 : 0;
              progressFill.style.width = `${Math.min(100, progress)}%`; // Cap progress at 100%

              // Increment total focus time only during Focus Time mode
              if (timerMode === "Focus Time") {
                  totalFocusTime++; // Increment total focus time in seconds
              }

              timerRemaining--; // Decrement remaining time

              if (timerRemaining < 0) {
                  // Timer finished
                  clearInterval(countdownInterval);
                  progressBar.style.display = "none"; // Hide progress bar
                  console.log(`Timer finished: ${timerMode}`);

                  if (timerMode === "Focus Time") {
                      const focusPoints = applyPowerUps(100); // Points for completing focus session
                      points += focusPoints;
                      document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                      console.log(`Awarded ${focusPoints} XP for focus session. Total XP: ${points}`);
                      checkLevelUp();
                      updateAnalytics(); // Update stats display
                      playFocusAudio(); // Play sound cue
                      
                      // Show session complete dialog instead of automatically starting break
                      showSessionCompleteDialog(); 
                      // Note: saveState() is called within handleSessionContinue or endFocusSession

                  } else if (timerMode === "Break Time" || timerMode === "Short Break") {
                       // After any break, go back to Focus Time
                       alert("Break's over! Time to focus.");
                       startTimer(focusDuration, "Focus Time");
                  } 
                  // No else needed, covers all expected modes

                   saveState(); // Save state after timer finishes a cycle (focus or break)
              }
          }, 1000); // Update every second
      }


      function checkLevelUp() {
        const currentLevelData = getAchievementLevel(previousPoints);
        const newLevelData = getAchievementLevel(points);

        // Check if the level itself has changed
        if (newLevelData.level !== currentLevelData.level) {
            console.log(`Level Up! From ${currentLevelData.level} to ${newLevelData.level}`);
            showAchievementOverlay(newLevelData.level);
        }
        
        // Update previousPoints regardless of level change for the next check
        previousPoints = points; 
        updateAchievementLevel(); // Update the display always to reflect current level style
        updateSidebarDashboard(); // Update sidebar level display
      }


      function playFocusAudio() {
        const audio = document.getElementById("focusAudio")
        if (audio) {
            audio.play().catch((err) => console.error("Focus audio play error:", err));
        } else {
            console.warn("Focus audio element not found.");
        }
      }

      function endFocusSession() {
          clearInterval(countdownInterval); // Stop the timer interval
          countdownInterval = null;
          isFocusModeActive = false;
          
          const timerDisplay = document.getElementById("timerDisplay");
          const timerTextSpan = document.getElementById("timerText");
          const progressBar = document.getElementById("progressBar");
          
          if (timerTextSpan) {
              timerTextSpan.textContent = allVideosCompleted ? "All Videos Watched!" : "Focus Complete!";
          }
          if (progressBar) {
              progressBar.style.display = "none"; // Hide progress bar
              document.getElementById("progressFill").style.width = '0%'; // Reset fill
          }

          // Optional: Stop YouTube player if it's still playing?
          if (player && typeof player.stopVideo === 'function') {
               // player.stopVideo(); // Or pauseVideo()
          }

          console.log("Focus session ended.");
          saveState(); // Ensure the final state (focus inactive) is saved
          updateAnalytics(); // Update displayed stats one last time for the session
      }


      function restartSession() {
        // Show confirmation dialog before actually restarting
        const dialog = document.getElementById("confirmationDialog")
        if (!dialog) return
        // Pause player and timer while confirming
        if (isFocusModeActive && player && typeof player.pauseVideo === 'function') {
            player.pauseVideo();
        }
        if(countdownInterval) {
           clearInterval(countdownInterval); // Pause timer visually
           // Don't nullify interval here, might need to resume if cancelled
        }
        dialog.style.display = "block"
      }

      function handleRestartConfirmation(choice) {
          const dialog = document.getElementById("confirmationDialog");
          if (!dialog) return;

          dialog.style.display = "none"; // Hide dialog regardless of choice

          if (choice === "yes") {
              console.log("Restarting session...");
              clearInterval(countdownInterval); // Ensure timer is stopped
              countdownInterval = null;
              isFocusModeActive = false;
              
              // Clear video-related state
              videoIds = [];
              currentVideoIndex = 0;
              completedVideos.clear();
              allVideosCompleted = false;
              timerRemaining = focusDuration / 1000; // Reset timer duration for next start
              timerMode = "Focus Time";

              // Destroy YouTube player if it exists
              if (player && typeof player.destroy === 'function') {
                   try {
                      player.destroy();
                      console.log("YouTube player destroyed.");
                   } catch (e) {
                      console.error("Error destroying player:", e);
                   } finally {
                      player = null; // Clear reference
                   }
              }
              // Ensure player div is empty and hidden
               const playerElement = document.getElementById("player");
              if(playerElement) {
                  playerElement.innerHTML = ""; 
                  playerElement.style.display = "none";
              }


              // Reset UI elements
              document.getElementById("restartBtn").style.display = "none";
              document.getElementById("pdfToggle").style.display = "none"; // Hide PDF toggle
              document.getElementById("videoSidebar").style.right = "-320px"; // Hide sidebar
              document.getElementById("videoSidebar").innerHTML = '<button id="minimizeBtn">-</button>'; // Reset sidebar content


              const timerTextSpan = document.getElementById("timerText");
              const progressBar = document.getElementById("progressBar");
              if(timerTextSpan) timerTextSpan.textContent = ""; // Clear timer text
              if(progressBar) progressBar.style.display = "none"; // Hide progress bar
              document.getElementById("progressFill").style.width = '0%'; // Reset progress fill


              // Show the input form again
              document.getElementById("inputForm").style.display = "block";
              document.getElementById("clockDisplay").style.display = "block"; // Show clock
              // Removed sitesBox toggle
              document.getElementById("lofiPlayer").style.display = "block"; // Show lofi player

              restoreUrlInputs(); // Set up the URL inputs for a new session
              saveState(); // Save the reset state
              startReminderTimer(); // Start reminder for input form
          } else {
               // User chose 'No', resume playback and timer if they were active
               console.log("Restart cancelled.");
               if (isFocusModeActive && player && typeof player.playVideo === 'function' && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                   player.playVideo();
               }
               // Resume timer only if it was previously active and paused by the dialog
               if(isFocusModeActive && timerRemaining >= 0 && !countdownInterval) {
                  // Restart interval with the remaining time if it was cleared
                  startTimer(timerRemaining * 1000, timerMode);
               }
          }
      }


      function toggleVideoSidebar() {
        const sidebar = document.getElementById("videoSidebar")
        if (!sidebar) return
        const isVisible = sidebar.style.right === "0px";
        sidebar.style.right = isVisible ? "-320px" : "0px"; // Toggle visibility
      }

      function updateAnalytics() {
         // Display total focus time in minutes
         document.getElementById("totalFocusTime").textContent = Math.floor(totalFocusTime / 60); 
         document.getElementById("totalDistractions").textContent = totalDistractions;
         document.getElementById("totalVideosWatched").textContent = totalVideosWatched;
         updateSidebarDashboard(); // Also update sidebar stats
      }

      function toggleAnalytics() {
        const analytics = document.getElementById("analytics")
        if (!analytics) return
        const isVisible = analytics.style.display === "block";
        analytics.style.display = isVisible ? "none" : "block";
        // Hide todo list if showing analytics
        if (!isVisible) {
           document.getElementById("todoList").style.display = "none";
        }
      }


      function savePlaylist() {
          const playlistNameInput = document.getElementById("playlistName");
          const playlistName = playlistNameInput.value.trim();
          const urlInputs = document.querySelectorAll("#urlInputs .youtube-url");
          
          if (!playlistName) {
              alert("Please enter a name to save this path (playlist).");
              playlistNameInput.focus();
              return;
          }
          if (!urlInputs.length) {
              alert("Cannot save playlist: URL input elements not found.");
              return;
          }

          const urls = Array.from(urlInputs)
                           .map((input) => input.value.trim())
                           .filter((url) => url); // Get non-empty URLs

          if (!urls.length) {
              alert("Please add at least one valid YouTube URL to save.");
              return;
          }

          const videoIdsForPlaylist = urls.map((url) => extractVideoId(url)).filter((id) => id); // Extract valid IDs

          if (videoIdsForPlaylist.length === 0) {
              alert("No valid YouTube video IDs found in the provided URLs. Playlist not saved.");
              return;
          }

          // Check if playlist name already exists and confirm overwrite
          const existingPlaylistIndex = playlists.findIndex(p => p.name === playlistName);
          if (existingPlaylistIndex !== -1) {
               if (!confirm(`A playlist named "${playlistName}" already exists. Overwrite it?`)) {
                   return; // User cancelled overwrite
               }
               // Remove the old playlist before adding the new one
               playlists.splice(existingPlaylistIndex, 1); 
          }


          // Add the new playlist
          playlists.push({ name: playlistName, videoIds: videoIdsForPlaylist });
          
          // Save playlists back to localStorage (using a global key for now)
          try {
             localStorage.setItem("playlists", JSON.stringify(playlists));
             console.log(`Playlist "${playlistName}" saved successfully.`);
          } catch (e) {
              console.error("Error saving playlists to localStorage:", e);
              alert("Could not save playlist due to storage error.");
              // Optionally revert playlists array if save failed?
              return;
          }

          populatePlaylistSelect(); // Update the dropdown menu
          
          // Optionally select the newly saved playlist in the dropdown
          const playlistSelect = document.getElementById("playlistSelect");
          if(playlistSelect) playlistSelect.value = playlistName;

          // Clear the playlist name input field
          playlistNameInput.value = ""; 
          alert(`Playlist "${playlistName}" saved!`);
      }


      function removePlaylist() {
          const playlistSelect = document.getElementById("playlistSelect");
          const selectedName = playlistSelect.value;
          
          if (!selectedName) {
              alert("Please select a playlist from the dropdown to remove.");
              return;
          }

          // Confirm removal
          if (!confirm(`Are you sure you want to delete the playlist "${selectedName}"? This cannot be undone.`)) {
              return; // User cancelled
          }

          // Filter out the selected playlist
          const originalLength = playlists.length;
          playlists = playlists.filter((p) => p.name !== selectedName);

          if (playlists.length < originalLength) {
              // Save the updated playlists array to localStorage
              try {
                  localStorage.setItem("playlists", JSON.stringify(playlists));
                  console.log(`Playlist "${selectedName}" removed successfully.`);
              } catch (e) {
                  console.error("Error saving updated playlists to localStorage:", e);
                  alert("Could not remove playlist due to storage error.");
                   // Revert playlists array if save failed? Could reload from storage.
                  playlists = JSON.parse(localStorage.getItem("playlists") || "[]"); // Revert attempt
                  populatePlaylistSelect(); // Refresh select even on error
                  return;
              }

              populatePlaylistSelect(); // Update the dropdown
              
              // Optionally clear the URL inputs if the deleted playlist was loaded
              // This depends on whether loading a playlist sets a flag or just fills inputs
              // For simplicity, let's clear the inputs.
              videoIds = []; // Clear loaded video IDs
              restoreUrlInputs(); // Reset input fields to default empty state
              alert(`Playlist "${selectedName}" deleted.`);

          } else {
               console.warn(`Playlist "${selectedName}" not found in the playlists array.`);
               alert(`Could not find the playlist "${selectedName}" to delete.`);
          }
      }


      function populatePlaylistSelect() {
        const playlistSelect = document.getElementById("playlistSelect");
        if (!playlistSelect) return;

        const currentSelectedValue = playlistSelect.value; // Preserve selection if possible

        playlistSelect.innerHTML = '<option value="">Select a Saved Path</option>'; // Default option

        if(playlists && playlists.length > 0) {
            playlists.forEach((playlist) => {
                const option = document.createElement("option");
                option.value = playlist.name;
                option.textContent = playlist.name;
                playlistSelect.appendChild(option);
            });
        } else {
             // Optional: Add a disabled option indicating no playlists saved
             // const noPlaylistOption = document.createElement("option");
             // noPlaylistOption.textContent = "No saved paths yet";
             // noPlaylistOption.disabled = true;
             // playlistSelect.appendChild(noPlaylistOption);
        }

         // Try to restore previous selection
         if (playlists.some(p => p.name === currentSelectedValue)) {
             playlistSelect.value = currentSelectedValue;
         }

        // Add onchange listener (or ensure it's added only once)
         // It's safer to remove existing listener before adding, or use a flag
         // playlistSelect.removeEventListener('change', handlePlaylistSelection); // Example removal
         playlistSelect.onchange = handlePlaylistSelection; // Assign directly (overwrites previous)
      }

      function handlePlaylistSelection() {
          const playlistSelect = document.getElementById("playlistSelect");
          const selectedName = playlistSelect.value;
          
          if (selectedName) {
              const selectedPlaylist = playlists.find((p) => p.name === selectedName);
              if (selectedPlaylist && selectedPlaylist.videoIds) {
                  console.log(`Loading playlist: "${selectedName}"`);
                  videoIds = selectedPlaylist.videoIds; // Load IDs into the global variable
                  restoreUrlInputs(); // Update the URL input fields based on loaded IDs
                  document.getElementById("playlistName").value = selectedName; // Pre-fill name input for potential overwrite
              } else {
                   console.warn(`Selected playlist "${selectedName}" not found or has no video IDs.`);
                   // videoIds = []; // Clear video IDs if playlist is invalid
                   // restoreUrlInputs(); // Reset inputs
              }
          } else {
               // "Select a Playlist" chosen
               console.log("No playlist selected.");
               // videoIds = []; // Optionally clear video IDs
               // restoreUrlInputs(); // Optionally reset input fields
               document.getElementById("playlistName").value = ""; // Clear name input
          }
      }


      function togglePDFViewer() {
        const pdfViewer = document.getElementById("pdfViewer")
        if (!pdfViewer) return
        const isVisible = pdfViewer.style.display === "block";
        pdfViewer.style.display = isVisible ? "none" : "block";
        // Clear the file input and iframe src when closing?
        if (isVisible) {
            document.getElementById("pdfInput").value = null; // Clear file input
            document.getElementById("pdfFrame").src = 'about:blank'; // Clear iframe
        }
      }

      function handlePDFUpload(event) {
          const file = event.target.files[0];
          const pdfFrame = document.getElementById("pdfFrame");
          const pdfViewer = document.getElementById("pdfViewer");

          if (!pdfFrame || !pdfViewer) {
              console.error("PDF viewer elements not found.");
              return;
          }

          if (!file) {
              console.log("No PDF file selected.");
              // pdfFrame.src = 'about:blank'; // Clear frame if no file selected
              return;
          }
          
          if (file.type !== "application/pdf") {
              alert("Please upload a valid PDF file (.pdf).");
              event.target.value = null; // Clear the invalid file selection
              // pdfFrame.src = 'about:blank'; // Clear frame
              return;
          }

          // File is valid PDF
          try {
             const url = URL.createObjectURL(file);
             pdfFrame.src = url; // Set iframe source to the local PDF blob URL
             pdfViewer.style.display = "block"; // Ensure the viewer is visible

             // Optional: Revoke the object URL when the viewer is closed or a new file is loaded?
             // This is good practice for memory management but can be tricky to implement robustly.
             // pdfFrame.onload = () => { URL.revokeObjectURL(url); }; // Revoke after load (might be too soon)
          } catch (error) {
              console.error("Error creating object URL for PDF:", error);
              alert("Could not display the PDF file.");
              event.target.value = null;
              pdfFrame.src = 'about:blank';
          }
      }


      function toggleAIPopup() {
        const aiPopup = document.getElementById("aiPopup")
        if (!aiPopup) return
        aiPopup.style.display = aiPopup.style.display === "block" ? "none" : "block"
      }

      // --- Quiet Pomodoro Functions ---
      function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = seconds % 60;
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }

       function updatePomodoroDisplay() {
           const timerDisplay = document.getElementById('pomodoroTimerDisplay');
           const statusDisplay = document.getElementById('pomodoroStatus');
           if (timerDisplay) timerDisplay.textContent = formatTime(pomodoroTimeRemaining);
           if (statusDisplay) statusDisplay.textContent = pomodoroMode;
       }

      function pomodoroSessionComplete() {
           if (pomodoroCompleteAudio) {
               pomodoroCompleteAudio.play().catch(e => console.error("Error playing pomodoro sound:", e));
           }

           if (pomodoroMode === 'Work') {
               // Award points for completed work session
               const pointsEarned = applyPowerUps(POMODORO_WORK_MINS * 1); // 1 point per min base
               points += pointsEarned;
               document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
               checkLevelUp();
               saveState();
               console.log(`Pomodoro work session complete! +${pointsEarned} XP`);

               // Switch to Break
               pomodoroMode = 'Break';
               pomodoroTimeRemaining = POMODORO_BREAK_MINS * 60;
           } else {
               // Switch back to Work
               pomodoroMode = 'Work';
               pomodoroTimeRemaining = POMODORO_WORK_MINS * 60;
           }
           updatePomodoroDisplay();
           // Automatically start the next phase? Or require user interaction? Let's auto-start.
           startPomodoroTimer(); 
       }


       function startPomodoroTimer() {
           if (isPomodoroRunning) return; // Prevent multiple intervals

           isPomodoroRunning = true;
           document.getElementById('pomodoroStartBtn').textContent = 'PAUSE'; // Change button text

           pomodoroInterval = setInterval(() => {
               pomodoroTimeRemaining--;
               updatePomodoroDisplay();

               if (pomodoroTimeRemaining < 0) {
                   clearInterval(pomodoroInterval);
                   isPomodoroRunning = false;
                   document.getElementById('pomodoroStartBtn').textContent = 'START';
                   pomodoroSessionComplete();
               }
           }, 1000);
       }

        function pausePomodoroTimer() {
             if (!isPomodoroRunning) return;
             clearInterval(pomodoroInterval);
             isPomodoroRunning = false;
             document.getElementById('pomodoroStartBtn').textContent = 'START';
        }

       function togglePomodoroStartPause() {
            if (isPomodoroRunning) {
                 pausePomodoroTimer();
            } else {
                 startPomodoroTimer();
            }
       }

      function resetPomodoro(hideOverlay = true) {
          clearInterval(pomodoroInterval);
          pomodoroInterval = null;
          isPomodoroRunning = false;
          pomodoroMode = 'Work';
          pomodoroTimeRemaining = POMODORO_WORK_MINS * 60;
          updatePomodoroDisplay();
          document.getElementById('pomodoroStartBtn').textContent = 'START';

          if (hideOverlay) {
               const overlay = document.getElementById('pomodoroOverlay');
               const container = document.getElementById('gameContainer');
               if (overlay) overlay.style.display = 'none';
               if (container) container.classList.remove('blur-background');
          }
           console.log("Pomodoro Reset.");
      }


      function toggleQuietPomodoro() {
          const overlay = document.getElementById('pomodoroOverlay');
          const container = document.getElementById('gameContainer');
          if (!overlay || !container) return;

          const isVisible = overlay.style.display === 'flex';

          if (isVisible) {
               // Hide Pomodoro
               resetPomodoro(true); // Reset and hide
          } else {
               // Show Pomodoro
               resetPomodoro(false); // Reset timer state without hiding
               overlay.style.display = 'flex';
               container.classList.add('blur-background');
                // Ensure sidebar is closed when opening pomodoro
                const sidebar = document.querySelector('.game-sidebar');
                if (sidebar) sidebar.style.left = '-250px'; 
          }
      }
      // --- End Pomodoro Functions ---

      function saveState() {
          const state = {
              videoIds,
              currentVideoIndex,
              // distractionCount, // Not actively used, maybe remove from saving
              points,
              timerMode,
              timerRemaining,
              isFocusModeActive,
              isSignedIn,
              currentUser,
              completedVideos: Array.from(completedVideos),
              allVideosCompleted,
              totalFocusTime, // Saved in seconds
              totalDistractions,
              totalVideosWatched,
              streakDays,
              // lastFocusDate is saved separately/globally
              mysteryBoxCount,
              activePowerUps,
              premiumLofiTracks: premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked })) // Save unlock status
          };
          
          try {
             localStorage.setItem("focusModeState", JSON.stringify(state));
             // console.log("Global state saved.");

             // Save user-specific data if logged in
             if (isSignedIn && currentUser) {
                const users = JSON.parse(localStorage.getItem("users") || "{}");
                if (users[currentUser]) { // Ensure user exists in storage
                    users[currentUser] = {
                        ...users[currentUser], // Keep existing password etc.
                        points: points,
                        totalFocusTime: totalFocusTime,
                        totalDistractions: totalDistractions,
                        totalVideosWatched: totalVideosWatched,
                        tasks: tasks, // Assumes 'tasks' holds the current user's tasks
                        streakDays: streakDays,
                        mysteryBoxCount: mysteryBoxCount,
                        activePowerUps: activePowerUps,
                         premiumLofiTracks: premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked })) // Save user's unlocks
                    };
                    localStorage.setItem("users", JSON.stringify(users));
                    // console.log(`User specific state saved for: ${currentUser}`);
                } else {
                     console.warn(`Attempted to save state for non-existent user: ${currentUser}`);
                }
             }
          } catch (e) {
               console.error("Error saving state to localStorage:", e);
               // Handle potential storage errors (e.g., quota exceeded)
               alert("Warning: Could not save progress. Storage might be full.");
          }
      }


      function updateSidebarDashboard() {
        const sidebarUsername = document.getElementById("sidebarUsername")
        const sidebarLevel = document.getElementById("sidebarLevel")
        const sidebarXP = document.getElementById("sidebarXP")
        const sidebarStreak = document.getElementById("sidebarStreak")
        if (!sidebarUsername || !sidebarLevel || !sidebarXP || !sidebarStreak) return

        sidebarUsername.textContent = currentUser || "Guest"; // Show username or Guest
        const levelData = getAchievementLevel(points); // Get level based on current points
        sidebarLevel.textContent = levelData.level;
        sidebarXP.textContent = points;
        sidebarStreak.textContent = `${streakDays} day${streakDays === 1 ? "" : "s"}`;
      }

      function logout() {
          console.log("Logging out...");
          saveState(); // Save current user's progress before logging out

           // Reset Pomodoro if active
           if (document.getElementById('pomodoroOverlay').style.display === 'flex') {
                resetPomodoro(true); 
           }

          // Reset global state variables
          isSignedIn = false;
          currentUser = null;
          points = 0;
          previousPoints = 0;
          totalFocusTime = 0;
          totalDistractions = 0;
          totalVideosWatched = 0;
          tasks = []; // Clear tasks array
          streakDays = 0;
          // lastFocusDate should ideally persist globally or be cleared if desired
          // localStorage.removeItem("lastFocusDate"); // Option to clear global date on logout
          mysteryBoxCount = 0;
          activePowerUps = {
              doublePoints: { active: false, expiry: null },
              streakShield: { active: false, used: false, expiry: null },
          };
          // Reset premium tracks to locked state in memory
          premiumLofiTracks.forEach(track => track.unlocked = false);
          initAudio(); // Re-initialize audio with only free tracks

          // Clear video playback state
          videoIds = [];
          currentVideoIndex = 0;
          completedVideos.clear();
          allVideosCompleted = false;
          
          // Stop timers and player
          clearInterval(countdownInterval);
          countdownInterval = null;
          isFocusModeActive = false;
          if (player && typeof player.destroy === 'function') {
               try { player.destroy(); } catch (e) {} finally { player = null; }
          }
          stopReminderTimer();

          // Update UI to logged-out state
          document.getElementById("player").innerHTML = "";
          document.getElementById("player").style.display = "none";
          document.getElementById("restartBtn").style.display = "none";
          document.getElementById("pdfToggle").style.display = "none";
          document.getElementById("videoSidebar").style.right = "-320px";
          document.getElementById("inputForm").style.display = "none";
          document.getElementById("signinForm").style.display = "none"; // Hide signin form too initially
          document.getElementById("landingPage").style.display = "block"; // Show landing page
          document.getElementById("clockDisplay").style.display = "none";
          // Removed sitesBox toggle
          document.getElementById("lofiPlayer").style.display = "none";
          document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: 0`;
          
          const progressBar = document.getElementById("progressBar");
          if (progressBar) progressBar.style.display = "none";
          document.getElementById("progressFill").style.width = '0%';

          // Clear sensitive fields
           const usernameInput = document.getElementById("username");
           const passwordInput = document.getElementById("password");
           if(usernameInput) usernameInput.value = "";
           if(passwordInput) passwordInput.value = "";

          // Clear the specific focusModeState for the session
          localStorage.removeItem("focusModeState"); 
          
          // Update displays
          updateAnalytics(); // Show 0 stats
          updateAchievementLevel(); // Show Mortal level
          updateSidebarDashboard(); // Show Guest in sidebar
          restoreTasks(); // Show default empty task line

          console.log("Logout complete.");
      }


      // --- Event Listeners Setup ---
      document.addEventListener("DOMContentLoaded", () => {
        initAudio(); // Initialize audio player and song list
        loadSavedState(); // Load previous state or set defaults
        setInterval(updateClock, 1000); // Start the live clock
         setInterval(checkTaskDeadlines, 60000); // Check deadlines every minute


        // Action Buttons (using data-action attribute)
        document.querySelectorAll("button[data-action]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const action = btn.getAttribute("data-action");
            switch (action) {
              case "start-game": showSignIn(); break;
              case "github": window.open("https://github.com/The-Chosen-One-o5/UltraFocusModeYT", "_blank"); break;
              case "sign-in": signIn(); break;
              case "create-account": createAccount(); break;
              case "add-url": addUrlInput(); break;
              case "start-playback": startPlayback(); break;
              case "save-playlist": savePlaylist(); break;
              case "remove-playlist": removePlaylist(); break;
              case "save-tasks": saveTasks(); break; // Might be redundant if using onblur
            }
          });
        });

        // Specific Button Listeners
        const restartBtn = document.getElementById("restartBtn");
        if (restartBtn) restartBtn.addEventListener("click", restartSession);

        const confirmBtn = document.getElementById("confirmBtn");
        if (confirmBtn) confirmBtn.addEventListener("click", () => handleRestartConfirmation("yes"));

        const cancelBtn = document.getElementById("cancelBtn");
        if (cancelBtn) cancelBtn.addEventListener("click", () => handleRestartConfirmation("no"));

        // Sidebar minimize button is attached dynamically in setupVideoSidebar

        // LoFi Player Controls
        const lofiPlay = document.getElementById("lofiPlay");
        if (lofiPlay) lofiPlay.addEventListener("click", playLofi);
        const lofiPause = document.getElementById("lofiPause");
        if (lofiPause) lofiPause.addEventListener("click", pauseLofi);
        const lofiPrev = document.getElementById("lofiPrev");
        if (lofiPrev) lofiPrev.addEventListener("click", prevLofi);
        const lofiNext = document.getElementById("lofiNext");
        if (lofiNext) lofiNext.addEventListener("click", nextLofi);

        // UI Toggles
        const statsBtn = document.getElementById("statsBtn");
        if (statsBtn) statsBtn.addEventListener("click", toggleAnalytics);
        const todoBtn = document.getElementById("todoBtn");
        if (todoBtn) todoBtn.addEventListener("click", toggleTodo);
        const pyqBtn = document.getElementById("pyqBtn");
        if (pyqBtn) pyqBtn.addEventListener("click", redirectToPYQs);
        const pdfToggle = document.getElementById("pdfToggle");
        if (pdfToggle) pdfToggle.addEventListener("click", togglePDFViewer);
        const pdfInput = document.getElementById("pdfInput");
        if (pdfInput) pdfInput.addEventListener("change", handlePDFUpload);
        const fireBox = document.getElementById("fireBox");
        if (fireBox) fireBox.addEventListener("click", toggleAIPopup);

        // Shop / Power-up Dialog Buttons
        const streakShieldBtn = document.getElementById("streakShieldBtn");
        if (streakShieldBtn) streakShieldBtn.addEventListener("click", showStreakShieldDialog);
        const streakShieldConfirmBtn = document.getElementById("streakShieldConfirmBtn");
        if (streakShieldConfirmBtn) streakShieldConfirmBtn.addEventListener("click", () => handleStreakShieldConfirmation("yes"));
        const streakShieldCancelBtn = document.getElementById("streakShieldCancelBtn");
        if (streakShieldCancelBtn) streakShieldCancelBtn.addEventListener("click", () => handleStreakShieldConfirmation("no"));

        const doublePointsBtn = document.getElementById("doublePointsBtn");
        if (doublePointsBtn) doublePointsBtn.addEventListener("click", showDoublePointsDialog);
        const doublePointsConfirmBtn = document.getElementById("doublePointsConfirmBtn");
        if (doublePointsConfirmBtn) doublePointsConfirmBtn.addEventListener("click", () => handleDoublePointsConfirmation("yes"));
        const doublePointsCancelBtn = document.getElementById("doublePointsCancelBtn");
        if (doublePointsCancelBtn) doublePointsCancelBtn.addEventListener("click", () => handleDoublePointsConfirmation("no"));

        const audioStoreBtn = document.getElementById("audioStoreBtn");
        if(audioStoreBtn) audioStoreBtn.addEventListener("click", showAudioTracksStore);
        const closeAudioStore = document.getElementById("closeAudioStore");
        if(closeAudioStore) closeAudioStore.addEventListener("click", closeAudioTracksStore);


        // Account Buttons
        const logoutBtn = document.getElementById("logoutBtn");
        if (logoutBtn) logoutBtn.addEventListener("click", logout);

        // Mystery Box
        const openMysteryBoxBtn = document.getElementById("openMysteryBox");
        if (openMysteryBoxBtn) openMysteryBoxBtn.addEventListener("click", openMysteryBox);

        // Deadline Dialog
        const deadlineConfirmBtn = document.getElementById("deadlineConfirmBtn");
        if(deadlineConfirmBtn) deadlineConfirmBtn.addEventListener("click", () => handleDeadlineConfirmation("yes"));
        const deadlineCancelBtn = document.getElementById("deadlineCancelBtn");
        if(deadlineCancelBtn) deadlineCancelBtn.addEventListener("click", () => handleDeadlineConfirmation("no"));

        // Session Complete Dialog
        const sessionContinueBtn = document.getElementById("sessionContinueBtn");
        if(sessionContinueBtn) sessionContinueBtn.addEventListener("click", () => handleSessionContinue("continue"));
        const sessionEndBtn = document.getElementById("sessionEndBtn");
        if(sessionEndBtn) sessionEndBtn.addEventListener("click", () => handleSessionContinue("end"));

        // Quiet Pomodoro Listeners
        const quietPomodoroBtn = document.getElementById("quietPomodoroBtn");
        if (quietPomodoroBtn) quietPomodoroBtn.addEventListener("click", toggleQuietPomodoro);
        const pomodoroStartBtn = document.getElementById("pomodoroStartBtn");
        if (pomodoroStartBtn) pomodoroStartBtn.addEventListener("click", togglePomodoroStartPause);
        const pomodoroResetBtn = document.getElementById("pomodoroResetBtn");
        if (pomodoroResetBtn) pomodoroResetBtn.addEventListener("click", () => resetPomodoro(true)); // Reset and hide


        // Timer Dragging Logic
        const timerDisplay = document.getElementById("timerDisplay");
        if (timerDisplay) {
            let isDragging = false;
            let currentX, currentY;
            let initialX, initialY;

            timerDisplay.addEventListener("mousedown", (e) => {
                // Prevent dragging if clicking on buttons inside the timer
                if (e.target.tagName === 'BUTTON') return; 
                
                initialX = e.clientX - timerDisplay.offsetLeft;
                initialY = e.clientY - timerDisplay.offsetTop;
                isDragging = true;
                timerDisplay.style.cursor = 'grabbing'; // Change cursor while dragging
            });

            document.addEventListener("mousemove", (e) => {
                if (isDragging) {
                    e.preventDefault(); // Prevent text selection during drag
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;

                    // Optional: Add boundary checks to keep timer on screen
                    const container = document.querySelector('.game-container') || document.body;
                    const containerRect = container.getBoundingClientRect();
                    const timerRect = timerDisplay.getBoundingClientRect();

                    currentX = Math.max(0, Math.min(currentX, containerRect.width - timerRect.width));
                    currentY = Math.max(0, Math.min(currentY, containerRect.height - timerRect.height));

                    timerDisplay.style.left = `${currentX}px`;
                    timerDisplay.style.top = `${currentY}px`;
                }
            });

            document.addEventListener("mouseup", () => {
                if (isDragging) {
                   isDragging = false;
                   timerDisplay.style.cursor = 'move'; // Reset cursor
                }
            });
             timerDisplay.style.cursor = 'move'; // Initial cursor style
        }

        // Distraction Detection (Visibility Change)
        document.addEventListener("visibilitychange", () => {
          if (document.hidden && isFocusModeActive) {
            console.log("Distraction detected: Tab hidden during focus.");
            distractionCount++; // Increment session distraction count (if used)
            totalDistractions++; // Increment lifetime distractions
            // pauseLofi(); // Don't pause lofi, only YT player handled by API
            saveState(); // Save updated distraction count
            updateAnalytics(); // Update displayed stats
          } else if (!document.hidden && isFocusModeActive) {
             console.log("Tab focused again.");
            // playLofi(); // Don't auto-play lofi, user controls it separately
          }
        });

      }); // End DOMContentLoaded
    })(); // End IIFE
  </script>
</body>
</html>
