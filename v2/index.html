<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quest for Focus - Learning Adventure</title>
  <style>
    /* Reset and Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #4169e1; /* Royal Blue */
      --primary-dark: #1e3a8a; /* Darker Blue */
      --secondary: #8e2de2; /* Purple */
      --accent: #ff4500; /* OrangeRed */
      --accent-alt: #ff8c00; /* DarkOrange */
      --bg-dark: #0f0f1b; /* Very Dark Blue/Purple */
      --bg-medium: #1a1a2e; /* Dark Blue/Purple */
      --bg-light: #252538; /* Medium Dark Blue/Purple */
      --text: #e0e0ff; /* Light Lavender */
      --text-dim: #9090b0; /* Grayish Lavender */
      --gold: #ffd700;
      --success: #28a745;
      --danger: #dc3545;
    }

    html {
      scrollbar-width: thin;
      scrollbar-color: var(--secondary) var(--bg-medium);
    }

    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-medium);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 0;
      border: 2px solid var(--bg-medium);
    }

    body {
      background-color: var(--bg-dark);
      min-height: 100vh;
      font-family: 'Roboto Mono', monospace; /* Changed font for better readability */
      color: var(--text);
      overflow-x: hidden; /* Prevent horizontal scroll */
      font-size: 16px; /* Adjusted base font size */
      line-height: 1.6; /* Improved line spacing */
    }

    /* Game Container and Background */
    .game-container {
      width: 100%;
      min-height: 100vh; /* Use min-height */
      position: relative;
      overflow: hidden;
      background-image: radial-gradient(circle at 10% 20%, rgba(142, 45, 226, 0.1) 0%, transparent 25%),
                        radial-gradient(circle at 90% 80%, rgba(65, 105, 225, 0.1) 0%, transparent 25%),
                        linear-gradient(to bottom, var(--bg-dark) 0%, var(--bg-medium) 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
      padding-top: 60px; /* Account for fixed top nav bar */
    }

    .game-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("data:image/svg+xml,%3Csvg width='8' height='8' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.04' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 5v1H5V0zm1 5v1H5v-1h1z'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 2;
      opacity: 0.5;
    }

    /* Page/View Containers */
    .page-view {
      width: 100%;
      height: calc(100vh - 60px); /* Full height minus top nav */
      display: none; /* Hidden by default */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      position: relative;
      z-index: 10;
      overflow-y: auto; /* Allow scrolling within views */
    }

    /* Landing Page & Signin Form Styles */
    #landingPageContainer, #signinFormContainer {
      text-align: center;
      width: 100%;
      max-width: 700px; /* Slightly wider */
      margin: auto; /* Center horizontally */
      padding: 40px 30px;
      background-color: rgba(15, 15, 27, 0.85); /* Slightly more opaque */
      border: 2px solid var(--secondary);
      border-radius: 12px; /* Softer corners */
      box-shadow: 0 0 25px rgba(142, 45, 226, 0.4);
      backdrop-filter: blur(4px);
      pointer-events: auto;
    }

    /* Titles and Subtitles */
    .title {
      font-family: 'Press Start 2P', cursive; /* Retro game font */
      font-size: 28px; /* Adjusted size */
      font-weight: 400; /* Normal for this font */
      color: var(--text);
      margin-bottom: 25px;
      text-shadow: 2px 2px 0px var(--primary-dark), 4px 4px 0px rgba(0,0,0,0.3);
      letter-spacing: 1px;
      line-height: 1.3;
    }

    .title span {
      color: var(--secondary);
      position: relative;
      display: inline-block;
    }

    .title span::after {
      content: "";
      position: absolute;
      bottom: -6px;
      left: 5%;
      width: 90%;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      opacity: 0.8;
    }

    .subtitle {
      font-size: 18px;
      color: var(--text-dim);
      margin-bottom: 35px;
      font-family: 'Roboto Mono', monospace;
    }

    /* Buttons */
    button {
      display: inline-block;
      padding: 10px 25px;
      font-size: 14px;
      font-family: 'Roboto Mono', monospace;
      font-weight: 600;
      background: var(--secondary);
      border: none;
      color: var(--text);
      border-radius: 4px; /* Small radius */
      cursor: pointer;
      margin: 5px 8px 15px;
      transition: all 0.2s ease-in-out;
      position: relative;
      box-shadow: 3px 3px 0 var(--primary-dark);
      text-transform: uppercase;
      letter-spacing: 1px;
      z-index: 11;
      pointer-events: auto;
      outline: none;
    }

    button:hover {
      background: var(--primary);
      transform: translate(1px, 1px);
      box-shadow: 2px 2px 0 var(--primary-dark);
    }

    button:active {
      transform: translate(3px, 3px);
      box-shadow: none;
    }

    button:disabled {
      background: var(--bg-light);
      color: var(--text-dim);
      cursor: not-allowed;
      box-shadow: 2px 2px 0 var(--bg-medium);
      transform: none;
    }

    .github-btn {
      background: var(--bg-light);
      box-shadow: 3px 3px 0 var(--bg-medium);
    }

    .github-btn:hover {
      background: var(--bg-medium);
      box-shadow: 2px 2px 0 var(--bg-medium);
    }

    .accent-btn {
      background: var(--accent);
      box-shadow: 3px 3px 0 var(--primary-dark);
    }

    .accent-btn:hover {
      background: var(--accent-alt);
    }

    .primary-btn {
      background: var(--primary);
       box-shadow: 3px 3px 0 var(--primary-dark);
    }
    .primary-btn:hover {
        background: var(--primary-dark);
    }


    /* Landing Page Features */
    #features {
      display: flex;
      justify-content: center;
      gap: 25px;
      margin-top: 40px;
      flex-wrap: wrap;
      z-index: 10;
    }

    .feature {
      background: var(--bg-light);
      padding: 20px;
      border-radius: 8px; /* Softer corners */
      width: 220px;
      box-shadow: 4px 4px 0 var(--bg-medium);
      border: 1px solid var(--primary);
      position: relative;
      overflow: hidden;
      z-index: 10;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
     .feature:hover {
        transform: translateY(-3px);
        box-shadow: 6px 6px 12px rgba(0, 0, 0, 0.3);
    }


    .feature::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }

    .feature i { /* Assuming FontAwesome or similar */
      font-size: 28px;
      color: var(--secondary);
      margin-bottom: 12px;
      display: block; /* Center icon */
    }

    .feature p {
      font-size: 15px;
      color: var(--text);
      text-align: center;
    }

    /* Input Fields */
    input[type="text"],
    input[type="password"],
    input[type="date"],
    input[type="time"],
    input[type="file"],
    select {
      display: block;
      width: 100%;
      max-width: 350px; /* Wider max */
      margin: 15px auto; /* More vertical space */
      padding: 12px 15px;
      border-radius: 4px;
      font-size: 16px;
      font-family: 'Roboto Mono', monospace;
      background: var(--bg-light);
      border: 2px solid var(--primary);
      color: var(--text);
      outline: none;
      box-shadow: inset 2px 2px 4px rgba(0, 0, 0, 0.2); /* Inner shadow */
      transition: border-color 0.3s, box-shadow 0.3s;
      z-index: 11;
      pointer-events: auto;
    }

    input:focus,
    select:focus {
      border-color: var(--secondary);
      box-shadow: 0 0 0 3px rgba(142, 45, 226, 0.3), inset 2px 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* Top Navigation Bar */
    #topNavBar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 60px;
      background-color: rgba(15, 15, 27, 0.9); /* Semi-transparent */
      backdrop-filter: blur(10px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 25px;
      border-bottom: 1px solid rgba(65, 105, 225, 0.3); /* Subtle border */
      z-index: 200;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
       display: none; /* Hidden by default, shown via JS */
    }

    #navLogo {
      font-family: 'Press Start 2P', cursive;
      font-size: 18px;
      color: var(--text);
      text-decoration: none;
    }
    #navLogo span {
      color: var(--secondary);
    }

    #navClockContainer {
      font-family: 'Roboto Mono', monospace;
      font-size: 16px;
      color: var(--text-dim);
      text-align: center;
    }
    #navClockTime {
        color: var(--primary);
        font-weight: 600;
        letter-spacing: 1px;
    }
     #navClockPeriod {
        color: var(--secondary);
        font-weight: 600;
        margin-left: 5px;
    }

    #navButtons {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    /* Streak Button Specific Styles (adapted from provided CSS) */
    .streak-btn {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      width: 45px;
      height: 45px;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: all .3s ease; /* Smooth transition */
      box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.2);
      background-color: var(--accent); /* Use accent color */
      padding: 0; /* Override default button padding */
      margin: 0; /* Override default button margin */
    }

    .streak-btn .sign {
      width: 100%;
      height: 100%;
      transition: width .3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .streak-btn .sign svg {
      width: 20px; /* Adjusted size */
      height: 20px;
      fill: white; /* White icon */
    }

    /* No text part needed for just the icon */

    .streak-btn:hover {
      transform: scale(1.1); /* Grow slightly on hover */
      box-shadow: 3px 3px 12px rgba(0, 0, 0, 0.3);
    }

     .streak-btn:active {
       transform: scale(1.05) translate(1px, 1px); /* Click effect */
     }

    /* Simple buttons for Profile/Settings in nav */
     #navProfileBtn, #navSettingsBtn {
         background: none;
         border: none;
         color: var(--text-dim);
         font-size: 22px; /* Icon size */
         cursor: pointer;
         padding: 5px;
         margin: 0;
         box-shadow: none;
         transition: color 0.2s ease;
     }
      #navProfileBtn:hover, #navSettingsBtn:hover {
         color: var(--primary);
         transform: none; /* No movement */
         box-shadow: none;
     }


    /* Home Page Styles */
    #homePage {
      justify-content: flex-start; /* Align content top */
      padding-top: 40px; /* Space below nav */
      text-align: center;
    }

    #welcomeMessage {
      font-size: 22px;
      margin-bottom: 15px;
      color: var(--text);
    }
    #welcomeMessage span {
        font-weight: bold;
        color: var(--secondary);
    }

    #dateTimeDisplay {
      font-size: 16px;
      color: var(--text-dim);
      margin-bottom: 30px;
    }

    #focusStatus {
      font-size: 18px;
      color: var(--accent-alt);
      margin-bottom: 40px;
      font-weight: 600;
      min-height: 25px; /* Prevent layout shift */
    }

    #startFocusContainer {
        background-color: rgba(26, 26, 46, 0.7);
        padding: 30px;
        border-radius: 10px;
        border: 1px solid var(--primary-dark);
        max-width: 600px;
        width: 90%;
        margin: 0 auto 30px auto;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
     #startFocusContainer .title {
        font-size: 20px;
        margin-bottom: 20px;
        text-shadow: 1px 1px 0px var(--primary-dark);
     }


    #urlInputs {
        margin-bottom: 15px;
    }
    .url-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      gap: 10px;
    }
    .url-container input {
        margin: 0; /* Override default margin */
        flex-grow: 1;
    }
    .url-container button { /* Style for 'X' remove button */
      padding: 8px 12px;
      margin: 0;
      background: var(--danger);
      font-size: 12px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      min-width: 35px;
    }
     .url-container button:hover {
        background: #c82333;
     }

    #playlistManagement {
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        margin-top: 20px;
        flex-wrap: wrap;
    }
     #playlistManagement select, #playlistManagement input {
        margin: 0;
        max-width: 180px;
     }
     #playlistManagement button {
        margin: 0;
        padding: 10px 15px;
        font-size: 12px;
     }

    #motivationQuote {
      margin-top: 40px;
      font-size: 16px;
      color: var(--text-dim);
      font-style: italic;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }


    /* YouTube Lecture Page Styles */
    #youtubeLecturePage {
        /* Takes full height already from .page-view */
        justify-content: center;
        align-items: center;
        padding: 10px; /* Minimal padding */
    }

    #playerContainer {
      width: 100%;
      max-width: 1200px; /* Limit player width */
      aspect-ratio: 16 / 9;
      position: relative; /* Needed for absolute positioning inside */
      margin: auto; /* Center */
    }

    #player {
      width: 100%;
      height: 100%;
      border-radius: 0;
      overflow: hidden;
      background: #000;
      border: 4px solid var(--primary);
      box-shadow: 0 0 25px rgba(65, 105, 225, 0.6);
      z-index: 5;
       position: absolute;
        top: 0;
        left: 0;
    }

    #timerDisplay {
      position: fixed; /* Keep fixed */
      top: 70px; /* Below top nav */
      left: 10px;
      color: var(--text);
      z-index: 101;
      cursor: move;
      padding: 10px 15px;
      background: rgba(26, 26, 46, 0.85);
      border: 1px solid var(--primary);
      border-radius: 4px;
      font-family: 'Roboto Mono', monospace;
      font-size: 16px;
      pointer-events: auto;
      box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(5px);
    }
     #timerText {
        display: block;
        margin-bottom: 5px;
     }

    #progressBar {
      width: 180px; /* Match padding */
      height: 8px;
      background: var(--bg-light);
      border: 1px solid var(--primary);
      border-radius: 2px;
      overflow: hidden; /* Ensure fill stays inside */
      margin-top: 5px;
      z-index: 101;
       display: block; /* Always visible when timer runs */
    }

    #progressFill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transition: width 0.5s linear; /* Smooth progress */
       border-radius: 1px;
    }

     #youtubeLecturePageControls {
        position: fixed;
        top: 70px;
        right: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 103;
     }

    #restartBtn { /* Renamed from Exit */
      background: var(--danger);
      box-shadow: 3px 3px 0 #a71d2a;
      padding: 8px 15px;
      font-size: 12px;
       margin: 0; /* Remove default margin */
    }
     #restartBtn:hover {
        background: #c82333;
        box-shadow: 2px 2px 0 #a71d2a;
     }

    #pdfToggle {
      background: var(--primary);
      padding: 8px 15px;
      font-size: 12px;
      margin: 0;
    }


    #videoSidebar {
      position: fixed;
      right: -320px; /* Start hidden */
      top: 60px; /* Below nav */
      width: 300px;
      height: calc(100vh - 60px); /* Full height minus nav */
      background: rgba(26, 26, 46, 0.95);
      backdrop-filter: blur(8px);
      transition: right 0.3s ease;
      padding: 20px;
      overflow-y: auto;
      z-index: 102;
      border-left: 3px solid var(--primary);
      pointer-events: auto;
       box-shadow: -5px 0 15px rgba(0,0,0,0.3);
    }
    #videoSidebar.open {
        right: 0;
    }

     #videoSidebarToggleBtn { /* New button to toggle sidebar */
        position: fixed;
        top: 130px;
        right: 10px;
        z-index: 103;
        background: var(--secondary);
        padding: 8px 10px;
        font-size: 18px; /* Icon size */
        border-radius: 4px;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
        margin: 0;
     }
      #videoSidebarToggleBtn:hover {
          background: var(--primary);
      }

    .thumbnail {
      width: 100%;
      margin-bottom: 15px;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 4px;
      transition: all 0.2s ease;
      image-rendering: auto; /* Changed from pixelated */
      pointer-events: auto;
       display: block; /* Prevent extra space */
    }

    .thumbnail:hover {
      border-color: var(--secondary);
      transform: scale(1.03);
       box-shadow: 0 0 10px rgba(142, 45, 226, 0.5);
    }
     .thumbnail.active {
        border-color: var(--accent);
        box-shadow: 0 0 10px rgba(255, 69, 0, 0.6);
     }


    /* Profile Page Styles */
    #profilePage {
        justify-content: flex-start;
        padding-top: 40px;
    }
    #profileContainer {
        background-color: rgba(26, 26, 46, 0.8);
        padding: 40px;
        border-radius: 12px;
        border: 1px solid var(--primary);
        max-width: 500px;
        width: 90%;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    #profileIcon {
        font-size: 60px;
        color: var(--secondary);
        margin-bottom: 15px;
        /* Placeholder - replace with actual icon/image if needed */
        display: inline-block;
        background: var(--bg-light);
        width: 100px;
        height: 100px;
        line-height: 100px;
        border-radius: 50%;
        border: 3px solid var(--primary);
    }
     #profileUsername {
        font-size: 24px;
        font-weight: bold;
        color: var(--text);
        margin-bottom: 10px;
     }
     .profile-stat {
        font-size: 18px;
        color: var(--text-dim);
        margin-bottom: 12px;
        border-bottom: 1px dashed var(--bg-light);
        padding-bottom: 8px;
     }
     .profile-stat span {
         font-weight: bold;
         color: var(--primary);
         margin-left: 8px;
     }
      .profile-stat .level { color: var(--gold); }
      .profile-stat .streak { color: var(--accent); }
      .profile-stat .xp { color: var(--secondary); }


    /* Focus Stats Page Styles */
    #focusStatsPage {
       justify-content: flex-start;
        padding-top: 40px;
    }
     #focusStatsContainer {
         background-color: rgba(26, 26, 46, 0.8);
        padding: 30px;
        border-radius: 12px;
        border: 1px solid var(--primary);
        max-width: 700px;
        width: 90%;
        box-shadow: 0 5px 20px rgba(0,0,0,0.3);
     }
     #focusStatsContainer h3 {
         text-align: center;
         font-family: 'Press Start 2P', cursive;
         font-size: 20px;
         color: var(--secondary);
         margin-bottom: 30px;
     }
     #statsDisplay {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
     }
     .stat-item {
         background: var(--bg-light);
         padding: 15px;
         border-radius: 6px;
         border: 1px solid var(--primary-dark);
         text-align: center;
     }
     .stat-item .label {
         font-size: 14px;
         color: var(--text-dim);
         margin-bottom: 8px;
         display: block;
     }
      .stat-item .value {
         font-size: 22px;
         font-weight: bold;
         color: var(--primary);
      }
      .stat-item .value.videos { color: var(--secondary); }
      .stat-item .value.distractions { color: var(--accent); }


     #focusCalendar {
         margin-top: 30px;
         background: var(--bg-light);
         padding: 20px;
         border-radius: 8px;
          border: 1px solid var(--primary-dark);
     }
      #focusCalendar h4 {
         text-align: center;
         margin-bottom: 15px;
         color: var(--text-dim);
      }
       #calendarGrid {
         /* Placeholder for actual calendar implementation */
         min-height: 150px;
         display: flex;
         justify-content: center;
         align-items: center;
         color: var(--text-dim);
         font-style: italic;
       }


    /* Sidebar Styles */
    .sidebar-trigger {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 25px; /* Wider trigger */
      height: 100px;
      background: var(--primary);
      z-index: 199;
      border-radius: 0 8px 8px 0; /* Rounded corners */
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text);
      font-weight: bold;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 14px;
      letter-spacing: 2px;
      pointer-events: auto;
       transition: background-color 0.2s ease;
       box-shadow: 3px 0 8px rgba(0,0,0,0.3);
    }
     .sidebar-trigger:hover {
        background: var(--secondary);
     }

    .game-sidebar {
      position: fixed;
      left: -300px; /* Start hidden */
      top: 0;
      width: 280px; /* Wider sidebar */
      height: 100vh;
      background: rgba(26, 26, 46, 0.98); /* More opaque */
      backdrop-filter: blur(5px);
      border-right: 3px solid var(--primary);
      z-index: 200;
      transition: left 0.3s ease;
      padding: 70px 0 20px 0; /* Padding top for nav bar */
      box-shadow: 4px 0 15px rgba(0, 0, 0, 0.4);
      overflow-y: auto;
      pointer-events: auto; /* Allows interaction when open */
    }

    .game-sidebar.open {
        left: 0;
    }

    .sidebar-section {
      padding: 15px 20px; /* More padding */
      border-bottom: 1px solid var(--bg-light);
    }
    .sidebar-section:last-child {
        border-bottom: none;
    }

    .sidebar-section h3 {
      color: var(--secondary);
      font-size: 16px;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
       padding-bottom: 5px;
       border-bottom: 1px dashed var(--primary-dark);
    }

    .sidebar-section a,
    .sidebar-section button {
      display: block; /* Ensure buttons take full width */
      width: 100%; /* Full width */
      padding: 10px 15px; /* More padding */
      margin: 8px 0; /* More spacing */
      background: var(--bg-light);
      color: var(--text);
      border: 1px solid var(--primary);
      border-radius: 4px;
      text-align: left;
      font-size: 14px;
      font-family: 'Roboto Mono', monospace;
      cursor: pointer;
      transition: all 0.2s ease;
      pointer-events: auto;
      z-index: 201;
       text-transform: none; /* Remove uppercase from general button style */
       box-shadow: none; /* Remove general button shadow */
       letter-spacing: 0.5px;
    }

    .sidebar-section a:hover,
    .sidebar-section button:hover {
      background: var(--primary);
      color: white;
      transform: translateX(5px); /* Subtle shift */
      border-color: var(--secondary);
       box-shadow: none;
    }

    .sidebar-section a {
        text-decoration: none;
    }

     /* Specific button styles within sidebar if needed */
     #logoutBtn {
        background: var(--danger);
        border-color: #a71d2a;
        color: white;
     }
      #logoutBtn:hover {
        background: #c82333;
        border-color: #a71d2a;
      }


    /* Shared Components (Points, Lofi, AI, Dialogs, Overlays) */

    #pointsDisplay {
      position: fixed;
      top: 120px; /* Position relative to top nav */
      left: 10px;
      font-size: 16px;
      color: var(--text);
      font-family: 'Roboto Mono', monospace;
      font-weight: 600;
      z-index: 101;
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(5px);
      padding: 8px 12px;
      border: 1px solid var(--secondary);
      border-radius: 4px;
      box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
      pointer-events: none; /* Display only */
    }

    #achievementLevel {
      position: fixed;
      top: 70px; /* Below nav */
      right: 10px;
      font-size: 16px;
      font-weight: bold;
      z-index: 101;
      font-family: 'Press Start 2P', cursive; /* Match title font */
      background: rgba(26, 26, 46, 0.85);
      backdrop-filter: blur(5px);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
      border-radius: 4px;
      pointer-events: none;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
     /* Glow/Rainbow styles for levels */
    .rainbow {
      background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 3s infinite linear; /* Smooth rainbow effect */
      border-color: transparent; /* Hide border for rainbow */
    }
     @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
     .level-glow { text-shadow: 0 0 10px var(--text); }
     .level-box-glow { box-shadow: 0 0 10px var(--gold); }


    #lofiPlayer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 101;
      background: rgba(26, 26, 46, 0.9);
      backdrop-filter: blur(5px);
      padding: 12px;
      border: 1px solid var(--primary);
      border-radius: 6px;
      box-shadow: 0 -3px 15px rgba(0, 0, 0, 0.3);
      pointer-events: auto;
      display: none; /* Controlled by JS */
    }

    #lofiPlayer .lofi-title { /* Added title */
      text-align: center;
      margin-bottom: 8px;
      font-size: 12px;
      color: var(--text-dim);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    #lofiPlayer button {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 6px 12px; /* Slightly larger */
      margin: 0 3px;
      cursor: pointer;
      font-size: 14px; /* Larger icons/text */
      border-radius: 4px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      font-family: 'Roboto Mono', monospace;
      z-index: 102;
      min-width: 35px; /* Ensure minimum size */
    }
     #lofiPlayer button:hover {
        background: var(--primary);
     }


    #fireBox { /* AI Chatbot Trigger */
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 50px; /* Slightly larger */
      height: 50px;
      background: var(--primary);
      border-radius: 50%; /* Circle */
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 26px; /* Larger icon */
      cursor: pointer;
      z-index: 100;
      box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.4);
      border: 2px solid var(--secondary);
      pointer-events: auto;
       transition: all 0.2s ease;
       display: none; /* Controlled by JS */
    }

    #fireBox:hover {
      background: var(--secondary);
      transform: translateY(-3px) scale(1.05);
      box-shadow: 4px 4px 15px rgba(0, 0, 0, 0.5);
    }

    #aiPopup {
      position: fixed;
      bottom: 70px; /* Position above trigger */
      left: 10px;
      width: 320px; /* Wider */
      height: 450px; /* Taller */
      background: var(--bg-medium);
      border-radius: 8px;
      padding: 5px;
      display: none; /* Toggled by JS */
      z-index: 101;
      box-shadow: 5px 5px 20px rgba(0, 0, 0, 0.4);
      border: 3px solid var(--primary);
      pointer-events: auto;
       overflow: hidden; /* Hide iframe border spill */
    }

    #aiPopup iframe {
      width: 100%;
      height: 100%;
      border: none;
       border-radius: 5px; /* Match container */
    }

    /* Dialog Styles (Confirmation, Powerups, Deadline, etc.) */
    .dialog-overlay { /* Common wrapper for dialogs */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6); /* Darker overlay */
      backdrop-filter: blur(5px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 105;
      display: none; /* Controlled by JS */
      pointer-events: auto;
      padding: 15px;
    }

    .dialog-box {
      background: var(--bg-medium);
      padding: 25px 30px;
      border: 3px solid var(--accent);
      box-shadow: 0 0 30px rgba(255, 69, 0, 0.5);
      border-radius: 10px;
      text-align: center;
      pointer-events: auto;
      font-family: 'Roboto Mono', monospace;
      max-width: 450px; /* Max width */
      width: 90%; /* Responsive width */
    }
     .dialog-box h3 {
        color: var(--accent);
        font-size: 20px;
        margin-bottom: 15px;
        font-family: 'Press Start 2P', cursive;
     }

    .dialog-box p {
      font-size: 16px;
      margin-bottom: 25px;
      color: var(--text);
      line-height: 1.5;
    }

    .dialog-box .dialog-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
        flex-wrap: wrap;
    }

    .dialog-box button {
      padding: 10px 25px;
      margin: 0; /* Remove default margin */
      font-size: 14px;
      pointer-events: auto;
      z-index: 106;
    }
    /* Specific dialog button colors */
    #confirmBtn, #streakShieldConfirmBtn, #doublePointsConfirmBtn, #deadlineConfirmBtn, #sessionContinueBtn, #openMysteryBox {
      background: var(--accent);
       box-shadow: 3px 3px 0 #b33000;
    }
     #confirmBtn:hover, #streakShieldConfirmBtn:hover, #doublePointsConfirmBtn:hover, #deadlineConfirmBtn:hover, #sessionContinueBtn:hover, #openMysteryBox:hover {
        background: var(--accent-alt);
        box-shadow: 2px 2px 0 #b33000;
     }
    #cancelBtn, #streakShieldCancelBtn, #doublePointsCancelBtn, #deadlineCancelBtn, #sessionEndBtn, #closeAudioStore, #mysteryBoxPopup button /* Assuming a close button */ {
      background: var(--primary);
      box-shadow: 3px 3px 0 var(--primary-dark);
    }
    #cancelBtn:hover, #streakShieldCancelBtn:hover, #doublePointsCancelBtn:hover, #deadlineCancelBtn:hover, #sessionEndBtn:hover, #closeAudioStore:hover, #mysteryBoxPopup button:hover {
       background: var(--primary-dark);
       box-shadow: 2px 2px 0 var(--primary-dark);
    }

     /* Deadline Dialog specific inputs */
    #deadlineDialog input, #deadlineDialog select {
       margin: 15px auto; /* More space */
    }

    /* Mystery Box Dialog */
     #mysteryBoxPopup .dialog-box {
        border-color: var(--gold);
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.6);
     }
     #mysteryBoxPopup h3 { color: var(--gold); }
     #mysteryRewardText { font-weight: bold; color: var(--accent-alt); }

     /* Audio Store Dialog */
     #audioTracksStore .dialog-box {
         border-color: var(--secondary);
         box-shadow: 0 0 30px rgba(142, 45, 226, 0.5);
         max-width: 500px;
         max-height: 80vh;
         overflow-y: auto;
     }
     #audioTracksStore h3 { color: var(--secondary); }
     #audioTracksList { margin-top: 20px; }
     .audio-track-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 15px;
      margin-bottom: 10px;
      background: var(--bg-light);
      border: 1px solid var(--primary);
      border-radius: 4px;
      transition: background-color 0.2s;
    }
     .audio-track-item:hover { background-color: var(--bg-medium); }

    .audio-track-item .track-info { text-align: left; }
    .audio-track-item .track-name { font-weight: bold; }
    .audio-track-item.locked .track-name { color: var(--text-dim); }
    .audio-track-item.unlocked .track-name { color: var(--accent-alt); }
    .audio-track-item .track-cost { font-size: 12px; color: var(--text-dim); }

    .unlock-track-btn {
      padding: 6px 12px;
      background: var(--secondary);
      font-size: 12px;
      margin: 0;
       flex-shrink: 0; /* Prevent shrinking */
    }
    .unlock-track-btn:disabled {
      background: var(--bg-light);
      color: var(--text-dim);
      cursor: not-allowed;
       opacity: 0.7;
    }
     .unlock-track-btn.unlocked {
        background: var(--success);
        color: white;
        cursor: default;
     }
      .unlock-track-btn.unlocked:hover { background: var(--success); } /* Keep color on hover */

    /* Achievement Overlay */
    #achievementOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(15, 15, 27, 0.85); /* Darker with slight transparency */
      backdrop-filter: blur(8px);
      display: flex;
      justify-content: center;
      align-items: center;
      color: gold;
      font-size: 36px; /* Larger text */
      font-weight: bold;
      z-index: 104;
      display: none; /* Toggled by JS */
      font-family: 'Press Start 2P', cursive; /* Game font */
      text-align: center;
      text-shadow: 3px 3px 0 var(--primary-dark), 5px 5px 10px rgba(0,0,0,0.5);
      background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23FFD700' fill-opacity='0.1' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E"); /* Subtle gold dots */
      pointer-events: none;
       padding: 20px;
       line-height: 1.4;
    }

    /* To-Do List Popup */
    #todoList {
      position: fixed; /* Changed to fixed */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50());
      width: 90%; /* Responsive */
      max-width: 400px; /* Max width */
      max-height: 70vh; /* Limit height */
      background: var(--bg-medium);
      padding: 20px;
      border: 2px solid var(--secondary);
      border-radius: 8px;
      display: none; /* Toggled by JS */
      z-index: 100;
      box-shadow: 0 5px 25px rgba(0, 0, 0, 0.4);
      pointer-events: auto;
      display: flex;
      flex-direction: column;
    }

    #todoList h3 {
      font-size: 18px;
      margin-bottom: 15px;
      color: var(--secondary);
      font-family: 'Roboto Mono', monospace;
      text-align: center;
       flex-shrink: 0; /* Prevent shrinking */
    }

    #tasks {
      overflow-y: auto; /* Scrollable task area */
      margin-bottom: 15px;
      background: none;
      padding-right: 5px; /* Space for scrollbar */
       flex-grow: 1; /* Take available space */
    }

    .task-line {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
      background: var(--bg-light);
      padding: 8px 10px;
      border: 1px solid var(--primary-dark);
      border-radius: 4px;
      pointer-events: auto;
       transition: background-color 0.2s;
    }
     .task-line:hover {
        background-color: rgba(37, 37, 56, 0.8); /* Slightly lighter on hover */
     }

    .task-line input[type="checkbox"] {
      margin-right: 12px;
      width: 18px; /* Larger checkbox */
      height: 18px;
      appearance: none;
      border: 2px solid var(--primary);
      background: var(--bg-medium);
      position: relative;
      cursor: pointer;
      pointer-events: auto;
      z-index: 11;
       border-radius: 3px;
       transition: background-color 0.2s, border-color 0.2s;
       flex-shrink: 0;
    }

    .task-line input[type="checkbox"]:checked {
      background: var(--secondary);
      border-color: var(--secondary);
    }

    .task-line input[type="checkbox"]:checked::after {
      content: "âœ”"; /* Checkmark */
      position: absolute;
      color: var(--text);
      font-size: 14px;
      font-weight: bold;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

     .task-line input[type="checkbox"]:hover {
        border-color: var(--secondary);
     }

    .task-line input[type="text"] {
      flex-grow: 1;
      font-size: 15px;
      font-family: 'Roboto Mono', monospace;
      color: var(--text);
      background: transparent;
      border: none;
      border-bottom: 1px solid transparent; /* Hidden border */
      padding: 5px 0; /* Vertical padding */
      outline: none;
      box-shadow: none;
      margin: 0;
      pointer-events: auto;
      z-index: 11;
       transition: border-color 0.2s;
    }

    .task-line input[type="text"]:focus {
      border-bottom: 1px solid var(--secondary);
      box-shadow: none;
    }
     .task-line input[type="text"][readonly] { /* Style for completed tasks */
        text-decoration: line-through;
        color: var(--text-dim);
     }


    .task-line .task-buttons { /* Container for buttons */
        display: flex;
        align-items: center;
        margin-left: 10px;
         flex-shrink: 0;
    }

    .task-line .set-deadline,
    .task-line .remove-task {
      color: var(--text-dim);
      font-size: 16px;
      cursor: pointer;
      background: none;
      border: none;
      padding: 5px;
      line-height: 1;
      pointer-events: auto;
      z-index: 11;
      transition: color 0.2s;
      margin: 0 2px; /* Spacing between buttons */
    }
     .task-line .set-deadline:hover { color: var(--primary); }
     .task-line .remove-task:hover { color: var(--danger); }


    .task-line .deadline-info,
    .task-line .points-info {
      margin-left: 8px;
      font-size: 11px;
       padding: 2px 5px;
       border-radius: 3px;
       white-space: nowrap; /* Prevent wrapping */
    }
     .task-line .deadline-info { color: var(--accent-alt); background-color: rgba(255, 140, 0, 0.1); }
     .task-line .points-info { color: var(--secondary); background-color: rgba(142, 45, 226, 0.1); }

     #todoList .dialog-buttons { /* Buttons at the bottom */
        margin-top: 15px;
        flex-shrink: 0;
     }


    /* Quiet Pomodoro Styles */
    #pomodoroOverlay { /* Uses .dialog-overlay */
        background: rgba(15, 15, 27, 0.95); /* More opaque */
        backdrop-filter: blur(12px); /* Stronger blur */
         z-index: 1000; /* Highest priority */
    }

    #pomodoroContainer { /* Replaces .dialog-box for specific styling */
      width: 90%;
      max-width: 420px;
      background: transparent; /* Transparent background */
      padding: 30px;
      border: none; /* No border */
      box-shadow: none; /* No shadow */
      text-align: center;
      pointer-events: auto;
    }
    #pomodoroContainer h3 {
         font-family: 'Press Start 2P', cursive;
         font-size: 22px;
         color: var(--secondary);
         margin-bottom: 15px;
          text-shadow: 2px 2px 0px var(--primary-dark);
    }
    #pomodoroContainer p {
        font-size: 16px;
        color: var(--text-dim);
        margin-bottom: 30px;
    }

    #pomodoroTimer {
      font-size: 90px; /* Larger timer */
      font-weight: bold;
      color: var(--text);
      margin: 25px 0;
      font-family: 'Orbitron', sans-serif; /* Digital-style font */
       text-shadow: 0 0 15px rgba(65, 105, 225, 0.5), 0 0 25px rgba(142, 45, 226, 0.4);
    }

    #pomodoroStatus {
      font-size: 18px;
      color: var(--accent-alt);
      margin-top: 20px;
       min-height: 25px; /* Prevent layout jumps */
       font-weight: 600;
    }

    #pomodoroControls {
      display: flex;
      justify-content: center;
      gap: 25px; /* More space */
      margin-top: 35px;
    }

    #pomodoroControls button {
      padding: 12px 30px; /* Larger buttons */
      font-size: 16px;
    }
     #pomodoroStartBtn { background: var(--success); border: none; box-shadow: 3px 3px 0 #1c7430;}
     #pomodoroStartBtn:hover { background: #218838; box-shadow: 2px 2px 0 #1c7430;}
     #pomodoroResetBtn { background: var(--accent); box-shadow: 3px 3px 0 #b33000;}
     #pomodoroResetBtn:hover { background: var(--accent-alt); box-shadow: 2px 2px 0 #b33000;}
     #pomodoroCloseBtn { background: var(--bg-light); box-shadow: 3px 3px 0 var(--bg-medium);}
     #pomodoroCloseBtn:hover { background: var(--bg-medium); box-shadow: 2px 2px 0 var(--bg-medium);}


    /* PDF Viewer Styles */
    #pdfViewer { /* Uses .dialog-box structure */
      max-width: 80vw; /* Wider */
      max-height: 85vh; /* Taller */
      width: auto;
      height: auto;
       border-color: var(--primary);
        box-shadow: 0 0 30px rgba(65, 105, 225, 0.5);
        display: flex;
        flex-direction: column;
    }
     #pdfViewer h3 {
        color: var(--primary);
        font-size: 18px;
        margin-bottom: 15px;
         flex-shrink: 0;
     }
    #pdfInput {
      margin-bottom: 15px;
      width: 100%;
      pointer-events: auto;
      z-index: 102;
       flex-shrink: 0;
    }

    #pdfFrameContainer {
        flex-grow: 1; /* Take remaining space */
        width: 100%;
        min-height: 400px; /* Minimum height */
        background: #ccc; /* Placeholder bg */
         border: 1px solid var(--primary-dark);
         border-radius: 4px;
         overflow: hidden; /* Clip iframe */
    }

    #pdfFrame {
      width: 100%;
      height: 100%;
      border: none;
      background: #fff; /* White background for PDF */
    }
     #pdfViewer .dialog-buttons {
        margin-top: 15px;
         flex-shrink: 0;
     }
     #pdfViewer button[onclick*="togglePDFViewer"] { /* Close button */
         background: var(--danger);
         box-shadow: 3px 3px 0 #a71d2a;
     }
      #pdfViewer button[onclick*="togglePDFViewer"]:hover {
         background: #c82333;
         box-shadow: 2px 2px 0 #a71d2a;
     }


    /* Responsive Adjustments */
    @media (max-width: 800px) {
      body { font-size: 14px; }
      .title { font-size: 22px; margin-bottom: 20px;}
      .subtitle { font-size: 16px; margin-bottom: 25px; }
      button { padding: 8px 18px; font-size: 12px; margin: 5px 5px 12px; }
      #landingPageContainer, #signinFormContainer { padding: 30px 20px; }
      #features { gap: 15px; }
      .feature { width: 180px; padding: 15px; }
      .feature i { font-size: 24px; }
      .feature p { font-size: 14px; }
      input[type="text"], input[type="password"], input[type="date"], input[type="time"], input[type="file"], select { padding: 10px 12px; font-size: 14px; }

      #topNavBar { height: 50px; padding: 0 15px; }
      #navLogo { font-size: 16px; }
      #navClockContainer { font-size: 14px; }
      #navButtons { gap: 10px; }
      .streak-btn { width: 40px; height: 40px; }
      .streak-btn .sign svg { width: 18px; height: 18px; }
      #navProfileBtn, #navSettingsBtn { font-size: 20px; }

      .page-view { padding: 15px; height: calc(100vh - 50px); }
      #homePage { padding-top: 30px; }
      #welcomeMessage { font-size: 18px; }
      #dateTimeDisplay, #motivationQuote { font-size: 14px; }
      #focusStatus { font-size: 16px; margin-bottom: 30px; }
      #startFocusContainer { padding: 20px; }
      #startFocusContainer .title { font-size: 18px; }

       #timerDisplay { top: 60px; font-size: 14px; padding: 8px 12px; }
       #progressBar { width: 150px; height: 6px; }
       #pointsDisplay { top: 105px; font-size: 14px; padding: 6px 10px; }
       #achievementLevel { top: 60px; font-size: 14px; padding: 6px 10px; }

       #youtubeLecturePageControls { top: 60px; }
       #restartBtn, #pdfToggle, #videoSidebarToggleBtn { padding: 6px 10px; font-size: 10px; }
        #videoSidebarToggleBtn { top: 110px; font-size: 16px; }


      #videoSidebar { width: 250px; right: -270px; top: 50px; height: calc(100vh - 50px); }
      #lofiPlayer { padding: 10px; }
      #lofiPlayer button { padding: 5px 10px; font-size: 12px; min-width: 30px;}
      #fireBox { width: 45px; height: 45px; font-size: 22px; }
      #aiPopup { width: 90%; max-width: 300px; height: 400px; bottom: 65px; }

      .dialog-box { padding: 20px; }
      .dialog-box h3 { font-size: 18px; }
      .dialog-box p { font-size: 14px; margin-bottom: 20px; }
      .dialog-box button { padding: 8px 20px; font-size: 12px; }

      #pomodoroContainer { padding: 20px; }
      #pomodoroTimer { font-size: 60px; margin: 20px 0;}
      #pomodoroControls { gap: 15px; margin-top: 25px;}
      #pomodoroControls button { padding: 10px 20px; font-size: 14px; }

      #profileContainer { padding: 30px; }
      #profileIcon { font-size: 50px; width: 80px; height: 80px; line-height: 80px;}
      #profileUsername { font-size: 20px; }
      .profile-stat { font-size: 16px; }

       #focusStatsContainer { padding: 20px; }
       #focusStatsContainer h3 { font-size: 18px; margin-bottom: 25px; }
       .stat-item .value { font-size: 20px; }

       #todoList { max-width: 90%; }
       .task-line input[type="text"] { font-size: 14px; }
    }

     @media (max-width: 480px) {
        .title { font-size: 18px; }
        .subtitle { font-size: 14px; }
        #navLogo { display: none; } /* Hide logo on very small screens */
         #navClockContainer { flex-grow: 1; text-align: left; margin-left: -10px;} /* Shift clock left */
        #homePage { padding-top: 20px; }
        #welcomeMessage { font-size: 16px; }
         #startFocusContainer { padding: 15px; }
         #startFocusContainer .title { font-size: 16px; }
         .url-container { flex-direction: column; align-items: stretch; gap: 5px; }
         .url-container button { width: 100%; margin-top: 5px; }
         #playlistManagement { flex-direction: column; gap: 8px; align-items: stretch;}
         #playlistManagement select, #playlistManagement input { max-width: 100%; }

         #timerDisplay { font-size: 12px; padding: 6px 8px; }
         #progressBar { width: 120px; }
         #pointsDisplay { font-size: 12px; padding: 5px 8px; }
         #achievementLevel { font-size: 12px; padding: 5px 8px; }

         #videoSidebar { width: 200px; right: -220px; padding: 15px; }

         #pomodoroTimer { font-size: 48px; }
         #pomodoroControls { gap: 10px; }
         #pomodoroControls button { padding: 8px 15px; font-size: 12px; }

         .dialog-box button { padding: 8px 15px; }

         .sidebar-trigger { width: 20px; height: 80px; font-size: 12px;}
         .game-sidebar { width: 240px; left: -260px;}
     }

  </style>
  <!-- Include Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Press+Start+2P&family=Roboto+Mono:wght@400;600&display=swap" rel="stylesheet">
   <!-- Font Awesome for Icons (Optional) -->
   <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

</head>
<body>

  <!-- Top Navigation Bar -->
  <nav id="topNavBar">
    <a href="#" id="navLogo" title="Quest for Focus">Q<span>4</span>F</a>
    <div id="navClockContainer">
        <span id="navClockTime">00:00:00</span>
        <span id="navClockPeriod">AM</span>
    </div>
    <div id="navButtons">
        <button id="navProfileBtn" title="View Profile">
             <i class="fas fa-user-circle"></i> <!-- Example Font Awesome icon -->
        </button>
        <button id="topNavStreakBtn" class="streak-btn" title="Focus Streak">
            <div class="sign">
                <svg viewBox="0 0 384 512" fill="currentColor" height="1em" width="1em"> <!-- Fire Icon -->
                    <path d="M153.6 467.2c-9.2 5.1-20.6.1-25.7-9.1C121.1 445.6 102.9 416 102.9 384c0-70.7 57.3-128 128-128s128 57.3 128 128c0 32-18.2 61.6-45.1 74.1-5.1 9.2-16.5 14.2-25.7 9.1s-14.2-16.5-9.1-25.7c18.2-32.9 14.9-73.8-10.3-103.3-24.5-28.7-62.5-40.9-98.1-31.9-4.7 1.2-8.8-2.2-10-6.9s2.2-8.8 6.9-10c42.8-10.7 88.4 1.3 119.1 31.9 30.7 30.7 34 79.1 10.3 113.3 9.2-5.1 20.6-.1 25.7 9.1 30.1-14.9 49.9-46.8 49.9-82.1 0-88.4-71.6-160-160-160S72.5 295.6 72.5 384c0 35.3 19.8 67.2 49.9 82.1 5.1-9.2 16.5-14.2 25.7-9.1s14.2 16.5 9.1 25.7-16.5 14.2-25.7 9.1z"></path>
                </svg>
            </div>
        </button>
       <!-- <button id="navSettingsBtn" title="Settings (Coming Soon)">
             <i class="fas fa-cog"></i>
        </button> -->
    </div>
  </nav>

  <!-- Main Game Container -->
  <div class="game-container">

    <!-- Sidebar Trigger -->
    <div class="sidebar-trigger" title="Open Menu">MENU</div>

    <!-- Sidebar -->
    <div class="game-sidebar">
        <div class="sidebar-section">
            <h3>Navigation</h3>
            <button data-action="show-view" data-view="home"><i class="fas fa-home"></i> Home</button>
            <button data-action="show-view" data-view="youtubeLecture"><i class="fab fa-youtube"></i> Watch Lectures</button>
             <button data-action="toggle-todo"><i class="fas fa-list-check"></i> To-Do List</button>
        </div>
        <div class="sidebar-section">
            <h3>Progress</h3>
             <button data-action="show-view" data-view="focusStats"><i class="fas fa-chart-line"></i> Focus Stats</button>
             <a href="https://room.examgoal.com/" target="_blank" rel="noreferrer"><i class="fas fa-dumbbell"></i> PYQs Practice</a>
        </div>
         <div class="sidebar-section">
            <h3>Self Study</h3>
            <button id="quietPomodoroBtn"><i class="fas fa-stopwatch"></i> Quiet Pomodoro</button>
          </div>
        <div class="sidebar-section">
            <h3>Shops & Realms</h3>
            <button id="streakShieldBtn"><i class="fas fa-shield-alt"></i> Streak Shield</button>
            <button id="doublePointsBtn"><i class="fas fa-bolt"></i> Double XP</button>
            <button id="audioStoreBtn"><i class="fas fa-music"></i> Audio Store</button>
             <a href="https://forestquest.vercel.app/" target="_blank" rel="noreferrer"><i class="fas fa-tree"></i> Forest Quest</a>
            <a href="https://focuswithpomodoro.netlify.app/" target="_blank" rel="noreferrer"><i class="fas fa-clock"></i> Pomodoro Realm</a>
            <a href="https://the-chosen-one-o5.github.io/Daily-Schedule/" target="_blank" rel="noreferrer"><i class="fas fa-calendar-alt"></i> Daily Planner</a>
        </div>
      <div class="sidebar-section">
        <h3>Account</h3>
         <button data-action="show-view" data-view="profile"><i class="fas fa-user"></i> Profile</button>
        <button id="logoutBtn"><i class="fas fa-sign-out-alt"></i> Logout</button>
      </div>
    </div>

    <!-- == Page Views == -->

    <!-- Landing Page View -->
    <div id="landingPage" class="page-view" style="display: flex;"> <!-- Show initially -->
        <div id="landingPageContainer">
            <div class="title">QUEST FOR <span>FOCUS</span></div>
            <div class="subtitle">Embark on your learning adventure! Conquer distractions, master knowledge.</div>
            <button data-action="show-view" data-view="signin" class="primary-btn">START YOUR QUEST</button>
            <button class="github-btn" data-action="github">
                <i class="fab fa-github"></i> GITHUB REPO
            </button>
            <div id="features">
                <div class="feature">
                <i class="fas fa-ban"></i> <!-- Ad ban icon -->
                <p>Ad-Free Zone<br>Focus without interruptions</p>
                </div>
                <div class="feature">
                <i class="fas fa-moon"></i> <!-- Moon icon -->
                <p>Immersive Dark Mode<br>Easy on the eyes</p>
                </div>
                <div class="feature">
                 <i class="fas fa-gamepad"></i> <!-- Gamify icon -->
                 <p>Gamified Learning<br>Level up your knowledge</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Sign In/Up View -->
    <div id="signinForm" class="page-view">
         <div id="signinFormContainer">
            <div class="title">ENTER THE <span>REALM</span></div>
            <div class="subtitle">Log in or create your hero profile to begin.</div>
            <input type="text" id="username" placeholder="Hero Name" required />
            <input type="password" id="password" placeholder="Secret Code" required />
            <button data-action="sign-in" class="primary-btn">SIGN IN</button>
            <p style="color: var(--text-dim); margin-top: 15px;">New adventurer?
                <button data-action="create-account" class="accent-btn" style="margin-left: 5px; background: var(--secondary); box-shadow: 3px 3px 0 var(--primary-dark);">CREATE ACCOUNT</button>
            </p>
             <button data-action="show-view" data-view="landing" style="margin-top: 20px; background: var(--bg-light); font-size: 12px;"> <i class="fas fa-arrow-left"></i> Back</button>
        </div>
    </div>

    <!-- Home Page View -->
    <div id="homePage" class="page-view">
        <div id="welcomeMessage">Welcome back, <span id="homeUsername">Hero</span>!</div>
        <div id="dateTimeDisplay">Loading date and time...</div>
        <div id="focusStatus">Ready to get in the zone?</div>

        <div id="startFocusContainer">
             <div class="title" style="font-size: 20px; margin-bottom: 20px;">Prepare Your <span>Session</span></div>

            <select id="playlistSelect">
                <option value="">Load Saved Playlist</option>
                <!-- Options added dynamically -->
            </select>

            <div id="urlInputs">
                <div class="url-container">
                <input type="text" class="youtube-url" placeholder="YouTube Video/Live URL" required />
                <!-- Remove button added dynamically for extras -->
                </div>
            </div>
            <button data-action="add-url" style="font-size: 12px; padding: 8px 15px;"><i class="fas fa-plus"></i> Add Another URL</button>

             <div id="playlistManagement">
                <input type="text" id="playlistName" placeholder="Save Playlist As..." />
                <button data-action="save-playlist" class="primary-btn" style="font-size: 12px;"><i class="fas fa-save"></i> Save</button>
                <button data-action="remove-playlist" class="accent-btn" style="font-size: 12px; background: var(--danger); box-shadow: 3px 3px 0 #a71d2a;"><i class="fas fa-trash"></i> Delete Selected</button>
            </div>


            <button data-action="start-playback" class="primary-btn" style="margin-top: 25px; padding: 12px 30px;"><i class="fas fa-play-circle"></i> BEGIN FOCUS</button>
        </div>


        <div id="motivationQuote">"The journey of a thousand miles begins with a single step."</div>
    </div>

    <!-- YouTube Lecture View -->
    <div id="youtubeLecturePage" class="page-view">
        <div id="playerContainer">
             <div id="player"></div> <!-- YouTube player iframe -->
        </div>

         <!-- Sidebar Toggle Button -->
        <button id="videoSidebarToggleBtn" title="Toggle Video List (T)">
            <i class="fas fa-list"></i>
        </button>


         <!-- YouTube Controls -->
         <div id="youtubeLecturePageControls">
            <button id="restartBtn" title="Exit Session"><i class="fas fa-times-circle"></i> Exit</button>
            <button id="pdfToggle" title="Upload & View PDF"><i class="fas fa-file-pdf"></i> PDF</button>
        </div>

         <!-- Video Sidebar -->
        <div id="videoSidebar">
            <!-- Thumbnails added dynamically -->
             <h3 style="color: var(--secondary); margin-bottom: 15px; text-align: center; font-size: 16px;">Video Playlist</h3>
             <div id="videoThumbnailList"></div>
        </div>
    </div>

    <!-- Profile View -->
    <div id="profilePage" class="page-view">
         <div id="profileContainer">
             <div id="profileIcon">ðŸ§™</div> <!-- Placeholder icon -->
             <div id="profileUsername">Hero Name</div>
             <div class="profile-stat">Level: <span id="profileLevel" class="level">Mortal</span></div>
             <div class="profile-stat">XP: <span id="profileXP" class="xp">0</span></div>
             <div class="profile-stat">Focus Streak: <span id="profileStreak" class="streak">0 days</span></div>
             <!-- Add more stats or settings here if needed -->
              <button data-action="show-view" data-view="home" style="margin-top: 20px; background: var(--bg-light); font-size: 12px;"> <i class="fas fa-arrow-left"></i> Back to Home</button>
         </div>
    </div>

    <!-- Focus Stats View -->
    <div id="focusStatsPage" class="page-view">
         <div id="focusStatsContainer">
            <h3><i class="fas fa-chart-bar"></i> Hero <span>Stats</span></h3>
            <div id="statsDisplay">
                <div class="stat-item">
                    <span class="label">Total Focus Time</span>
                    <span id="statsTotalFocusTime" class="value">0 min</span>
                </div>
                 <div class="stat-item">
                    <span class="label">Distractions Defeated</span>
                    <span id="statsTotalDistractions" class="value distractions">0</span>
                </div>
                 <div class="stat-item">
                    <span class="label">Videos Completed</span>
                    <span id="statsTotalVideosWatched" class="value videos">0</span>
                </div>
                <div class="stat-item">
                    <span class="label">Current Streak</span>
                    <span id="statsCurrentStreak" class="value streak">0 days</span>
                </div>
            </div>
             <div id="focusCalendar">
                <h4>Focus Activity Calendar (Coming Soon)</h4>
                <div id="calendarGrid">
                    Calendar visualization will appear here.
                </div>
             </div>
             <button data-action="show-view" data-view="home" style="margin-top: 30px; background: var(--bg-light); font-size: 12px; display: block; margin-left: auto; margin-right: auto;"> <i class="fas fa-arrow-left"></i> Back to Home</button>
         </div>
    </div>


    <!-- == Shared Components (Positioned Fixed or Popups) == -->

    <!-- Timer Display (for YouTube page) -->
    <div id="timerDisplay" style="display: none;"> <!-- Hidden initially -->
      <span id="timerText">Focus Time: 00:00</span>
      <div id="progressBar">
        <div id="progressFill"></div>
      </div>
    </div>

    <!-- Points Display -->
    <div id="pointsDisplay"><span style="color: var(--secondary);">â­</span> XP: 0</div>

     <!-- Achievement Level Display -->
    <div id="achievementLevel">Mortal</div>

    <!-- To-Do List Popup -->
    <div id="todoList">
        <h3><i class="fas fa-tasks"></i> QUEST LOG</h3>
        <div id="tasks">
          <!-- Task lines added dynamically -->
        </div>
         <div class="dialog-buttons">
            <button data-action="save-tasks" class="primary-btn"><i class="fas fa-save"></i> Save Quests</button>
             <button data-action="add-task-line" style="background: var(--bg-light);"><i class="fas fa-plus"></i> Add Quest</button>
            <button data-action="close-todo" class="accent-btn" style="background: var(--danger); box-shadow: 3px 3px 0 #a71d2a;"><i class="fas fa-times"></i> Close</button>
         </div>
    </div>


    <!-- Lo-Fi Player -->
    <div id="lofiPlayer">
      <div class="lofi-title">LOFI MUSIC â™¬</div>
      <button id="lofiPrev" title="Previous Track">â—„</button>
      <button id="lofiPlay" title="Play">â–¶</button>
      <button id="lofiPause" title="Pause">âšâš</button>
      <button id="lofiNext" title="Next Track">â–º</button>
    </div>

    <!-- AI Chatbot -->
    <div id="fireBox" title="Ask AI Assistant">ðŸ§™</div>
    <div id="aiPopup">
      <iframe src="https://www.chatbase.co/chatbot-iframe/3dSdpryiYZlWipHUL8dNK" frameBorder="0"></iframe>
    </div>

    <!-- Achievement Overlay -->
    <div id="achievementOverlay">LEVEL UP!</div>

    <!-- Confirmation Dialog -->
    <div id="confirmationDialog" class="dialog-overlay">
         <div class="dialog-box">
             <h3>Confirm Action</h3>
            <p id="confirmationDialogText">Are you sure you want to proceed?</p>
             <div class="dialog-buttons">
                <button id="confirmBtn">YES</button>
                <button id="cancelBtn">NO</button>
            </div>
        </div>
    </div>

     <!-- Streak Shield Dialog -->
    <div id="streakShieldDialog" class="dialog-overlay">
        <div class="dialog-box">
            <h3><i class="fas fa-shield-alt"></i> Streak Shield</h3>
            <p>Protect your focus streak for 1 week! This powerful enchantment costs 800 XP.</p>
            <div class="dialog-buttons">
                <button id="streakShieldConfirmBtn">Buy (800 XP)</button>
                <button id="streakShieldCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

     <!-- Double Points Dialog -->
    <div id="doublePointsDialog" class="dialog-overlay">
        <div class="dialog-box">
             <h3><i class="fas fa-bolt"></i> Double XP Power-Up</h3>
            <p>Activate Double XP for 24 hours and supercharge your progress! Costs 800 XP.</p>
             <div class="dialog-buttons">
                <button id="doublePointsConfirmBtn">Activate (800 XP)</button>
                <button id="doublePointsCancelBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Task Deadline Dialog -->
    <div id="deadlineDialog" class="dialog-overlay">
         <div class="dialog-box">
            <h3><i class="fas fa-calendar-check"></i> Set Quest Deadline</h3>
            <p>Assign a deadline and difficulty to earn bonus XP upon completion!</p>
            <input type="date" id="deadlineDate" />
            <input type="time" id="deadlineTime" />
            <select id="taskDifficulty">
                <option value="50">Easy (+50 XP)</option>
                <option value="100">Medium (+100 XP)</option>
                <option value="200">Hard (+200 XP)</option>
                <option value="300">Very Hard (+300 XP)</option>
            </select>
            <div class="dialog-buttons">
                <button id="deadlineConfirmBtn">Set Deadline</button>
                <button id="deadlineCancelBtn">Cancel</button>
            </div>
         </div>
    </div>

    <!-- Session Complete Dialog -->
    <div id="sessionCompleteDialog" class="dialog-overlay">
        <div class="dialog-box">
            <h3><i class="fas fa-check-circle"></i> Session Complete!</h3>
            <p>Excellent focus! You've conquered this session.</p>
            <p>Embark on another quest immediately for a +100 XP bonus?</p>
            <div class="dialog-buttons">
                <button id="sessionContinueBtn">Continue (+100 XP)</button>
                <button id="sessionEndBtn">End Session</button>
            </div>
        </div>
    </div>

     <!-- Mystery Box Popup -->
    <div id="mysteryBoxPopup" class="dialog-overlay">
        <div class="dialog-box">
            <h3><i class="fas fa-gift"></i> Focus Mystery Box</h3>
            <p id="mysteryRewardText">You've earned a mystery box! Click to reveal your reward!</p>
             <div class="dialog-buttons">
                <button id="openMysteryBox">Open Box</button>
                <!-- Add a close button maybe? -->
                 <button id="closeMysteryBoxBtn" style="background: var(--bg-light);">Later</button>
            </div>
        </div>
    </div>

     <!-- Audio Tracks Store -->
    <div id="audioTracksStore" class="dialog-overlay">
         <div class="dialog-box">
            <h3><i class="fas fa-store"></i> Audio Tracks Store</h3>
            <p>Unlock exclusive Lo-Fi tracks with your hard-earned XP!</p>
            <div id="audioTracksList">
                <!-- Track items added dynamically -->
            </div>
             <div class="dialog-buttons" style="margin-top: 20px;">
                <button id="closeAudioStore">Close Store</button>
            </div>
         </div>
    </div>

    <!-- PDF Viewer Popup -->
    <div id="pdfViewer" class="dialog-overlay">
        <div class="dialog-box">
            <h3><i class="fas fa-file-pdf"></i> PDF Viewer</h3>
            <input type="file" id="pdfInput" accept=".pdf" />
            <div id="pdfFrameContainer">
                 <iframe id="pdfFrame"></iframe>
            </div>
            <div class="dialog-buttons">
                <button onclick="togglePDFViewer()" style="background: #ff4444;">Close</button>
            </div>
         </div>
    </div>


    <!-- Quiet Pomodoro Overlay -->
    <div id="pomodoroOverlay" class="dialog-overlay">
      <div id="pomodoroContainer">
        <h3><i class="fas fa-brain"></i> QUIET POMODORO</h3>
        <p>Engage in deep work. Earn 1 XP for every minute focused.</p>
        <div id="pomodoroTimer">60:00</div>
        <div id="pomodoroStatus">Ready to begin</div>
        <div id="pomodoroControls">
          <button id="pomodoroStartBtn">START</button>
          <button id="pomodoroResetBtn">RESET</button>
          <button id="pomodoroCloseBtn">CLOSE</button>
        </div>
      </div>
    </div>


    <!-- Audio Elements -->
    <audio id="focusAudio" preload="none" src="https://the-chosen-one-o5.github.io/UltraFocusModeYT/focus.mp3"></audio>
    <audio id="lofiAudio" preload="metadata" loop></audio> <!-- Preload metadata -->
    <audio id="pomodoroCompleteAudio" preload="none" src="https://www.dropbox.com/scl/fi/ihrcv1s3o4m4abhn6oa5z/level-up-4-243762.mp3?rlkey=qkaf4zrhipxtxpu51an0do45r&st=boipxpb5&dl=1"></audio>
    <audio id="levelUpAudio" preload="none" src="https://www.dropbox.com/scl/fi/ykeun00q1t03kzpeow819/music-to-make-your-brain-shut-up-a-dark-academia-playlist-4.mp3?rlkey=3hnw2vk2ck0yjnr9oekk2xqld&st=hh77z1k0&dl=1"></audio> <!-- Example level up sound -->
    <audio id="achievementAudio" preload="none" src="https://www.dropbox.com/scl/fi/pe09xx1c680gzymsa2gdf/NEOTIC-Calm-Your-Anxiety.mp3?rlkey=2hp7su9j541mpcdkw4ccavx58&st=yles17dd&dl=1"></audio> <!-- Example general achievement sound -->


  </div> <!-- End Game Container -->


  <script>
    ;(() => {
      // --- State Variables ---
      let currentView = 'landingPage'; // Tracks the current visible page
      let player; // YouTube Player object
      let videoIds = []; // Array of video IDs for the current session
      let currentVideoIndex = 0; // Index of the currently playing video
      let isFocusModeActive = false; // Is a YouTube session running?
      let countdownInterval; // Interval ID for the focus/break timer
      let distractionCount = 0; // Count for the current session (if needed)
      let points = 0; // User's XP
      let isSignedIn = false; // User login status
      let currentUser = null; // Username of the logged-in user
      const focusDuration = 50 * 60 * 1000; // 50 minutes
      const firstBreakDuration = 15 * 60 * 1000; // 15 minutes
      const secondBreakDuration = 10 * 60 * 1000; // 10 minutes
      let timerMode = "Focus Time"; // Current timer phase
      let timerRemaining = focusDuration / 1000; // Time left in seconds
      let completedVideos = new Set(); // IDs of videos watched in the session
      let allVideosCompleted = false; // Flag if all videos in the list are done
      let totalFocusTime = 0; // Lifetime focus time in seconds
      let totalDistractions = 0; // Lifetime distraction count
      let totalVideosWatched = 0; // Lifetime videos watched count
      let playlists = []; // User's saved playlists [{ name: "...", videoIds: [...] }]
      let tasks = []; // User's to-do list [{ text: "...", completed: false, deadline: timestamp, points: num, deadlineChecked: bool }]
      let previousPoints = 0; // Points before the last update (for level-up check)
      let streakDays = 0; // Current focus streak
      let lastFocusDate = null; // Date string of the last focus session start
      let isYouTubeAPILoaded = false; // Flag for YouTube API status
      let lofiAudio; // Lo-fi audio element
      let currentLofiIndex = 0; // Index for the lofi track array
      let currentTaskForDeadline = null; // Reference to the task element when setting deadline
      let isSidebarOpen = false; // State of the main sidebar
       let isVideoSidebarOpen = false; // State of the video thumbnail sidebar

      // Pomodoro Variables
      let pomodoroInterval;
      let pomodoroTimeRemaining = 60 * 60; // 60 minutes default
      let isPomodoroActive = false;

      // Reminder Variables (Not fully implemented in UI, logic kept)
      let reminderInterval;
      let timeOnInputForm = 0; // Kept conceptually, might repurpose for Home page time
      const reminderIntervalTime = 20 * 60 * 1000; // 20 minutes
      const reminderThreshold = 20 * 60 * 1000; // 20 minutes

      // Power-Up & Mystery Box Variables
      let mysteryBoxCount = 0;
      let activePowerUps = {
        doublePoints: { active: false, expiry: null },
        streakShield: { active: false, used: false, expiry: null },
      };
      const STREAK_SHIELD_COST = 800;
      const STREAK_SHIELD_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days
      const DOUBLE_POINTS_COST = 800;
      const DOUBLE_POINTS_DURATION = 24 * 60 * 60 * 1000; // 24 hours
      const MYSTERY_BOX_STREAK_INTERVAL = 14; // Earn box every 14 days
      const mysteryBoxRewards = [
        { type: "points", value: () => Math.floor(Math.random() * 451) + 50, message: (val) => `+${val} XP` },
        { type: "doublePoints", value: DOUBLE_POINTS_DURATION, message: () => "Double XP for 24 Hours" },
        { type: "streakShield", value: STREAK_SHIELD_DURATION, message: () => "1-Week Streak Shield" }, // Changed to 1 week shield
        { type: "lofiTrack", message: () => "Unlock a Random Lofi Track" }, // New reward type
      ];

       // Audio Tracks Configuration
       const baseLofiSongs = [ // Always available
          "https://www.dropbox.com/scl/fi/7qrgbk6vpej7x0ih7vev2/1-6_XRwBX7NX-1.mp3?rlkey=m3gntnys7az2hoq0iokkajucj&st=bmrhzjy8&dl=1",
          "https://www.dropbox.com/scl/fi/ykeun00q1t03kzpeow819/music-to-make-your-brain-shut-up-a-dark-academia-playlist-4.mp3?rlkey=3hnw2vk2ck0yjnr9oekk2xqld&st=hh77z1k0&dl=1",
          "https://www.dropbox.com/scl/fi/pe09xx1c680gzymsa2gdf/NEOTIC-Calm-Your-Anxiety.mp3?rlkey=2hp7su9j541mpcdkw4ccavx58&st=yles17dd&dl=1",
          "https://www.dropbox.com/scl/fi/lb5f47widcz8mwhg79jiz/Kate-Grove-SKYRIM-THEME-skyrim-elderscrolls-ocarina.mp3?rlkey=f8kpm1ipyowc1wv998myu06us&st=bm9qmodf&dl=1",
        ];
        let premiumLofiTracks = [ // Unlockable
            { id: "track1", name: "Celestial Dreams", url: "https://www.dropbox.com/scl/fi/3xkks3j4tcmnloz46o03m/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=6w97eurecqph68b8f2r7zn5pf&st=epeucz72&dl=1", unlocked: false, cost: 150 },
            { id: "track2", name: "Midnight Study", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=ui3kdsq5&dl=1", unlocked: false, cost: 150 },
            { id: "track3", name: "Rainy Day Focus", url: "https://www.dropbox.com/scl/fi/iaouozc1osse7h5ea9lon/thunder-chosic.com.mp3?rlkey=o7u0rarnh4kk657qhmcgyiolz&st=2r9f625j&dl=1", unlocked: false, cost: 200 },
            { id: "track4", name: "Epic Concentration", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=cq8j3dij&dl=1", unlocked: false, cost: 250 },
            { id: "track5", name: "Zen Garden", url: "https://www.dropbox.com/scl/fi/8wf64nv0rwubt7hbs5x20/Kurate-Music-Best-of-Gibran-Alcocer-Beautiful-Piano-Mix.mp3?rlkey=i776feuxag0ebullqe0kjo0gp&st=bb3uyo3h&dl=1", unlocked: false, cost: 100 },
            { id: "track6", name: "Hopecore", url: "https://www.dropbox.com/scl/fi/p303xk68pvu8sfrmtwzj2/rhawn-there-is-hopecore.mp3?rlkey=m6tva7g4dsva39ii1l0e8tnu0&st=6z218pii&dl=1", unlocked: false, cost: 120 },
            { id: "track7", name: "Nostalgia", url: "https://www.dropbox.com/scl/fi/c1iy5yjmf3d57jrb1aokc/KestrelTapes-what-nostalgia-sounds-like...mp3?rlkey=qcdj1vpdnzwdb03fxp0vk0661&st=fyqrl6ge&dl=1", unlocked: false, cost: 120 },
            { id: "track8", name: "Stranger Vibes", url: "https://www.dropbox.com/scl/fi/evhrjdri6a9n9bk05qhcu/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=lauo50rz3indg5n3to5gfks1y&st=gcqmonsf&dl=1", unlocked: false, cost: 180 },
        ];
        let availableLofiSongs = [...baseLofiSongs]; // Combined list for playback

      // Achievement Levels Configuration
      const achievementLevels = [
        { points: 0, level: "Mortal", color: "white" },
        { points: 1000, level: "Soldier", color: "#4169E1" }, // Royal Blue
        { points: 2000, level: "Knight", color: "#e0e0ff", glow: true }, // Text color
        { points: 3000, level: "KING", color: "#ff8c00", glow: true }, // Dark Orange
        { points: 4000, level: "GIGACHAD", color: "#ff4500", glow: true }, // Orange Red
        { points: 5000, level: "Demigod", color: "gold", glow: true },
        { points: 6000, level: "Titan", color: "gold", glow: true, box: true },
        { points: 7000, level: "Immortal", color: "gold", glow: true, box: true, boxGlow: true },
        { points: 8000, level: "Celestial", color: "#00BFFF", glow: true, box: true, boxGlow: true }, // Deep Sky Blue
        { points: 9000, level: "Divine", color: "rainbow" },
        { points: 10000, level: "Omnipotent", color: "rainbow", glow: true },
      ];

      // Motivational Quotes
       const motivationalQuotes = [
           "The only way to do great work is to love what you do. - Steve Jobs",
           "Success is not final, failure is not fatal: It is the courage to continue that counts. - Winston Churchill",
           "Believe you can and you're halfway there. - Theodore Roosevelt",
           "The expert in anything was once a beginner.",
           "Focus on progress, not perfection.",
           "The secret of getting ahead is getting started. - Mark Twain",
           "Donâ€™t watch the clock; do what it does. Keep going. - Sam Levenson",
           "You are stronger than you think.",
           "Every accomplishment starts with the decision to try.",
           "Push yourself, because no one else is going to do it for you.",
       ];


      // --- DOM Element References ---
      // (Get references to frequently used elements after DOMContentLoaded)
      let topNavBar, landingPage, signinForm, homePage, youtubeLecturePage, profilePage, focusStatsPage;
      let playerContainer, playerDiv, timerDisplay, timerText, progressBar, progressFill, pointsDisplay;
      let achievementLevelDiv, lofiPlayer, aiPopup, fireBox, videoSidebar, videoThumbnailList;
      let usernameInput, passwordInput, homeUsernameSpan, dateTimeDisplaySpan, focusStatusSpan;
      let playlistSelect, urlInputsContainer, playlistNameInput;
      let todoListPopup, tasksContainer;
      let confirmationDialog, streakShieldDialog, doublePointsDialog, deadlineDialog, sessionCompleteDialog, mysteryBoxPopup, audioTracksStore, pdfViewer, pomodoroOverlay;
      let gameSidebar, sidebarTrigger;
      let navClockTime, navClockPeriod, topNavStreakBtn, videoSidebarToggleBtn;


      // --- Core Functions ---

      /**
       * Switches the visible page view.
       * @param {string} viewId - The ID of the page view to show.
       */
      function showView(viewId) {
        console.log("Switching view to:", viewId);
        const views = document.querySelectorAll('.page-view');
        views.forEach(view => {
          view.style.display = 'none';
        });

        const targetView = document.getElementById(viewId);
        if (targetView) {
          targetView.style.display = 'flex'; // Use flex for centering etc.
          currentView = viewId;

          // Control visibility of shared elements based on view
          const isHomePage = viewId === 'homePage';
          const isYoutubePage = viewId === 'youtubeLecturePage';
          const showLofiAndAI = isHomePage || isYoutubePage;
          const showTopNav = isHomePage || isYoutubePage || viewId === 'profilePage' || viewId === 'focusStatsPage'; // Show on more pages

          if(topNavBar) topNavBar.style.display = showTopNav ? 'flex' : 'none';
          if(lofiPlayer) lofiPlayer.style.display = showLofiAndAI ? 'block' : 'none';
          if(fireBox) fireBox.style.display = showLofiAndAI ? 'flex' : 'none';

           // If switching away from YouTube view, maybe pause video?
           if (!isYoutubePage && player && typeof player.pauseVideo === 'function') {
               // player.pauseVideo(); // Optional: Pause if navigating away
           }

          // Specific setup for certain views
          if (isHomePage) {
            updateHomePageInfo();
            displayRandomMotivation();
             startReminderTimer(); // Restart reminder if going to home
             if (player && typeof player.destroy === 'function' && !isFocusModeActive) { // Clean up player if focus ended
                  // player.destroy(); player = null; // Be careful with this, might break returning
             }
          } else {
               stopReminderTimer(); // Stop reminder if leaving home
          }

          if(isYoutubePage && isFocusModeActive && videoIds.length > 0) {
              // Ensure timer display is visible if focus is active
              if(timerDisplay) timerDisplay.style.display = 'block';
          } else if (!isYoutubePage) {
              // Hide timer if not on youtube page
              if(timerDisplay) timerDisplay.style.display = 'none';
          }


          if (viewId === 'profilePage') displayProfileInfo();
          if (viewId === 'focusStatsPage') displayFocusStatsInfo();

           // Close sidebar if open when changing view
           closeSidebar();


        } else {
          console.error("View not found:", viewId);
          // Show landing page as a fallback
          if(landingPage) landingPage.style.display = 'flex';
          currentView = 'landingPage';
          if(topNavBar) topNavBar.style.display = 'none'; // Hide nav on fallback
        }
        saveState(); // Save the current view
      }

       /**
        * Updates the dynamic information on the Home page.
        */
       function updateHomePageInfo() {
            if (homeUsernameSpan) homeUsernameSpan.textContent = currentUser || "Hero";
            updateDateTimeDisplay(); // Update time/date
            updateFocusStatus(); // Update tasks/focus info
       }

       function updateDateTimeDisplay() {
           if (!dateTimeDisplaySpan) return;
           const now = new Date();
           const optionsDate = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
           // const optionsTime = { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true };
           dateTimeDisplaySpan.textContent = `${now.toLocaleDateString(undefined, optionsDate)}`;
           // No need for time here as it's in the top nav
       }

        function updateFocusStatus() {
            if (!focusStatusSpan) return;
            const incompleteTasks = tasks.filter(task => !task.completed).length;
            if (isFocusModeActive) {
                 focusStatusSpan.textContent = `Currently in ${timerMode}. Keep up the great work!`;
                 focusStatusSpan.style.color = 'var(--success)';
            } else if (incompleteTasks > 0) {
                 focusStatusSpan.textContent = `You have ${incompleteTasks} quest${incompleteTasks > 1 ? 's' : ''} remaining today!`;
                 focusStatusSpan.style.color = 'var(--accent-alt)';
            } else if (tasks.length > 0) {
                focusStatusSpan.textContent = "All quests completed for today! Well done!";
                 focusStatusSpan.style.color = 'var(--success)';
            }
            else {
                 focusStatusSpan.textContent = "Ready to add some quests and start focusing?";
                  focusStatusSpan.style.color = 'var(--text-dim)';
            }
        }

        function displayRandomMotivation() {
            const quoteElement = document.getElementById('motivationQuote');
            if (quoteElement) {
                const randomIndex = Math.floor(Math.random() * motivationalQuotes.length);
                quoteElement.textContent = motivationalQuotes[randomIndex];
            }
        }


        /**
         * Updates the user profile information display.
         */
        function displayProfileInfo() {
             const usernameEl = document.getElementById('profileUsername');
             const levelEl = document.getElementById('profileLevel');
             const xpEl = document.getElementById('profileXP');
             const streakEl = document.getElementById('profileStreak');

            if(usernameEl) usernameEl.textContent = currentUser || 'Guest';
            if(levelEl) {
                const levelInfo = getAchievementLevel(points);
                levelEl.textContent = levelInfo.level;
                levelEl.style.color = levelInfo.color === 'rainbow' ? '' : levelInfo.color; // Apply color directly or let class handle rainbow
                if (levelInfo.color === 'rainbow') levelEl.classList.add('rainbow');
                else levelEl.classList.remove('rainbow');
            }
            if(xpEl) xpEl.textContent = points;
            if(streakEl) streakEl.textContent = `${streakDays} day${streakDays === 1 ? '' : 's'}`;
        }

        /**
         * Updates the focus statistics display.
         */
        function displayFocusStatsInfo() {
             const focusTimeEl = document.getElementById('statsTotalFocusTime');
             const distractionsEl = document.getElementById('statsTotalDistractions');
             const videosEl = document.getElementById('statsTotalVideosWatched');
             const streakEl = document.getElementById('statsCurrentStreak');

             if(focusTimeEl) focusTimeEl.textContent = `${Math.floor(totalFocusTime / 60)} min`;
             if(distractionsEl) distractionsEl.textContent = totalDistractions;
             if(videosEl) videosEl.textContent = totalVideosWatched;
             if(streakEl) streakEl.textContent = `${streakDays} day${streakDays === 1 ? '' : 's'}`;

             // TODO: Implement calendar rendering based on historical data
             const calendarGrid = document.getElementById('calendarGrid');
            if(calendarGrid) {
                // Placeholder - replace with actual calendar generation
                calendarGrid.innerHTML = '<i>Focus activity calendar rendering is planned for a future update.</i>';
            }
        }

      /**
       * Initializes the audio elements.
       */
      function initAudio() {
        lofiAudio = document.getElementById("lofiAudio");
        updateAvailableLofiTracks(); // Update based on unlocked state initially
        if (lofiAudio && availableLofiSongs.length > 0) {
            currentLofiIndex = Math.floor(Math.random() * availableLofiSongs.length); // Start random
            lofiAudio.src = availableLofiSongs[currentLofiIndex];
        } else {
            console.warn("Lofi audio element or songs not found/available.");
        }
         // Preload other sounds if desired (might increase initial load time)
        // document.getElementById('levelUpAudio').load();
        // document.getElementById('achievementAudio').load();
        // document.getElementById('focusAudio').load();
        // document.getElementById('pomodoroCompleteAudio').load();
      }

      /**
        * Updates the list of available Lo-fi tracks based on unlocked premium tracks.
        */
       function updateAvailableLofiTracks() {
           const unlockedPremiumUrls = premiumLofiTracks
               .filter(track => track.unlocked)
               .map(track => track.url);
           availableLofiSongs = [...new Set([...baseLofiSongs, ...unlockedPremiumUrls])]; // Combine and remove duplicates

           // If the current track is no longer available (e.g., relocked - unlikely but possible), reset index
            if (lofiAudio && !availableLofiSongs.includes(lofiAudio.src)) {
                currentLofiIndex = 0;
                if (availableLofiSongs.length > 0) {
                    lofiAudio.src = availableLofiSongs[currentLofiIndex];
                } else {
                    lofiAudio.removeAttribute('src'); // No songs available
                }
           }
           console.log("Available Lofi Tracks:", availableLofiSongs.length);
       }


      /**
       * Calculates the current achievement level based on points.
       * @param {number} currentPoints - The user's current points.
       * @returns {object} The level object { points, level, color, glow, box, boxGlow }.
       */
      function getAchievementLevel(currentPoints) {
        let currentLevel = achievementLevels[0];
        for (const level of achievementLevels) {
          if (currentPoints >= level.points) {
            currentLevel = level;
          } else {
            break;
          }
        }
        return currentLevel;
      }

      /**
       * Updates the visual display of the achievement level.
       */
      function updateAchievementLevel() {
        if (!achievementLevelDiv) return;

        const level = getAchievementLevel(points);
        achievementLevelDiv.textContent = level.level;

        // Reset classes/styles
        achievementLevelDiv.className = 'level-default'; // Base class if needed
        achievementLevelDiv.style.cssText = ''; // Clear inline styles
        achievementLevelDiv.classList.remove('rainbow', 'level-glow', 'level-box-glow');
         achievementLevelDiv.style.border = '2px solid var(--secondary)'; // Default border

        achievementLevelDiv.style.color = level.color === 'rainbow' ? '' : level.color; // Apply color unless rainbow

        if (level.glow) achievementLevelDiv.classList.add('level-glow');
        if (level.box) achievementLevelDiv.style.border = '2px solid var(--gold)';
        if (level.boxGlow) achievementLevelDiv.classList.add('level-box-glow');
        if (level.color === 'rainbow') {
             achievementLevelDiv.classList.add('rainbow');
             achievementLevelDiv.style.border = '2px solid transparent'; // Hide border for rainbow
        }

        // Update sidebar/profile as well
        const profileLevelEl = document.getElementById('profileLevel');
        if (profileLevelEl && currentView === 'profilePage') displayProfileInfo();
      }


       /**
        * Plays a sound effect.
        * @param {string} soundId - The ID of the audio element.
        */
       function playSound(soundId) {
           const audio = document.getElementById(soundId);
           if (audio) {
               audio.currentTime = 0; // Rewind to start
               audio.play().catch(err => console.warn(`Audio play error (${soundId}):`, err.message)); // Use warn for non-critical sounds
           }
       }


      /**
       * Shows the achievement overlay with a message.
       * @param {string} message - The message to display.
       */
      function showAchievementOverlay(message) {
        const overlay = document.getElementById("achievementOverlay");
        if (!overlay) return;

        overlay.textContent = message;
        overlay.style.display = "flex";
        playSound('levelUpAudio'); // Play level up sound

        // Add a class for animation (optional)
        overlay.classList.add('animate-fade-in');

        setTimeout(() => {
             overlay.classList.remove('animate-fade-in'); // Remove class for next time
             overlay.style.display = "none";
        }, 5000); // Display for 5 seconds
      }


      /**
       * Updates the clock display in the top navigation bar.
       */
      function updateClock() {
        if (!navClockTime || !navClockPeriod) return; // Check if nav elements exist

        const now = new Date();
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const seconds = now.getSeconds().toString().padStart(2, "0");
        const period = hours >= 12 ? "PM" : "AM";
        hours = hours % 12 || 12; // Convert to 12-hour format
        hours = hours.toString().padStart(2, "0");

        navClockTime.textContent = `${hours}:${minutes}:${seconds}`;
        navClockPeriod.textContent = period;

         // Update date on home page if visible
         if (currentView === 'homePage') {
             updateDateTimeDisplay();
         }
      }

      // --- Lo-Fi Player Functions ---

      function playLofi() {
        if (!lofiAudio || availableLofiSongs.length === 0) return;
        lofiAudio.play().catch((err) => console.error("Lofi play error:", err));
         // Add visual feedback (e.g., change play button icon)
        document.getElementById('lofiPlay').style.display = 'none';
        document.getElementById('lofiPause').style.display = 'inline-block';
      }

      function pauseLofi() {
        if (!lofiAudio) return;
        lofiAudio.pause();
        document.getElementById('lofiPlay').style.display = 'inline-block';
        document.getElementById('lofiPause').style.display = 'none';
      }

      function nextLofi() {
        if (!lofiAudio || availableLofiSongs.length <= 1) return; // Don't change if only one song
        currentLofiIndex = (currentLofiIndex + 1) % availableLofiSongs.length;
        lofiAudio.src = availableLofiSongs[currentLofiIndex];
        playLofi();
      }
        function prevLofi() {
        if (!lofiAudio || availableLofiSongs.length <= 1) return;
        currentLofiIndex = (currentLofiIndex - 1 + availableLofiSongs.length) % availableLofiSongs.length;
        lofiAudio.src = availableLofiSongs[currentLofiIndex];
        playLofi();
      }


      // --- Streak & Points Functions ---

       /**
        * Updates the streak counter and saves the date. Called when focus starts.
        */
       function updateStreak() {
            if (!isSignedIn) return; // Only track for logged-in users

            const today = new Date().toDateString();

            // Check if last focus was yesterday
            if (lastFocusDate) {
                 const last = new Date(lastFocusDate);
                 const todayDate = new Date(today);
                 const diffTime = todayDate - last;
                 const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays === 1) {
                    streakDays++;
                    checkMysteryBoxMilestone(); // Check if a box is earned
                     console.log("Streak continued:", streakDays);
                } else if (diffDays > 1) {
                    // Streak broken? Check for shield
                    if (activePowerUps.streakShield.active && Date.now() < activePowerUps.streakShield.expiry && !activePowerUps.streakShield.used) {
                        // Shield active and not used yet for this break
                         activePowerUps.streakShield.used = true; // Mark shield as used for this break period
                         // Streak continues (doesn't increment, just doesn't reset)
                         showConfirmation("Streak Shield Activated!", "Your Streak Shield protected your focus streak from breaking!", false); // Info only
                        console.log("Streak shield used.");
                    } else {
                         console.log("Streak broken.");
                         streakDays = 1; // Reset streak to 1 for today's session
                         activePowerUps.streakShield.used = false; // Reset shield usage flag if streak resets
                    }
                } else if (diffDays === 0) {
                    // Multiple sessions on the same day - streak doesn't change
                    console.log("Same day session, streak:", streakDays);
                } else {
                     // This case (diffDays < 0) shouldn't happen with dates
                     console.warn("Date difference anomaly:", diffDays);
                     streakDays = 1; // Reset as a precaution
                }
            } else {
                // First focus session ever or after a long break
                streakDays = 1;
                 console.log("First streak day.");
            }

            lastFocusDate = today; // Update the last focus date to today

           updateStreakDisplay();
           saveState(); // Save streak and date
       }

        /** Updates the streak button UI */
        function updateStreakDisplay() {
             if (!topNavStreakBtn) return;
             const tooltipText = `${streakDays} day focus streak`;
             topNavStreakBtn.title = tooltipText; // Update tooltip

            // Optional: Add visual indication like pulsing for high streaks
             if (streakDays >= 7) {
                 topNavStreakBtn.classList.add('glowing-streak'); // Add a CSS class for glow
             } else {
                 topNavStreakBtn.classList.remove('glowing-streak');
             }

             // Update profile/stats page if visible
             const profileStreakEl = document.getElementById('profileStreak');
             if (profileStreakEl && currentView === 'profilePage') profileStreakEl.textContent = `${streakDays} day${streakDays === 1 ? '' : 's'}`;
             const statsStreakEl = document.getElementById('statsCurrentStreak');
              if (statsStreakEl && currentView === 'focusStatsPage') statsStreakEl.textContent = `${streakDays} day${streakDays === 1 ? '' : 's'}`;
        }


        /** Checks if the user reached a streak milestone for a mystery box */
        function checkMysteryBoxMilestone() {
            if (streakDays > 0 && streakDays % MYSTERY_BOX_STREAK_INTERVAL === 0) {
                mysteryBoxCount++;
                 showMysteryBoxPopup(); // Show the popup immediately
                 playSound('achievementAudio'); // Play a sound
                 saveState();
            }
        }

        /** Shows the Mystery Box popup */
        function showMysteryBoxPopup() {
            const popup = document.getElementById("mysteryBoxPopup");
            const rewardText = document.getElementById("mysteryRewardText");
            const openButton = document.getElementById("openMysteryBox");
            if (!popup || !rewardText || !openButton) return;

             if (mysteryBoxCount > 0) {
                 rewardText.textContent = `You have ${mysteryBoxCount} Focus Mystery Box${mysteryBoxCount > 1 ? 'es' : ''}! Open one?`;
                 openButton.disabled = false;
                 openButton.textContent = "Open Box";
                 popup.style.display = "flex";
             } else {
                  // Optionally show a message if they try to open with none, though button should be disabled
                  rewardText.textContent = "No Mystery Boxes available right now. Keep focusing!";
                  openButton.disabled = true;
                  openButton.textContent = "No Boxes";
                  // Don't automatically show if none available unless triggered by button
             }
        }

        /** Handles opening the mystery box */
        function openMysteryBox() {
            if (mysteryBoxCount <= 0) return;

            const popup = document.getElementById("mysteryBoxPopup");
            const rewardText = document.getElementById("mysteryRewardText");
            const openButton = document.getElementById("openMysteryBox");
            if (!popup || !rewardText || !openButton) return;

            mysteryBoxCount--; // Consume one box

            // Select a random reward
             // Weight rewards? Points more common?
            const rewardIndex = Math.floor(Math.random() * mysteryBoxRewards.length);
            const reward = mysteryBoxRewards[rewardIndex];

            let rewardValue = null;
            let rewardMessageText = "";

            switch (reward.type) {
                case "points":
                    rewardValue = reward.value(); // Generate random points
                    points += rewardValue; // Add points directly (power-ups don't apply to box rewards)
                    rewardMessageText = `You found ${reward.message(rewardValue)}!`;
                    break;
                case "doublePoints":
                    if (!activePowerUps.doublePoints.active || (activePowerUps.doublePoints.expiry && Date.now() > activePowerUps.doublePoints.expiry)) {
                         activePowerUps.doublePoints.active = true;
                         activePowerUps.doublePoints.expiry = Date.now() + DOUBLE_POINTS_DURATION;
                         rewardMessageText = `Power-Up Activated: ${reward.message()}!`;
                         // Set timeout to deactivate
                         setTimeout(() => {
                             activePowerUps.doublePoints.active = false;
                             activePowerUps.doublePoints.expiry = null;
                             saveState();
                             showConfirmation("Power-Up Expired", "Your Double XP power-up has ended.", false);
                             console.log("Double Points expired");
                         }, DOUBLE_POINTS_DURATION);
                     } else {
                        // Already active, give points instead?
                         rewardValue = 200; // Consolation points
                         points += rewardValue;
                         rewardMessageText = `Double XP is already active! You get +${rewardValue} XP instead!`;
                     }
                    break;
                case "streakShield":
                     if (!activePowerUps.streakShield.active || (activePowerUps.streakShield.expiry && Date.now() > activePowerUps.streakShield.expiry)) {
                         activePowerUps.streakShield.active = true;
                         activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION; // Use shield duration constant
                         activePowerUps.streakShield.used = false; // Reset used flag
                         rewardMessageText = `Power-Up Activated: ${reward.message()}!`;
                          // Set timeout to deactivate
                         setTimeout(() => {
                             activePowerUps.streakShield.active = false;
                             activePowerUps.streakShield.expiry = null;
                             saveState();
                             showConfirmation("Power-Up Expired", "Your Streak Shield has faded.", false);
                             console.log("Streak Shield expired");
                         }, STREAK_SHIELD_DURATION);
                     } else {
                         // Already active, give points instead?
                         rewardValue = 200; // Consolation points
                         points += rewardValue;
                         rewardMessageText = `Streak Shield is already active! You get +${rewardValue} XP instead!`;
                     }
                    break;
                 case "lofiTrack":
                    const lockedTracks = premiumLofiTracks.filter(t => !t.unlocked);
                    if (lockedTracks.length > 0) {
                        const trackToUnlock = lockedTracks[Math.floor(Math.random() * lockedTracks.length)];
                         trackToUnlock.unlocked = true;
                         updateAvailableLofiTracks(); // Update playable list
                         rewardMessageText = `New Audio Unlocked: "${trackToUnlock.name}"!`;
                         playSound('achievementAudio');
                    } else {
                        // All tracks unlocked, give points
                        rewardValue = 100;
                        points += rewardValue;
                        rewardMessageText = `You've unlocked all audio tracks! You get +${rewardValue} XP!`;
                    }
                    break;
            }

            // Update display
            rewardText.textContent = rewardMessageText;
             if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
            openButton.textContent = "Awesome!"; // Change button text after opening

            saveState(); // Save changes (points, powerups, box count, tracks)
            checkLevelUp(); // Check if points reward caused level up

            // Disable button temporarily or change its action
            openButton.disabled = true;
             setTimeout(() => {
                 if (mysteryBoxCount > 0) {
                     // Still have boxes left, reset popup for next open
                     showMysteryBoxPopup();
                 } else {
                     // No boxes left, keep button disabled or hide popup
                      openButton.textContent = "No More Boxes";
                      // Optionally auto-close after a delay: setTimeout(() => popup.style.display = 'none', 3000);
                 }
             }, 2500); // Reset after 2.5 seconds
        }

        /** Closes the mystery box popup */
        function closeMysteryBoxPopup() {
            const popup = document.getElementById("mysteryBoxPopup");
            if (popup) popup.style.display = "none";
        }


      /** Applies active power-ups to earned points.
       * @param {number} basePoints - The points earned before power-ups.
       * @returns {number} Points after applying power-ups.
      */
      function applyPowerUps(basePoints) {
        let finalPoints = basePoints;
        if (activePowerUps.doublePoints.active && Date.now() < activePowerUps.doublePoints.expiry) {
          finalPoints *= 2;
          console.log("Double points applied!");
        }
        return Math.floor(finalPoints); // Ensure integer points
      }

        /** Checks if the points crossed a level threshold and shows overlay */
        function checkLevelUp() {
            const oldLevel = getAchievementLevel(previousPoints);
            const newLevel = getAchievementLevel(points);

            if (newLevel.points > oldLevel.points) {
                 // LEVEL UP!
                 showAchievementOverlay(`LEVEL UP! REACHED ${newLevel.level.toUpperCase()}!`);
                 // Update level display immediately
                 updateAchievementLevel();
             }
            previousPoints = points; // Update previous points for next check
             // Update profile/stats immediately if visible
             if (currentView === 'profilePage') displayProfileInfo();
             if (currentView === 'focusStatsPage') displayFocusStatsInfo();
        }


      // --- Power-Up Store Functions ---

        function showStreakShieldDialog() {
            if (points < STREAK_SHIELD_COST) {
                showConfirmation("Insufficient XP", `You need ${STREAK_SHIELD_COST} XP to purchase the Streak Shield. You currently have ${points} XP.`, false);
                return;
            }
            if (activePowerUps.streakShield.active && Date.now() < activePowerUps.streakShield.expiry) {
                 showConfirmation("Already Active", "Your Streak Shield is already active!", false);
                 return;
            }
            const dialog = document.getElementById("streakShieldDialog");
            if (dialog) dialog.style.display = "flex";
        }

        function handleStreakShieldConfirmation(choice) {
            const dialog = document.getElementById("streakShieldDialog");
            if (dialog) dialog.style.display = "none";

            if (choice === "yes" && points >= STREAK_SHIELD_COST) {
                points -= STREAK_SHIELD_COST;
                activePowerUps.streakShield.active = true;
                 activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION;
                 activePowerUps.streakShield.used = false; // Ensure it starts as unused

                if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                 showConfirmation("Purchase Successful", "Streak Shield activated for 1 week!", false);
                 playSound('achievementAudio'); // Use a success sound
                saveState();

                // Set timeout to notify expiry (optional)
                 setTimeout(() => {
                     activePowerUps.streakShield.active = false;
                     activePowerUps.streakShield.expiry = null;
                     saveState();
                     // Notify user only if they are active?
                     if(isSignedIn) showConfirmation("Power-Up Expired", "Your Streak Shield has faded.", false);
                     console.log("Streak Shield expired naturally.");
                 }, STREAK_SHIELD_DURATION);
            }
        }


        function showDoublePointsDialog() {
             if (points < DOUBLE_POINTS_COST) {
                 showConfirmation("Insufficient XP", `You need ${DOUBLE_POINTS_COST} XP for the Double XP Power-Up. You have ${points} XP.`, false);
                 return;
             }
             if (activePowerUps.doublePoints.active && Date.now() < activePowerUps.doublePoints.expiry) {
                 showConfirmation("Already Active", "Double XP is already active!", false);
                 return;
            }
            const dialog = document.getElementById("doublePointsDialog");
            if (dialog) dialog.style.display = "flex";
        }

        function handleDoublePointsConfirmation(choice) {
            const dialog = document.getElementById("doublePointsDialog");
            if (dialog) dialog.style.display = "none";

            if (choice === "yes" && points >= DOUBLE_POINTS_COST) {
                points -= DOUBLE_POINTS_COST;
                activePowerUps.doublePoints.active = true;
                 activePowerUps.doublePoints.expiry = Date.now() + DOUBLE_POINTS_DURATION;

                if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                showConfirmation("Purchase Successful", "Double XP Power-Up activated for 24 hours!", false);
                 playSound('achievementAudio');
                saveState();

                // Set timeout for expiry
                 setTimeout(() => {
                     activePowerUps.doublePoints.active = false;
                     activePowerUps.doublePoints.expiry = null;
                     saveState();
                    if(isSignedIn) showConfirmation("Power-Up Expired", "Your Double XP power-up has ended.", false);
                     console.log("Double Points expired.");
                 }, DOUBLE_POINTS_DURATION);
            }
        }

        // --- Audio Store Functions ---

        function showAudioTracksStore() {
            const store = document.getElementById("audioTracksStore");
            const tracksList = document.getElementById("audioTracksList");
            if (!store || !tracksList) return;

            tracksList.innerHTML = ""; // Clear previous list

            // Sort tracks: locked first, maybe? Or by name?
            premiumLofiTracks.sort((a, b) => a.name.localeCompare(b.name));

            premiumLofiTracks.forEach(track => {
                const trackItem = document.createElement("div");
                trackItem.className = `audio-track-item ${track.unlocked ? 'unlocked' : 'locked'}`;

                const trackInfo = document.createElement("div");
                trackInfo.className = "track-info";

                const trackName = document.createElement("div");
                trackName.className = "track-name";
                trackName.textContent = track.name;

                 const trackCost = document.createElement("div");
                 trackCost.className = "track-cost";
                 trackCost.textContent = track.unlocked ? "Owned" : `${track.cost} XP`;


                trackInfo.appendChild(trackName);
                 trackInfo.appendChild(trackCost);


                const unlockBtn = document.createElement("button");
                unlockBtn.className = "unlock-track-btn";
                unlockBtn.dataset.trackId = track.id; // Store ID for click handler

                if (track.unlocked) {
                    unlockBtn.textContent = "âœ“ OWNED";
                    unlockBtn.disabled = true;
                     unlockBtn.classList.add('unlocked');
                } else {
                    unlockBtn.textContent = "UNLOCK";
                    unlockBtn.disabled = points < track.cost;
                    unlockBtn.onclick = () => unlockAudioTrack(track.id);
                }

                trackItem.appendChild(trackInfo);
                trackItem.appendChild(unlockBtn);
                tracksList.appendChild(trackItem);
            });

            store.style.display = "flex";
        }

        function closeAudioTracksStore() {
            const store = document.getElementById("audioTracksStore");
            if (store) store.style.display = "none";
        }

        function unlockAudioTrack(trackId) {
            const track = premiumLofiTracks.find(t => t.id === trackId);
            if (!track || track.unlocked || points < track.cost) return;

            // Deduct points and unlock
            points -= track.cost;
            track.unlocked = true;

            updateAvailableLofiTracks(); // Update the available song list

            // Update UI
            if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
            showConfirmation("Track Unlocked!", `Successfully unlocked "${track.name}"! It's now available in the Lo-fi player.`, false);
             playSound('achievementAudio');

            // Refresh the store display
            showAudioTracksStore();
            saveState(); // Save points and track unlock status
            checkLevelUp();
        }


      // --- Pomodoro Functions ---

        function showPomodoroOverlay() {
            // Reset timer state before showing
            clearInterval(pomodoroInterval);
            isPomodoroActive = false;
            pomodoroTimeRemaining = 60 * 60; // Reset to 60 minutes
            updatePomodoroDisplay();
            const statusEl = document.getElementById("pomodoroStatus");
            if (statusEl) statusEl.textContent = "Ready to begin";
             // Enable start, disable reset initially?
             document.getElementById('pomodoroStartBtn').disabled = false;
             document.getElementById('pomodoroResetBtn').disabled = true;


            const overlay = document.getElementById("pomodoroOverlay");
            if (overlay) overlay.style.display = "flex";
        }

        function startPomodoro() {
            if (isPomodoroActive) return;
            isPomodoroActive = true;

            const statusEl = document.getElementById("pomodoroStatus");
            if (statusEl) statusEl.textContent = "Focus session in progress...";

             // Disable start, enable reset
             document.getElementById('pomodoroStartBtn').disabled = true;
             document.getElementById('pomodoroResetBtn').disabled = false;

            pomodoroInterval = setInterval(() => {
                pomodoroTimeRemaining--;
                updatePomodoroDisplay();

                 // Award point every minute (60 seconds)
                 if (pomodoroTimeRemaining % 60 === 0 && pomodoroTimeRemaining > 0) {
                     const earned = applyPowerUps(1); // 1 point per minute, check powerup
                     points += earned;
                     if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                     // Maybe update stats page data too?
                 }


                if (pomodoroTimeRemaining <= 0) {
                    completePomodoroSession();
                }
            }, 1000);
        }

        function resetPomodoro() {
            clearInterval(pomodoroInterval);
            isPomodoroActive = false;
            pomodoroTimeRemaining = 60 * 60; // Reset to 60 minutes
            updatePomodoroDisplay();
            const statusEl = document.getElementById("pomodoroStatus");
            if (statusEl) statusEl.textContent = "Timer reset";
             // Enable start, disable reset
             document.getElementById('pomodoroStartBtn').disabled = false;
             document.getElementById('pomodoroResetBtn').disabled = true;
        }

        function closePomodoroOverlay() {
            const overlay = document.getElementById("pomodoroOverlay");
            if (!overlay) return;

            if (isPomodoroActive) {
                // Ask for confirmation if running
                showConfirmation(
                    "Exit Pomodoro?",
                     "A Pomodoro session is currently active. Are you sure you want to stop? Progress will be saved.",
                     true, // isCancellable = true
                     () => { // onConfirm
                          clearInterval(pomodoroInterval);
                          isPomodoroActive = false;
                          saveState(); // Save points earned so far
                          overlay.style.display = "none";
                     },
                     () => {} // onCancel = do nothing
                 );

            } else {
                // If not active, just close
                overlay.style.display = "none";
            }
        }


        function updatePomodoroDisplay() {
            const timerElement = document.getElementById("pomodoroTimer");
            if (!timerElement) return;

            const minutes = Math.floor(pomodoroTimeRemaining / 60);
            const seconds = pomodoroTimeRemaining % 60;

            timerElement.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
        }

        function completePomodoroSession() {
            clearInterval(pomodoroInterval);
            isPomodoroActive = false;

            playSound("pomodoroCompleteAudio"); // Play completion sound

             // Final point for the last minute if exactly on time
             if (pomodoroTimeRemaining === 0) {
                 const earned = applyPowerUps(1);
                 points += earned;
                 if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
             }


            const statusEl = document.getElementById("pomodoroStatus");
             if (statusEl) statusEl.textContent = `Session Complete! Well done!`;

             // Enable start, disable reset
             document.getElementById('pomodoroStartBtn').disabled = false;
             document.getElementById('pomodoroResetBtn').disabled = true;


            saveState(); // Save final points
            checkLevelUp();

             // Optional: Auto-reset or prompt for next session?
            // setTimeout(resetPomodoro, 3000); // Auto-reset after 3 secs
        }


      // --- Reminder Functions (Conceptual) ---

      function startReminderTimer() {
          // This timer was originally for the input form.
          // We can repurpose it for the Home page if needed, e.g., remind to start focusing.
          stopReminderTimer(); // Clear existing timer first
          console.log("Reminder timer started (currently no action).");
          // reminderInterval = setInterval(() => {
          //     timeOnInputForm += reminderIntervalTime;
          //     if (timeOnInputForm >= reminderThreshold) {
          //         // Trigger reminder (e.g., notification or alert)
          //         // alert("Don't forget to start your focus session or check your tasks!");
          //         console.log("Reminder triggered!");
          //         timeOnInputForm = 0; // Reset counter after triggering
          //     }
          // }, reminderIntervalTime);
      }

      function stopReminderTimer() {
        if (reminderInterval) {
          clearInterval(reminderInterval);
          reminderInterval = null;
          console.log("Reminder timer stopped.");
        }
          timeOnInputForm = 0; // Reset time counter
      }


      // --- Task Management Functions ---

        function toggleTodo() {
            if (!todoListPopup) return;
            const isVisible = todoListPopup.style.display === "flex";
            if (isVisible) {
                saveTasks(); // Save tasks when closing
                todoListPopup.style.display = "none";
            } else {
                restoreTasks(); // Load tasks when opening
                todoListPopup.style.display = "flex";
            }
        }

        function addTaskLine(taskData = { text: "", completed: false, deadline: null, points: null }) {
            if (!tasksContainer) return null;

            const line = document.createElement("div");
            line.className = "task-line";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.className = "task-check";
            checkbox.checked = taskData.completed;
            checkbox.onchange = handleTaskCompletionChange; // Use specific handler

            const input = document.createElement("input");
            input.type = "text";
            input.className = "task-text";
            input.placeholder = "Add a new quest...";
            input.value = taskData.text;
            input.readOnly = taskData.completed; // Make completed tasks read-only
            input.onkeydown = handleTaskInputKeydown;
            input.onchange = () => { line.dataset.text = input.value; }; // Store value on change for saving


             // Store data attributes for easier access
             line.dataset.text = taskData.text;
             line.dataset.completed = taskData.completed;
             if(taskData.deadline) line.dataset.deadline = taskData.deadline;
             if(taskData.points) line.dataset.points = taskData.points;
             if(taskData.deadlineChecked) line.dataset.deadlineChecked = taskData.deadlineChecked;


            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'task-buttons';

            const deadlineBtn = document.createElement("button");
            deadlineBtn.className = "set-deadline";
            deadlineBtn.innerHTML = '<i class="fas fa-stopwatch"></i>'; // Use icon
            deadlineBtn.title = "Set Deadline";
            deadlineBtn.onclick = () => showDeadlineDialog(line);
             deadlineBtn.disabled = taskData.completed; // Disable if completed


            const removeBtn = document.createElement("button");
            removeBtn.className = "remove-task";
            removeBtn.innerHTML = '<i class="fas fa-times"></i>'; // Use icon
             removeBtn.title = "Remove Task";
            removeBtn.onclick = () => removeTask(line);


             buttonsContainer.appendChild(deadlineBtn);
             buttonsContainer.appendChild(removeBtn);

            line.appendChild(checkbox);
            line.appendChild(input);
             line.appendChild(buttonsContainer); // Add buttons container

            // Add deadline/points info spans if they exist
             updateTaskDeadlineDisplay(line, taskData.deadline, taskData.points);

            tasksContainer.appendChild(line);

             // Style completed tasks
             if (taskData.completed) {
                 line.style.opacity = '0.7';
             }


            return input; // Return the input element for focusing
        }

         // Handle Enter key in task input
         function handleTaskInputKeydown(event) {
             if (event.key === "Enter") {
                 event.preventDefault();
                 const currentInput = event.target;
                 const currentLine = currentInput.closest('.task-line');
                 currentLine.dataset.text = currentInput.value; // Save current value before adding new

                 // Check if this is the last task line
                 const allLines = tasksContainer.querySelectorAll('.task-line');
                 if (currentLine === allLines[allLines.length - 1]) {
                     const newFocusTarget = addTaskLine(); // Add a new empty line
                     if (newFocusTarget) newFocusTarget.focus();
                 } else {
                     // Find the next task input and focus it
                     let nextLine = currentLine.nextElementSibling;
                     while (nextLine && !nextLine.classList.contains('task-line')) {
                         nextLine = nextLine.nextElementSibling;
                     }
                     if (nextLine) {
                         const nextInput = nextLine.querySelector('.task-text');
                         if (nextInput) nextInput.focus();
                     } else {
                         // If somehow there's no next line, add one
                           const newFocusTarget = addTaskLine();
                           if (newFocusTarget) newFocusTarget.focus();
                     }
                 }
             }
         }


        function removeTask(taskElement) {
            if (!tasksContainer || !taskElement) return;

            // Don't remove the last line if it's the only one
             if (tasksContainer.children.length > 1) {
                tasksContainer.removeChild(taskElement);
                // No need to call saveTasks here, it's called on close/save button
             } else {
                 // Clear the text of the last line instead of removing
                 const input = taskElement.querySelector('.task-text');
                 if (input) input.value = '';
                 taskElement.dataset.text = '';
                 // Also clear deadline info?
                 taskElement.removeAttribute('data-deadline');
                 taskElement.removeAttribute('data-points');
                 updateTaskDeadlineDisplay(taskElement, null, null);
             }
        }

        function restoreTasks() {
            if (!tasksContainer) return;
            tasksContainer.innerHTML = ""; // Clear existing lines

            if (tasks.length === 0) {
                addTaskLine(); // Add one empty line if no tasks saved
            } else {
                tasks.forEach(taskData => addTaskLine(taskData));
            }
             // Check for passed deadlines immediately after restoring
             checkTaskDeadlines();
        }

        function saveTasks() {
            if (!tasksContainer) return;
            const taskLines = tasksContainer.querySelectorAll(".task-line");

            tasks = Array.from(taskLines).map(line => {
                 const input = line.querySelector(".task-text");
                 const checkbox = line.querySelector(".task-check");
                 return {
                     text: input ? input.value.trim() : (line.dataset.text || ""), // Use input value first, then dataset
                     completed: checkbox ? checkbox.checked : (line.dataset.completed === 'true'),
                     deadline: line.dataset.deadline ? parseInt(line.dataset.deadline) : null,
                     points: line.dataset.points ? parseInt(line.dataset.points) : null,
                      deadlineChecked: line.dataset.deadlineChecked === 'true' // Keep track if deadline was processed
                 };
             }).filter(task => task.text !== ""); // Filter out lines that became empty

            localStorage.setItem("tasks", JSON.stringify(tasks));
            if (isSignedIn && currentUser) {
                try {
                    const users = JSON.parse(localStorage.getItem("users") || "{}");
                    if(users[currentUser]) {
                         users[currentUser].tasks = tasks;
                         localStorage.setItem("users", JSON.stringify(users));
                    }
                } catch (err) {
                    console.error("Error saving tasks to user data:", err);
                }
            }
            console.log("Tasks saved:", tasks);
            updateFocusStatus(); // Update home page status
        }

         /** Handles checkbox change, applying styles and checking deadlines */
         function handleTaskCompletionChange(event) {
             const checkbox = event.target;
             const taskLine = checkbox.closest('.task-line');
             const input = taskLine.querySelector('.task-text');
             const deadlineBtn = taskLine.querySelector('.set-deadline');

             taskLine.dataset.completed = checkbox.checked; // Update data attribute

             if (checkbox.checked) {
                 input.readOnly = true;
                 taskLine.style.opacity = '0.7';
                 if(deadlineBtn) deadlineBtn.disabled = true;
                 // Check if deadline met ON COMPLETION
                 checkSingleTaskDeadline(taskLine);
             } else {
                 input.readOnly = false;
                 taskLine.style.opacity = '1';
                 if(deadlineBtn) deadlineBtn.disabled = false;
             }
             // Saving happens on popup close or save button
         }

         /** Checks a single task's deadline status, usually upon completion */
         function checkSingleTaskDeadline(taskLine) {
             const deadlineTimestamp = taskLine.dataset.deadline ? parseInt(taskLine.dataset.deadline) : null;
             const deadlineChecked = taskLine.dataset.deadlineChecked === 'true';
             const taskPoints = taskLine.dataset.points ? parseInt(taskLine.dataset.points) : null;
             const taskText = taskLine.dataset.text || "Untitled Task";

             if (!deadlineTimestamp || deadlineChecked || !taskPoints) return; // No deadline, already checked, or no points defined

             const now = Date.now();
             let earnedPoints = 0;
             let message = "";

             if (now <= deadlineTimestamp) {
                 // Completed ON TIME
                 earnedPoints = applyPowerUps(taskPoints);
                 points += earnedPoints;
                  message = `Quest "${taskText}" completed on time! +${earnedPoints} XP`;
                  playSound('achievementAudio'); // Success sound
             } else {
                 // Completed LATE (no points penalty for completing late, only for missing entirely)
                 message = `Quest "${taskText}" completed, but the deadline passed.`;
                  // No points awarded or deducted here. Deduction happens in the periodic check if not completed at all.
             }

              showConfirmation("Quest Update", message, false);
              if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;

             taskLine.dataset.deadlineChecked = 'true'; // Mark as checked to prevent re-processing
              saveState(); // Save points immediately
             checkLevelUp();
         }


          /** Periodic check for deadlines that have passed for UNCOMPLETED tasks */
         function checkTaskDeadlines() {
              const now = Date.now();
              let tasksUpdated = false;
              let totalPenalty = 0;

             tasks.forEach((task, index) => {
                  // Only check tasks that have a deadline, are NOT completed, and haven't been checked yet
                  if (!task.deadline || task.completed || task.deadlineChecked) return;

                 if (now > task.deadline) {
                      // Deadline passed for an uncompleted task
                      const penaltyPoints = Math.floor((task.points || 50) / 2); // Penalty is half the potential points
                      totalPenalty += penaltyPoints;

                     // Update the task state in the main `tasks` array
                     tasks[index].deadlineChecked = true;
                     tasksUpdated = true;

                     // Visually update the corresponding task line if ToDo list is open
                     const taskLines = tasksContainer?.querySelectorAll('.task-line');
                     if (taskLines && taskLines[index]) {
                          taskLines[index].dataset.deadlineChecked = 'true';
                          // Maybe add visual indicator for missed deadline?
                           const deadlineInfo = taskLines[index].querySelector('.deadline-info');
                           if (deadlineInfo) deadlineInfo.textContent += " (Missed)";
                           taskLines[index].style.backgroundColor = 'rgba(220, 53, 69, 0.1)'; // Reddish background tint
                     }
                 }
             });

              if (totalPenalty > 0) {
                 points = Math.max(0, points - totalPenalty); // Apply penalty, ensure points don't go below 0
                 showConfirmation("Deadline Missed!", `You missed the deadline for one or more quests! -${totalPenalty} XP penalty applied.`, false);
                 if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                 saveState(); // Save points deduction
              }

             if (tasksUpdated) {
                 saveTasks(); // Save the updated `deadlineChecked` status
             }
         }



      // --- Task Deadline Dialog ---

        function showDeadlineDialog(taskElement) {
            const dialog = document.getElementById("deadlineDialog");
            const dateInput = document.getElementById("deadlineDate");
            const timeInput = document.getElementById("deadlineTime");
            const difficultySelect = document.getElementById("taskDifficulty");

            if (!dialog || !dateInput || !timeInput || !difficultySelect || !taskElement) return;

            currentTaskForDeadline = taskElement; // Store reference to the task line element

            // Pre-fill with existing deadline or default
            const existingDeadline = taskElement.dataset.deadline ? parseInt(taskElement.dataset.deadline) : null;
             const existingPoints = taskElement.dataset.points ? parseInt(taskElement.dataset.points) : null;


            if (existingDeadline) {
                 const d = new Date(existingDeadline);
                 dateInput.value = d.toISOString().split('T')[0];
                 timeInput.value = d.toTimeString().substring(0, 5); // HH:MM
            } else {
                // Default to tomorrow at current time
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                dateInput.value = tomorrow.toISOString().split('T')[0];
                const now = new Date();
                timeInput.value = now.toTimeString().substring(0, 5);
            }

             // Pre-select difficulty
             difficultySelect.value = existingPoints || "100"; // Default to medium (100)


            dialog.style.display = "flex";
        }

        function handleDeadlineConfirmation(choice) {
            const dialog = document.getElementById("deadlineDialog");
            if (!dialog || !currentTaskForDeadline) return;

            dialog.style.display = "none";

            if (choice === "yes") {
                const dateValue = document.getElementById("deadlineDate").value;
                const timeValue = document.getElementById("deadlineTime").value;
                const difficultySelect = document.getElementById("taskDifficulty");
                const selectedPoints = difficultySelect.value;

                 if (!dateValue || !timeValue) {
                     showConfirmation("Invalid Date/Time", "Please select a valid date and time for the deadline.", false);
                     currentTaskForDeadline = null;
                     return;
                 }

                const deadlineTimestamp = new Date(`${dateValue}T${timeValue}`).getTime();

                 // Validate deadline is in the future
                if (deadlineTimestamp <= Date.now()) {
                    showConfirmation("Invalid Deadline", "The deadline must be set in the future.", false);
                    currentTaskForDeadline = null;
                    return;
                }


                 // Update data attributes on the task line element
                 currentTaskForDeadline.dataset.deadline = deadlineTimestamp;
                 currentTaskForDeadline.dataset.points = selectedPoints;
                 currentTaskForDeadline.dataset.deadlineChecked = 'false'; // Reset checked status if deadline is changed

                 // Update the visual display for the task line
                 updateTaskDeadlineDisplay(currentTaskForDeadline, deadlineTimestamp, selectedPoints);

                 // Saving happens when the ToDo list is closed or saved explicitly
                 console.log(`Deadline set for task "${currentTaskForDeadline.dataset.text}"`);

            }

            currentTaskForDeadline = null; // Clear reference
        }


       /** Updates or removes the deadline/points spans on a task line */
       function updateTaskDeadlineDisplay(taskLine, deadlineTimestamp, pointsValue) {
           // Remove existing spans first
           const existingDeadlineSpan = taskLine.querySelector(".deadline-info");
           if (existingDeadlineSpan) existingDeadlineSpan.remove();
           const existingPointsSpan = taskLine.querySelector(".points-info");
           if (existingPointsSpan) existingPointsSpan.remove();

            if (deadlineTimestamp && pointsValue) {
                const deadlineDate = new Date(deadlineTimestamp);

                 const deadlineInfo = document.createElement("span");
                 deadlineInfo.className = "deadline-info";
                 // Format date/time nicely
                 const dateOptions = { month: 'short', day: 'numeric' };
                 const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
                 deadlineInfo.textContent = `Due: ${deadlineDate.toLocaleDateString(undefined, dateOptions)} ${deadlineDate.toLocaleTimeString(undefined, timeOptions)}`;
                 deadlineInfo.title = deadlineDate.toLocaleString(); // Full date on hover

                 const pointsInfo = document.createElement("span");
                 pointsInfo.className = "points-info";
                 pointsInfo.textContent = `+${pointsValue} XP`;


                // Append after the text input but before the buttons
                 const buttonsContainer = taskLine.querySelector('.task-buttons');
                 if (buttonsContainer) {
                      taskLine.insertBefore(pointsInfo, buttonsContainer);
                      taskLine.insertBefore(deadlineInfo, pointsInfo); // Insert deadline before points
                 } else {
                     // Fallback if buttons container not found (shouldn't happen)
                     taskLine.appendChild(deadlineInfo);
                     taskLine.appendChild(pointsInfo);
                 }
            }
        }



      // --- YouTube Player Functions ---

      /**
       * Extracts YouTube Video ID from various URL formats.
       * @param {string} url - The YouTube URL.
       * @returns {string|null} The video ID or null if invalid.
       */
      function extractVideoId(url) {
        if (!url) return null;
        try {
          // Standard watch URL
          let match = url.match(/[?&]v=([^&]+)/);
          if (match) return match[1];

          // Shortened youtu.be URL
          match = url.match(/youtu\.be\/([^?&]+)/);
          if (match) return match[1];

           // Live URL
           match = url.match(/\/live\/([^?&/]+)/);
           if (match) return match[1];

          // Embed URL
          match = url.match(/\/embed\/([^?&]+)/);
          if (match) return match[1];

           // Shorts URL
           match = url.match(/\/shorts\/([^?&]+)/);
           if (match) return match[1];

          console.warn("Could not extract Video ID from URL:", url);
          return null; // No valid ID found
        } catch (e) {
          console.error("Error parsing URL:", url, e);
          return null;
        }
      }


        /** Initiates the process of starting YouTube playback */
        function prepareAndStartPlayback() {
             try {
                 const urlElements = urlInputsContainer.querySelectorAll(".youtube-url");
                 const urls = Array.from(urlElements)
                                 .map(input => input.value.trim())
                                 .filter(url => url); // Get non-empty URLs

                if (urls.length === 0) {
                    showConfirmation("No URLs", "Please enter at least one YouTube video or live stream URL.", false);
                    return;
                }

                videoIds = urls.map(extractVideoId).filter(id => id); // Extract valid IDs

                if (videoIds.length === 0) {
                     showConfirmation("Invalid URLs", "None of the provided URLs seem to be valid YouTube videos or live streams.", false);
                     return;
                 }

                 // Reset session state
                 currentVideoIndex = 0;
                 completedVideos.clear();
                 allVideosCompleted = false;

                  // Switch view first
                  showView('youtubeLecturePage');

                 // Then initialize the player and timer
                 initializeYouTubeView();

                 saveState(); // Save the video IDs and reset state

                 // Optional: Request fullscreen
                 requestFullscreen(document.documentElement);


             } catch (err) {
                 console.error("Error preparing playback:", err);
                 showConfirmation("Playback Error", "An unexpected error occurred while trying to start the session.", false);
             }
        }

         /** Loads the YouTube API script if not already loaded */
        function loadYouTubeAPI() {
            return new Promise((resolve, reject) => {
            if (isYouTubeAPILoaded) {
                resolve();
                return;
            }
            console.log("Loading YouTube IFrame API...");
            const tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";
            tag.async = true; // Load asynchronously

             // Define the global callback function
             window.onYouTubeIframeAPIReady = () => {
                 console.log("YouTube IFrame API Ready.");
                 isYouTubeAPILoaded = true;
                 // Ensure YT object is available before resolving
                  if (typeof YT !== 'undefined' && YT.Player) {
                     resolve();
                 } else {
                      // Sometimes it might take a moment longer
                      setTimeout(() => {
                          if (typeof YT !== 'undefined' && YT.Player) {
                              resolve();
                          } else {
                               console.error("YT.Player not available after API ready.");
                               reject(new Error("YouTube Player object not found after API load."));
                          }
                      }, 500); // Wait a bit longer
                 }

             };

            tag.onerror = (error) => {
                console.error("Failed to load YouTube API script:", error);
                reject(new Error("Failed to load YouTube API script."));
            };

            // Append the script tag to the head
             document.head.appendChild(tag);

            // Timeout mechanism in case the API load hangs
            setTimeout(() => {
                 if (!isYouTubeAPILoaded) {
                    console.error("YouTube API load timed out.");
                     reject(new Error("YouTube API load timed out."));
                 }
            }, 15000); // 15 second timeout
            });
        }


       /** Sets up the YouTube view: Loads API, creates player, starts timer */
       function initializeYouTubeView() {
           if (videoIds.length === 0) {
                console.warn("initializeYouTubeView called with no video IDs.");
                showView('home'); // Go back home if no videos
                return;
           }

            loadYouTubeAPI()
                .then(() => {
                    console.log("API loaded successfully, setting up player.");
                    setupYouTubePlayer(); // Create the player instance
                    updateStreak(); // Update streak when focus starts
                    startTimer(focusDuration, "Focus Time"); // Start the focus timer
                     if(timerDisplay) timerDisplay.style.display = 'block'; // Ensure timer is visible
                     setupVideoSidebar(); // Populate video list sidebar
                     updateFocusStatus(); // Update status on home page (even though hidden)
                })
                .catch((err) => {
                    console.error("Failed to initialize YouTube View:", err);
                     showConfirmation("Player Error", "Could not load the YouTube player. Please check your connection and try again.", false);
                     showView('home'); // Go back home on error
                     isFocusModeActive = false; // Ensure focus mode is off
                });
       }


      /** Creates the YT.Player instance */
      function setupYouTubePlayer() {
          if (!isYouTubeAPILoaded || typeof YT === 'undefined' || !YT.Player) {
              console.error("YouTube API not ready for player setup.");
              return;
          }
           if (!playerDiv) {
               console.error("Player div element not found.");
               return;
           }
           if (videoIds.length === 0) {
               console.warn("No video IDs to load.");
               return;
           }

          // Destroy existing player if it exists
          if (player && typeof player.destroy === 'function') {
              console.log("Destroying previous player instance.");
              player.destroy();
              player = null;
          }

          console.log("Creating new YT.Player with video ID:", videoIds[currentVideoIndex]);
          try {
              player = new YT.Player("player", { // Target the ID 'player'
                  height: "100%",
                  width: "100%",
                  videoId: videoIds[currentVideoIndex],
                  playerVars: {
                      autoplay: 1, // Autoplay first video
                      controls: 1, // Show YouTube controls
                      modestbranding: 1, // Less YouTube logo
                      rel: 0, // No related videos at end
                      showinfo: 0, // Hide video title/uploader
                      iv_load_policy: 3, // Hide annotations
                      fs: 1, // Allow fullscreen button in player
                      // origin: window.location.origin // Recommended for security
                  },
                  events: {
                      onReady: onPlayerReady,
                      onStateChange: onPlayerStateChange,
                       onError: onPlayerError
                  },
              });
          } catch (error) {
               console.error("Error creating YT.Player:", error);
               showConfirmation("Player Creation Failed", "There was an issue creating the video player.", false);
               showView('home');
          }
      }

      /** Called when the player is ready */
      function onPlayerReady(event) {
        console.log("Player Ready. Playing video:", videoIds[currentVideoIndex]);
        event.target.playVideo();
        isFocusModeActive = true; // Mark focus as active once player starts
         highlightCurrentThumbnail();
      }

      /** Called when the player's state changes (playing, paused, ended, etc.) */
      function onPlayerStateChange(event) {
        console.log("Player State Change:", event.data);
        if (event.data === YT.PlayerState.ENDED) {
          console.log("Video ended:", videoIds[currentVideoIndex]);
          completedVideos.add(videoIds[currentVideoIndex]);
          totalVideosWatched++;

          const earnedPoints = applyPowerUps(50); // 50 base points per video
          points += earnedPoints;
          if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;

          checkLevelUp();
          saveState(); // Save progress after each video
          updateAnalyticsDisplay(); // Update stats page if visible

          currentVideoIndex++;
          if (currentVideoIndex < videoIds.length) {
              console.log("Loading next video:", videoIds[currentVideoIndex]);
            player.loadVideoById(videoIds[currentVideoIndex]);
             highlightCurrentThumbnail();
          } else {
            console.log("All videos completed.");
            allVideosCompleted = true;
             // Don't automatically end session, let timer run out or user exit
             showConfirmation("Playlist Complete!", "You've watched all videos in this session. Keep focusing until the timer ends or exit when ready.", false);
             // Maybe stop the player or show a 'finished' screen?
              player.stopVideo();
          }
        } else if (event.data === YT.PlayerState.PAUSED) {
             // Optional: Handle pause event, maybe pause timer?
             console.log("Video paused.");
        } else if (event.data === YT.PlayerState.PLAYING) {
             console.log("Video playing.");
             isFocusModeActive = true; // Ensure focus mode stays active
             highlightCurrentThumbnail();
        }
      }

       /** Handles player errors */
       function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            let errorMsg = "An unknown error occurred with the YouTube player.";
            switch (event.data) {
                case 2: errorMsg = "The video request contains an invalid parameter value."; break;
                case 5: errorMsg = "The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred."; break;
                case 100: errorMsg = "The video requested was not found."; break;
                case 101:
                case 150: errorMsg = "The owner of the requested video does not allow it to be played in embedded players."; break;
            }
             showConfirmation("Video Playback Error", `${errorMsg} Skipping to the next video if available. (Error code: ${event.data})`, false);

             // Attempt to play next video automatically on error
             setTimeout(() => {
                 currentVideoIndex++;
                 if (currentVideoIndex < videoIds.length) {
                     console.log("Attempting to load next video due to error:", videoIds[currentVideoIndex]);
                     player.loadVideoById(videoIds[currentVideoIndex]);
                 } else {
                     console.log("All videos attempted after error.");
                     allVideosCompleted = true;
                     endFocusSession("Error playing videos."); // End session if last video errors
                 }
             }, 2000); // Wait 2 seconds before skipping
       }


      /** Populates the video thumbnail sidebar */
      function setupVideoSidebar() {
        if (!videoThumbnailList) return;
        videoThumbnailList.innerHTML = ''; // Clear previous thumbnails

        if(videoIds.length <= 1) {
            // Hide sidebar toggle if only one video
            if(videoSidebarToggleBtn) videoSidebarToggleBtn.style.display = 'none';
             closeVideoSidebar(); // Ensure it's closed
             return;
        } else {
            // Show toggle if multiple videos
             if(videoSidebarToggleBtn) videoSidebarToggleBtn.style.display = 'block';
        }


        videoIds.forEach((id, index) => {
          const thumbnail = document.createElement("img");
          thumbnail.src = `https://img.youtube.com/vi/${id}/mqdefault.jpg`; // Medium quality thumbnail
          thumbnail.alt = `Video Thumbnail ${index + 1}`;
          thumbnail.className = "thumbnail";
           thumbnail.dataset.index = index; // Store index
           thumbnail.title = `Play Video ${index + 1}`;
          thumbnail.onclick = () => {
            if (index !== currentVideoIndex) { // Prevent reloading same video
                 currentVideoIndex = index;
                 player.loadVideoById(videoIds[currentVideoIndex]);
                 highlightCurrentThumbnail();
                 closeVideoSidebar(); // Close sidebar after selection
            }
          };
           // Add error handling for broken thumbnails
           thumbnail.onerror = () => {
               thumbnail.alt = `Thumbnail unavailable (Video ${index+1})`;
               thumbnail.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'; // Transparent pixel
               thumbnail.style.border = '1px dashed var(--text-dim)';
               thumbnail.style.height = '70px'; // Maintain some height
           };

          videoThumbnailList.appendChild(thumbnail);
        });
         highlightCurrentThumbnail(); // Highlight initially loaded video
      }

       /** Toggles the visibility of the video thumbnail sidebar */
       function toggleVideoSidebar() {
            if (!videoSidebar) return;
            isVideoSidebarOpen = !isVideoSidebarOpen;
            if (isVideoSidebarOpen) {
                 videoSidebar.classList.add('open');
                 // Optional: Change icon on toggle button
                 if(videoSidebarToggleBtn) videoSidebarToggleBtn.innerHTML = '<i class="fas fa-times"></i>';
            } else {
                 videoSidebar.classList.remove('open');
                  if(videoSidebarToggleBtn) videoSidebarToggleBtn.innerHTML = '<i class="fas fa-list"></i>';
            }
       }

        function closeVideoSidebar() {
             if (!videoSidebar || !isVideoSidebarOpen) return;
             isVideoSidebarOpen = false;
             videoSidebar.classList.remove('open');
             if(videoSidebarToggleBtn) videoSidebarToggleBtn.innerHTML = '<i class="fas fa-list"></i>';
        }


       /** Highlights the currently playing video thumbnail */
       function highlightCurrentThumbnail() {
           if (!videoThumbnailList) return;
           const thumbnails = videoThumbnailList.querySelectorAll('.thumbnail');
           thumbnails.forEach((thumb, index) => {
               if (index === currentVideoIndex) {
                   thumb.classList.add('active');
                    // Scroll sidebar to show active thumbnail (optional)
                    // thumb.scrollIntoView({ behavior: 'smooth', block: 'center' });
               } else {
                   thumb.classList.remove('active');
               }
           });
       }

      // --- Focus Timer Functions ---

      function startTimer(duration, mode) {
        if (!timerDisplay || !progressFill || !progressBar) return;

        clearInterval(countdownInterval); // Clear any existing timer

        isFocusModeActive = true;
        timerMode = mode;
        let timeRemainingSeconds = Math.max(0, Math.floor(duration / 1000)); // Ensure non-negative start time
        timerRemaining = timeRemainingSeconds; // Update global state
        const totalDurationSeconds = Math.floor(duration / 1000);

        progressBar.style.display = "block"; // Make progress bar visible
        progressFill.style.width = '0%'; // Reset progress fill
         timerDisplay.style.display = 'block'; // Make timer display visible

        console.log(`Timer started: ${mode} for ${totalDurationSeconds} seconds`);

        countdownInterval = setInterval(() => {
            const minutes = Math.floor(timeRemainingSeconds / 60);
            const seconds = Math.floor(timeRemainingSeconds % 60);

            if(timerText) timerText.textContent = `${mode}: ${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

            // Calculate progress, prevent division by zero
            const progress = totalDurationSeconds > 0 ? ((totalDurationSeconds - timeRemainingSeconds) / totalDurationSeconds) * 100 : 0;
            progressFill.style.width = `${Math.min(100, progress)}%`; // Cap at 100%


             // Increment total focus time only during focus mode
             if (mode === "Focus Time") {
                 totalFocusTime++; // Increment lifetime focus time every second
                 // Points are awarded at the *end* of the session or per video
             }

             // Update global remaining time state
             timerRemaining = timeRemainingSeconds;

            timeRemainingSeconds--; // Decrement after calculations

            if (timeRemainingSeconds < 0) {
                 // Timer finished
                 clearInterval(countdownInterval);
                 progressFill.style.width = '100%'; // Ensure it shows full
                 progressBar.style.display = "none"; // Hide progress bar after completion


                 if (mode === "Focus Time") {
                     console.log("Focus session finished.");
                     const earnedPoints = applyPowerUps(100); // 100 base points per completed focus session
                     points += earnedPoints;
                     if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                     checkLevelUp();
                     playSound("focusAudio"); // Play session end sound

                     // Show session complete dialog instead of auto-starting break
                     showSessionCompleteDialog();
                     // isFocusModeActive remains true until user chooses to end

                 } else if (mode === "Break Time") { // First break finished
                     console.log("Long break finished.");
                     startTimer(secondBreakDuration, "Short Break");
                 } else { // Short break finished
                     console.log("Short break finished.");
                     startTimer(focusDuration, "Focus Time"); // Loop back to focus
                 }
                 saveState(); // Save points and timer state
            }
        }, 1000);
      }


        /** Ends the focus session entirely, called from dialog or exit button */
        function endFocusSession(reason = "Session ended normally.") {
             console.log("Ending focus session:", reason);
             clearInterval(countdownInterval);
             isFocusModeActive = false;
             timerRemaining = focusDuration / 1000; // Reset timer duration state
             timerMode = "Focus Time";

            // Clean up YouTube player if it exists
             if (player && typeof player.destroy === 'function') {
                 player.destroy();
                 player = null;
                 console.log("YouTube player destroyed.");
             }
             // Reset video state
             videoIds = [];
             currentVideoIndex = 0;
             completedVideos.clear();
             allVideosCompleted = false;


             // Update UI
             if(timerDisplay) timerDisplay.style.display = 'none';
             if(progressBar) progressBar.style.display = 'none';
             if(progressFill) progressFill.style.width = '0%';

              closeVideoSidebar(); // Ensure video sidebar is closed
              if(videoSidebarToggleBtn) videoSidebarToggleBtn.style.display = 'none'; // Hide toggle btn


             exitFullscreen(); // Exit fullscreen if active
             saveState(); // Save the final state
             updateAnalyticsDisplay(); // Update stats display
             updateFocusStatus(); // Update home page status

             showView('home'); // Go back to the home page
        }


      /** Shows the Session Complete dialog */
      function showSessionCompleteDialog() {
        const dialog = document.getElementById("sessionCompleteDialog");
        if (dialog) dialog.style.display = "flex";
      }

      /** Handles user choice from Session Complete dialog */
      function handleSessionContinue(choice) {
        const dialog = document.getElementById("sessionCompleteDialog");
        if (dialog) dialog.style.display = "none";

        if (choice === "continue") {
          // Award bonus points
          const bonusPoints = applyPowerUps(100);
          points += bonusPoints;
          if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
           showConfirmation("Bonus XP!", `You earned +${bonusPoints} XP for starting another session!`, false);
           playSound('achievementAudio');
          checkLevelUp();
          saveState();

          // Start a new focus session immediately
          // Needs to decide if it uses the *same* videos or prompts for new ones?
          // For now, let's assume it restarts the timer but keeps videos (or prompts user)
          // If keeping videos, just restart timer:
          startTimer(focusDuration, "Focus Time");
          // If prompting for new videos is desired, this logic needs adjustment, maybe go home first.

        } else {
          // User chose to end the session
          endFocusSession("User ended session after completion.");
        }
      }


      /** Shows the confirmation dialog for exiting */
      function requestExitSession() {
         showConfirmation(
             "Abandon Quest?",
             "Are you sure you want to end this focus session? Current progress will be saved.",
             true, // isCancellable
             () => { endFocusSession("User exited session early."); }, // onConfirm
             () => { console.log("Exit cancelled."); } // onCancel
         );
      }


       // --- PDF Viewer Functions ---

        function togglePDFViewer() {
            const pdfPopup = document.getElementById("pdfViewer");
             const pdfFrame = document.getElementById("pdfFrame");
            if (!pdfPopup) return;
            const isVisible = pdfPopup.style.display === "flex";
            if (isVisible) {
                pdfPopup.style.display = "none";
                if (pdfFrame) pdfFrame.src = 'about:blank'; // Clear iframe src to release memory
            } else {
                // Reset file input value in case user wants to upload same file again
                 const pdfInput = document.getElementById("pdfInput");
                 if (pdfInput) pdfInput.value = '';
                 if (pdfFrame) pdfFrame.src = 'about:blank';
                 pdfPopup.style.display = "flex";
            }
        }

        function handlePDFUpload(event) {
            const file = event.target.files[0];
            const pdfFrame = document.getElementById("pdfFrame");
            const pdfPopup = document.getElementById("pdfViewer"); // Needed to ensure it's visible

            if (!pdfFrame || !pdfPopup) return;

            if (!file || file.type !== "application/pdf") {
                 showConfirmation("Invalid File", "Please select a valid PDF file.", false);
                 event.target.value = ''; // Clear the input
                 pdfFrame.src = 'about:blank'; // Clear frame
                return;
            }

            const objectURL = URL.createObjectURL(file);
            pdfFrame.src = objectURL;

             // Release the object URL when the iframe is unloaded or popup closed (important for memory)
             pdfFrame.onload = () => {
                pdfFrame.contentWindow.addEventListener('unload', () => {
                     console.log("Releasing PDF Object URL");
                     URL.revokeObjectURL(objectURL);
                 });
             };
             // Also revoke if popup is closed manually before iframe unloads (fallback)
             // This might be tricky depending on timing. Best practice is usually on unload.

             pdfPopup.style.display = "flex"; // Ensure popup is visible
        }


      // --- AI Chatbot Functions ---

      function toggleAIPopup() {
        if (!aiPopup) return;
        const isVisible = aiPopup.style.display === "block";
        aiPopup.style.display = isVisible ? "none" : "block";
         // Maybe focus iframe when opened? (Might have cross-origin issues)
      }

      // --- Sidebar Functions ---

        function toggleSidebar() {
            if (!gameSidebar || !sidebarTrigger) return;
            isSidebarOpen = !isSidebarOpen;
            if(isSidebarOpen) {
                gameSidebar.classList.add('open');
                 sidebarTrigger.style.left = '280px'; // Move trigger with sidebar
            } else {
                gameSidebar.classList.remove('open');
                sidebarTrigger.style.left = '0px'; // Reset trigger position
            }
        }
         function closeSidebar() {
            if (!gameSidebar || !sidebarTrigger || !isSidebarOpen) return;
            isSidebarOpen = false;
             gameSidebar.classList.remove('open');
             sidebarTrigger.style.left = '0px';
        }


      // --- Authentication & User Data ---

       function showSignInForm() {
            showView('signinForm');
            // Clear fields on show
            if(usernameInput) usernameInput.value = '';
            if(passwordInput) passwordInput.value = '';
       }


        function signIn() {
            if(!usernameInput || !passwordInput) return;
            const username = usernameInput.value.trim();
            const password = passwordInput.value; // Don't trim password

            if (!username || !password) {
                 showConfirmation("Missing Info", "Please enter both Hero Name and Secret Code.", false);
                 return;
            }

            try {
                const users = JSON.parse(localStorage.getItem("users") || "{}");
                if (users[username] && users[username].password === password) {
                     // Sign in successful
                     isSignedIn = true;
                     currentUser = username;

                     // Load user data
                     points = users[username].points || 0;
                     previousPoints = points; // Sync previous points on login
                     totalFocusTime = users[username].totalFocusTime || 0;
                     totalDistractions = users[username].totalDistractions || 0;
                     totalVideosWatched = users[username].totalVideosWatched || 0;
                     tasks = users[username].tasks || [];
                     streakDays = users[username].streakDays || 0;
                     lastFocusDate = users[username].lastFocusDate || null; // Load last focus date for streak calc
                     mysteryBoxCount = users[username].mysteryBoxCount || 0;
                     activePowerUps = users[username].activePowerUps || {
                         doublePoints: { active: false, expiry: null },
                         streakShield: { active: false, used: false, expiry: null },
                     };
                    // Ensure power-up structure is valid
                    if (!activePowerUps.doublePoints) activePowerUps.doublePoints = { active: false, expiry: null };
                     if (!activePowerUps.streakShield) activePowerUps.streakShield = { active: false, used: false, expiry: null };


                    // Load premium track unlock status
                    const savedTracks = users[username].premiumLofiTracks || [];
                    premiumLofiTracks.forEach(track => {
                        const saved = savedTracks.find(st => st.id === track.id);
                        track.unlocked = saved ? saved.unlocked : false;
                    });
                    updateAvailableLofiTracks(); // Update playable list

                     // Update UI
                     if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                     updateAchievementLevel();
                     updateStreakDisplay(); // Update streak immediately on login

                     // Navigate to home
                     showView('homePage');

                     populatePlaylistSelect(); // Load user's playlists
                     restoreTasks(); // Load user's tasks (do this *after* showing view?)


                     // Check for expired powerups on login
                     checkExpiredPowerups();

                     console.log(`User ${currentUser} signed in.`);


                } else {
                     showConfirmation("Login Failed", "Invalid Hero Name or Secret Code.", false);
                     isSignedIn = false;
                     currentUser = null;
                }
            } catch (err) {
                console.error("Sign-in error:", err);
                 showConfirmation("Sign-in Error", "An error occurred during sign-in. Local data might be corrupted.", false);
            }
        }


        function createAccount() {
             if(!usernameInput || !passwordInput) return;
             const username = usernameInput.value.trim();
             const password = passwordInput.value;

             if (!username || !password) {
                 showConfirmation("Missing Info", "Please enter both Hero Name and Secret Code.", false);
                 return;
             }
             if (password.length < 4) { // Basic validation
                 showConfirmation("Weak Code", "Secret Code should be at least 4 characters long.", false);
                 return;
             }


            try {
                const users = JSON.parse(localStorage.getItem("users") || "{}");
                if (users[username]) {
                     showConfirmation("Name Taken", "This Hero Name is already registered. Please choose another.", false);
                } else {
                    // Create new user entry
                    users[username] = {
                        password: password, // Store password (consider hashing in a real app!)
                        points: 0,
                        totalFocusTime: 0,
                        totalDistractions: 0,
                        totalVideosWatched: 0,
                        tasks: [],
                        streakDays: 0,
                        lastFocusDate: null,
                        mysteryBoxCount: 0,
                         activePowerUps: {
                             doublePoints: { active: false, expiry: null },
                             streakShield: { active: false, used: false, expiry: null },
                         },
                        playlists: [], // Add playlists storage per user
                        premiumLofiTracks: premiumLofiTracks.map(track => ({ id: track.id, unlocked: false })) // Initial locked state
                    };
                    localStorage.setItem("users", JSON.stringify(users));

                    // Log in the new user
                     isSignedIn = true;
                     currentUser = username;
                     points = 0;
                     previousPoints = 0;
                     totalFocusTime = 0;
                     totalDistractions = 0;
                     totalVideosWatched = 0;
                     tasks = [];
                     streakDays = 0;
                     lastFocusDate = null;
                     mysteryBoxCount = 0;
                     activePowerUps = {
                         doublePoints: { active: false, expiry: null },
                         streakShield: { active: false, used: false, expiry: null },
                     };
                     playlists = []; // Reset playlists for new user
                      premiumLofiTracks.forEach(t => t.unlocked = false); // Ensure tracks are locked
                      updateAvailableLofiTracks();


                     // Update UI
                     if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: ${points}`;
                     updateAchievementLevel();
                     updateStreakDisplay();

                      // Navigate to home
                      showView('homePage');

                     populatePlaylistSelect(); // Show empty playlist dropdown
                     restoreTasks(); // Show empty task list

                      console.log(`Account created for ${currentUser}.`);
                      showConfirmation("Account Created!", `Welcome, Hero ${currentUser}! Your journey begins now.`, false);
                }
            } catch (err) {
                console.error("Account creation error:", err);
                 showConfirmation("Creation Error", "An error occurred creating the account.", false);
            }
        }


       function logout() {
            showConfirmation(
                "Logout?",
                "Are you sure you want to log out? Your progress is saved.",
                true, // isCancellable
                () => { // onConfirm
                    console.log(`Logging out user ${currentUser}`);
                     // Reset all user-specific state
                     isSignedIn = false;
                     currentUser = null;
                     points = 0;
                     previousPoints = 0;
                     totalFocusTime = 0;
                     totalDistractions = 0;
                     totalVideosWatched = 0;
                     tasks = [];
                     streakDays = 0;
                     lastFocusDate = null;
                     mysteryBoxCount = 0;
                     activePowerUps = {
                         doublePoints: { active: false, expiry: null },
                         streakShield: { active: false, used: false, expiry: null },
                     };
                     playlists = [];
                     premiumLofiTracks.forEach(t => t.unlocked = false);
                     updateAvailableLofiTracks();


                     // Reset focus session state if active
                     if(isFocusModeActive) {
                          clearInterval(countdownInterval);
                          isFocusModeActive = false;
                           if (player && typeof player.destroy === 'function') {
                               player.destroy(); player = null;
                           }
                          videoIds = [];
                          currentVideoIndex = 0;
                          completedVideos.clear();
                          allVideosCompleted = false;
                     }

                     // Reset UI related to user data
                      if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: 0`;
                      updateAchievementLevel();
                      updateStreakDisplay(); // Shows 0 days
                      populatePlaylistSelect(); // Clear playlists
                      restoreTasks(); // Clear tasks
                       if(timerDisplay) timerDisplay.style.display = 'none'; // Hide timer


                     // Clear sensitive fields if necessary (already happens on showSignInForm)


                     // Clear saved state for sensitive user info (optional, depends on persistence strategy)
                     // localStorage.removeItem('focusModeState'); // Or selectively clear parts

                     showView('landingPage'); // Go back to landing page
                },
                () => { console.log("Logout cancelled."); } // onCancel
            );
       }

      // --- Playlist Management ---

        function addUrlInput() {
             if (!urlInputsContainer) return;

             const container = document.createElement("div");
             container.className = "url-container";

             const newInput = document.createElement("input");
             newInput.type = "text";
             newInput.className = "youtube-url";
             newInput.placeholder = "Another YouTube URL";

             const removeBtn = document.createElement("button");
             removeBtn.innerHTML = '<i class="fas fa-times"></i>'; // Use icon
             removeBtn.title = "Remove URL";
             removeBtn.onclick = () => {
                 // Ensure we don't remove the very last input field
                 if (urlInputsContainer.querySelectorAll(".url-container").length > 1) {
                     urlInputsContainer.removeChild(container);
                 } else {
                      // Clear the value of the last input instead
                     newInput.value = '';
                 }
             };

             container.appendChild(newInput);
             container.appendChild(removeBtn);
             urlInputsContainer.appendChild(container);
             newInput.focus(); // Focus the newly added input
        }

       /** Clears and restores URL inputs based on a list of video IDs */
       function restoreUrlInputs(ids = []) {
            if (!urlInputsContainer) return;
            urlInputsContainer.innerHTML = ''; // Clear existing

            if (ids.length === 0) {
                // Add one empty input if no IDs provided
                addUrlInput();
                 // Ensure the first input doesn't have a remove button
                 const firstRemoveBtn = urlInputsContainer.querySelector('.url-container button');
                 if(firstRemoveBtn) firstRemoveBtn.remove();
            } else {
                ids.forEach((id, index) => {
                     const container = document.createElement("div");
                     container.className = "url-container";

                     const input = document.createElement("input");
                     input.type = "text";
                     input.className = "youtube-url";
                     input.placeholder = "YouTube URL";
                     input.value = `https://www.youtube.com/watch?v=${id}`; // Reconstruct URL
                     container.appendChild(input);

                     if (index > 0 || ids.length > 1) { // Add remove button if not the only one
                         const removeBtn = document.createElement("button");
                         removeBtn.innerHTML = '<i class="fas fa-times"></i>';
                          removeBtn.title = "Remove URL";
                         removeBtn.onclick = () => {
                              if (urlInputsContainer.querySelectorAll(".url-container").length > 1) {
                                 urlInputsContainer.removeChild(container);
                             } else {
                                 input.value = ''; // Clear last input
                             }
                         };
                         container.appendChild(removeBtn);
                     }
                      urlInputsContainer.appendChild(container);
                 });
                 // If after loading a playlist there's only one URL, remove its 'X' button
                 if (ids.length === 1) {
                     const singleRemoveBtn = urlInputsContainer.querySelector('.url-container button');
                     if(singleRemoveBtn) singleRemoveBtn.remove();
                 }

            }
        }


        function savePlaylist() {
             if (!playlistNameInput || !urlInputsContainer) return;
             const name = playlistNameInput.value.trim();

             if (!name) {
                 showConfirmation("Missing Name", "Please enter a name for this playlist.", false);
                 return;
             }

             const urlElements = urlInputsContainer.querySelectorAll(".youtube-url");
             const currentVideoIds = Array.from(urlElements)
                 .map(input => extractVideoId(input.value))
                 .filter(id => id);

             if (currentVideoIds.length === 0) {
                 showConfirmation("No Videos", "Add at least one valid YouTube URL to save the playlist.", false);
                 return;
             }

            // Check if playlist name already exists (overwrite confirmation?)
             const existingIndex = playlists.findIndex(p => p.name === name);
             if (existingIndex !== -1) {
                 showConfirmation(
                     "Overwrite Playlist?",
                     `A playlist named "${name}" already exists. Do you want to overwrite it?`,
                     true, // isCancellable
                     () => { // onConfirm overwrite
                         playlists[existingIndex] = { name: name, videoIds: currentVideoIds };
                         savePlaylistsToUserData();
                         populatePlaylistSelect(); // Refresh dropdown
                          playlistNameInput.value = ""; // Clear input field
                          showConfirmation("Playlist Saved", `Playlist "${name}" has been updated.`, false);
                     },
                     () => { console.log("Overwrite cancelled."); } // onCancel
                 );
             } else {
                  // Add new playlist
                  playlists.push({ name: name, videoIds: currentVideoIds });
                  savePlaylistsToUserData();
                  populatePlaylistSelect();
                  playlistNameInput.value = "";
                  showConfirmation("Playlist Saved", `Playlist "${name}" has been saved successfully.`, false);
             }
        }

        function removePlaylist() {
             if (!playlistSelect) return;
             const selectedName = playlistSelect.value;

             if (!selectedName) {
                 showConfirmation("No Selection", "Please select a playlist from the dropdown to remove.", false);
                 return;
             }

            showConfirmation(
                "Delete Playlist?",
                `Are you sure you want to delete the playlist "${selectedName}"? This cannot be undone.`,
                true, // isCancellable
                () => { // onConfirm delete
                    playlists = playlists.filter(p => p.name !== selectedName);
                    savePlaylistsToUserData();
                    populatePlaylistSelect(); // Refresh dropdown
                    playlistSelect.value = ""; // Reset selection
                     restoreUrlInputs(); // Clear URL inputs after deleting loaded playlist
                    showConfirmation("Playlist Deleted", `Playlist "${selectedName}" has been removed.`, false);
                },
                 () => { console.log("Deletion cancelled."); } // onCancel
            );
        }

        /** Saves the current `playlists` array to the logged-in user's data */
        function savePlaylistsToUserData() {
             if (isSignedIn && currentUser) {
                 try {
                     const users = JSON.parse(localStorage.getItem("users") || "{}");
                      if(users[currentUser]) {
                         users[currentUser].playlists = playlists;
                         localStorage.setItem("users", JSON.stringify(users));
                          console.log("Playlists saved for user:", currentUser);
                      }
                 } catch (err) {
                     console.error("Error saving playlists to user data:", err);
                 }
             }
        }

        function populatePlaylistSelect() {
            if (!playlistSelect) return;
            const currentSelection = playlistSelect.value; // Preserve selection if possible

            playlistSelect.innerHTML = '<option value="">Load Saved Playlist</option>'; // Clear and add default

            playlists.sort((a, b) => a.name.localeCompare(b.name)); // Sort alphabetically

            playlists.forEach(playlist => {
                const option = document.createElement("option");
                option.value = playlist.name;
                option.textContent = playlist.name;
                playlistSelect.appendChild(option);
            });

             playlistSelect.value = currentSelection; // Try to restore selection

            // Add onchange listener if not already added
            if (!playlistSelect.onchange) {
                 playlistSelect.onchange = handlePlaylistSelection;
            }
        }

        function handlePlaylistSelection() {
             if (!playlistSelect) return;
             const selectedName = playlistSelect.value;
             if (selectedName) {
                 const selectedPlaylist = playlists.find(p => p.name === selectedName);
                 if (selectedPlaylist) {
                      console.log("Loading playlist:", selectedName);
                      restoreUrlInputs(selectedPlaylist.videoIds); // Load URLs into inputs
                      if(playlistNameInput) playlistNameInput.value = selectedName; // Pre-fill name input for easy overwrite/save
                 }
             } else {
                  // "Load Saved Playlist" selected - clear inputs?
                  restoreUrlInputs(); // Clear URL inputs
                  if(playlistNameInput) playlistNameInput.value = "";
             }
        }


      // --- State Management ---

       /** Saves the current application state to localStorage */
       function saveState() {
           // Don't save if not signed in, to avoid overwriting guest state potentially
           // Or, save non-user-specific things separately? For now, only save for logged-in users.
           if (!isSignedIn || !currentUser) {
                // Clear potentially sensitive state if logged out?
                 // localStorage.removeItem('focusModeState'); // Example
                return;
           }

           const stateToSave = {
                // Session State (if active)
                videoIds: isFocusModeActive ? videoIds : [],
                currentVideoIndex: isFocusModeActive ? currentVideoIndex : 0,
                timerMode: isFocusModeActive ? timerMode : "Focus Time",
                timerRemaining: isFocusModeActive ? timerRemaining : focusDuration / 1000,
                isFocusModeActive: isFocusModeActive,
                completedVideos: isFocusModeActive ? Array.from(completedVideos) : [],
                allVideosCompleted: isFocusModeActive ? allVideosCompleted : false,

                // User Persistent State (also saved directly to user object)
                points: points,
                totalFocusTime: totalFocusTime,
                totalDistractions: totalDistractions, // Note: distraction tracking needs re-implementation if desired
                totalVideosWatched: totalVideosWatched,
                streakDays: streakDays,
                lastFocusDate: lastFocusDate,
                mysteryBoxCount: mysteryBoxCount,
                 activePowerUps: activePowerUps,
                 premiumLofiTrackState: premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked })), // Save unlock status

                // UI State
                 currentView: currentView, // Save the last active view
                 // Note: Saving tasks and playlists happens in their respective functions directly into the user object
           };

           try {
                // Save the general app state
                localStorage.setItem("focusModeState", JSON.stringify(stateToSave));

                // Update the specific user's object in localStorage as the primary source of truth
                const users = JSON.parse(localStorage.getItem("users") || "{}");
                 if (users[currentUser]) {
                     users[currentUser].points = points;
                     users[currentUser].totalFocusTime = totalFocusTime;
                     users[currentUser].totalDistractions = totalDistractions;
                     users[currentUser].totalVideosWatched = totalVideosWatched;
                     users[currentUser].streakDays = streakDays;
                     users[currentUser].lastFocusDate = lastFocusDate;
                     users[currentUser].mysteryBoxCount = mysteryBoxCount;
                     users[currentUser].activePowerUps = activePowerUps;
                     users[currentUser].premiumLofiTracks = premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked }));
                     // Tasks and Playlists are saved separately by their functions

                     localStorage.setItem("users", JSON.stringify(users));
                 }
                // console.log("State saved.");

           } catch (err) {
                console.error("Error saving state:", err);
                 // Handle potential storage quota exceeded errors
           }
       }


       /** Loads state from localStorage on page load */
       function loadSavedState() {
           console.log("Loading saved state...");
           // --- Load User Data (Primary Source) ---
           // Check if a user was previously logged in via a separate flag or check currentUser in state
            let lastUser = null;
            let loadedAppState = null;
            try {
                 loadedAppState = JSON.parse(localStorage.getItem("focusModeState") || "{}");
                 // Simple check to see if a user seemed to be logged in last session
                 // A more robust way would be a dedicated 'lastLogin' item
                 if (loadedAppState.points > 0 || loadedAppState.streakDays > 0) { // Infer logged in state
                      // Attempt to find the user associated with this state (needs improvement)
                      // For now, let's assume the state belongs to whoever tries to log in next,
                      // or implement a 'lastUser' saved item.
                      // Let's skip auto-login for simplicity now. User must sign in.
                 }
            } catch (err) {
                 console.error("Error parsing saved app state:", err);
                 localStorage.removeItem("focusModeState"); // Clear corrupted state
            }


            // --- Initial UI State ---
            showView('landingPage'); // Default to landing page
             updateClock(); // Start clock interval
             initAudio(); // Initialize audio elements
             if(pointsDisplay) pointsDisplay.innerHTML = `<span style="color: var(--secondary);">â­</span> XP: 0`; // Reset displays
             updateAchievementLevel();
             updateStreakDisplay();


            // --- Load Global Settings (If any) ---
            // Example: Load theme preference, volume, etc. if stored globally


            console.log("State loading complete. User needs to sign in.");
       }


        /** Checks for expired powerups, typically on login or page load */
        function checkExpiredPowerups() {
            let stateChanged = false;
            const now = Date.now();

            // Check Double Points
            if (activePowerUps.doublePoints.active && activePowerUps.doublePoints.expiry && now > activePowerUps.doublePoints.expiry) {
                 console.log("Double Points expired since last session.");
                 activePowerUps.doublePoints.active = false;
                 activePowerUps.doublePoints.expiry = null;
                 stateChanged = true;
                 // Optionally notify user on login?
                 // showConfirmation("Power-Up Expired", "Your Double XP power-up expired while you were away.", false);
            }

             // Check Streak Shield
            if (activePowerUps.streakShield.active && activePowerUps.streakShield.expiry && now > activePowerUps.streakShield.expiry) {
                 console.log("Streak Shield expired since last session.");
                 activePowerUps.streakShield.active = false;
                 activePowerUps.streakShield.expiry = null;
                 activePowerUps.streakShield.used = false; // Reset used flag
                 stateChanged = true;
                 // showConfirmation("Power-Up Expired", "Your Streak Shield faded while you were away.", false);
            }


            if (stateChanged) {
                 saveState(); // Save the updated powerup status
            }
        }


       // --- Utility Functions ---

       /** Requests fullscreen for an element */
       function requestFullscreen(element) {
           if (element.requestFullscreen) element.requestFullscreen().catch(err => console.warn("Fullscreen request failed:", err.message));
           else if (element.mozRequestFullScreen) element.mozRequestFullScreen(); // Firefox
           else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen(); // Chrome, Safari, Opera
           else if (element.msRequestFullscreen) element.msRequestFullscreen(); // IE/Edge
       }

       /** Exits fullscreen mode */
       function exitFullscreen() {
            if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                 if (document.exitFullscreen) document.exitFullscreen();
                 else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
                 else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                 else if (document.msExitFullscreen) document.msExitFullscreen();
            }
       }

        /** Shows a generic confirmation/alert dialog */
        function showConfirmation(title, message, isCancellable = false, onConfirm = () => {}, onCancel = () => {}) {
             const dialog = document.getElementById("confirmationDialog");
             const titleEl = dialog.querySelector("h3");
             const messageEl = dialog.querySelector("p");
             const confirmBtn = document.getElementById("confirmBtn");
             const cancelBtn = document.getElementById("cancelBtn");

            if (!dialog || !titleEl || !messageEl || !confirmBtn || !cancelBtn) return;

             titleEl.textContent = title;
             messageEl.textContent = message;

            // Configure buttons
             cancelBtn.style.display = isCancellable ? "inline-block" : "none"; // Show/hide cancel button

             // Remove previous listeners to prevent multiple triggers
             const newConfirmBtn = confirmBtn.cloneNode(true);
             confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
             const newCancelBtn = cancelBtn.cloneNode(true);
             cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);


            // Add new listeners
             newConfirmBtn.addEventListener('click', () => {
                 dialog.style.display = 'none';
                 onConfirm();
             });

             if (isCancellable) {
                 newCancelBtn.addEventListener('click', () => {
                     dialog.style.display = 'none';
                     onCancel();
                 });
             } else {
                 // If not cancellable, the confirm button just closes it
                 newConfirmBtn.textContent = "OK"; // Change button text
                 newConfirmBtn.onclick = () => { dialog.style.display = 'none'; onConfirm(); };
             }


             dialog.style.display = "flex";
        }

      // --- Event Listener Setup ---
      function setupEventListeners() {
        console.log("Setting up event listeners...");

        // --- Page Navigation ---
        document.querySelectorAll('button[data-action="show-view"]').forEach(button => {
            button.addEventListener('click', () => {
                const viewId = button.dataset.view;
                 if (viewId === 'signin' && isSignedIn) {
                    showView('homePage'); // Don't show signin if already logged in
                 } else if (viewId) {
                    showView(viewId);
                }
            });
        });

         // --- Sidebar ---
         if(sidebarTrigger) sidebarTrigger.addEventListener('click', toggleSidebar);
         // Close sidebar if clicking outside of it (optional)
         document.addEventListener('click', (event) => {
              if (!gameSidebar?.contains(event.target) && !sidebarTrigger?.contains(event.target) && isSidebarOpen) {
                  closeSidebar();
              }
         });


        // --- Authentication ---
        document.querySelector('button[data-action="sign-in"]')?.addEventListener('click', signIn);
        document.querySelector('button[data-action="create-account"]')?.addEventListener('click', createAccount);
        document.getElementById('logoutBtn')?.addEventListener('click', logout);

        // --- Home Page Actions ---
        document.querySelector('button[data-action="add-url"]')?.addEventListener('click', addUrlInput);
        document.querySelector('button[data-action="save-playlist"]')?.addEventListener('click', savePlaylist);
        document.querySelector('button[data-action="remove-playlist"]')?.addEventListener('click', removePlaylist);
        document.querySelector('button[data-action="start-playback"]')?.addEventListener('click', prepareAndStartPlayback);
         // Playlist select change is handled in populatePlaylistSelect

         // --- YouTube Page Actions ---
         document.getElementById('restartBtn')?.addEventListener('click', requestExitSession); // Changed behavior
         document.getElementById('pdfToggle')?.addEventListener('click', togglePDFViewer);
         document.getElementById('pdfInput')?.addEventListener('change', handlePDFUpload);
         if(videoSidebarToggleBtn) videoSidebarToggleBtn.addEventListener('click', toggleVideoSidebar);
         // Keyboard shortcut for video sidebar
         document.addEventListener('keydown', (e) => {
             // Avoid triggering when typing in inputs
             if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;
             if (currentView === 'youtubeLecturePage' && (e.key === 't' || e.key === 'T')) {
                 toggleVideoSidebar();
             }
         });


        // --- ToDo List ---
         document.querySelector('button[data-action="toggle-todo"]')?.addEventListener('click', toggleTodo);
         document.querySelector('button[data-action="save-tasks"]')?.addEventListener('click', saveTasks);
         document.querySelector('button[data-action="close-todo"]')?.addEventListener('click', toggleTodo); // Close button uses same toggle
         document.querySelector('button[data-action="add-task-line"]')?.addEventListener('click', () => {
             const newInp = addTaskLine();
             if(newInp) newInp.focus();
         });


        // --- Powerup/Store Buttons ---
        document.getElementById('streakShieldBtn')?.addEventListener('click', showStreakShieldDialog);
        document.getElementById('doublePointsBtn')?.addEventListener('click', showDoublePointsDialog);
        document.getElementById('audioStoreBtn')?.addEventListener('click', showAudioTracksStore);
        document.getElementById('quietPomodoroBtn')?.addEventListener('click', showPomodoroOverlay);

         // --- Dialog Confirm/Cancel Buttons ---
         // Generic Confirmation
         // Listeners are added dynamically in showConfirmation

         // Streak Shield
         document.getElementById('streakShieldConfirmBtn')?.addEventListener('click', () => handleStreakShieldConfirmation('yes'));
         document.getElementById('streakShieldCancelBtn')?.addEventListener('click', () => handleStreakShieldConfirmation('no'));
         // Double Points
         document.getElementById('doublePointsConfirmBtn')?.addEventListener('click', () => handleDoublePointsConfirmation('yes'));
         document.getElementById('doublePointsCancelBtn')?.addEventListener('click', () => handleDoublePointsConfirmation('no'));
          // Deadline
         document.getElementById('deadlineConfirmBtn')?.addEventListener('click', () => handleDeadlineConfirmation('yes'));
         document.getElementById('deadlineCancelBtn')?.addEventListener('click', () => handleDeadlineConfirmation('no'));
         // Session Complete
         document.getElementById('sessionContinueBtn')?.addEventListener('click', () => handleSessionContinue('continue'));
         document.getElementById('sessionEndBtn')?.addEventListener('click', () => handleSessionContinue('end'));
         // Mystery Box
         document.getElementById('openMysteryBox')?.addEventListener('click', openMysteryBox);
          document.getElementById('closeMysteryBoxBtn')?.addEventListener('click', closeMysteryBoxPopup);
         // Audio Store
         document.getElementById('closeAudioStore')?.addEventListener('click', closeAudioTracksStore);
         // PDF Close (handled inline for simplicity, can move here)
         // Pomodoro
         document.getElementById('pomodoroStartBtn')?.addEventListener('click', startPomodoro);
         document.getElementById('pomodoroResetBtn')?.addEventListener('click', resetPomodoro);
         document.getElementById('pomodoroCloseBtn')?.addEventListener('click', closePomodoroOverlay);


        // --- LoFi Player ---
        document.getElementById('lofiPlay')?.addEventListener('click', playLofi);
        document.getElementById('lofiPause')?.addEventListener('click', pauseLofi);
        document.getElementById('lofiPrev')?.addEventListener('click', prevLofi);
        document.getElementById('lofiNext')?.addEventListener('click', nextLofi);

        // --- AI Chatbot ---
        if(fireBox) fireBox.addEventListener('click', toggleAIPopup);

         // --- Timer Dragging ---
         if (timerDisplay) {
             let isDragging = false;
             let currentX, currentY, initialX, initialY;

            timerDisplay.addEventListener("mousedown", (e) => {
                // Prevent dragging if clicking on buttons inside the timer
                 if (e.target.tagName === 'BUTTON') return;
                 isDragging = true;
                 initialX = e.clientX - timerDisplay.offsetLeft;
                 initialY = e.clientY - timerDisplay.offsetTop;
                 timerDisplay.style.cursor = 'grabbing';
                 e.preventDefault(); // Prevent text selection during drag
            });

             document.addEventListener("mousemove", (e) => {
                 if (isDragging) {
                     e.preventDefault();
                     currentX = e.clientX - initialX;
                     currentY = e.clientY - initialY;

                     // Basic boundary checks (optional)
                      const maxX = window.innerWidth - timerDisplay.offsetWidth - 10;
                      const maxY = window.innerHeight - timerDisplay.offsetHeight - 10;
                      currentX = Math.max(10, Math.min(currentX, maxX));
                      currentY = Math.max(65, Math.min(currentY, maxY)); // Ensure it stays below top nav

                     timerDisplay.style.left = `${currentX}px`;
                     timerDisplay.style.top = `${currentY}px`;
                 }
             });

             document.addEventListener("mouseup", () => {
                 if (isDragging) {
                     isDragging = false;
                      timerDisplay.style.cursor = 'move';
                 }
             });
         }


        // --- Window Visibility Change --- (Distraction tracking - needs refinement)
        document.addEventListener("visibilitychange", () => {
          if (document.hidden && isFocusModeActive) {
            // distractionCount++; // Increment session distraction
            // totalDistractions++; // Increment lifetime distraction
             pauseLofi(); // Pause music when tab hidden
             // Maybe pause timer too? Depends on desired behavior.
             // if (countdownInterval) clearInterval(countdownInterval); // Example: Pause timer
             console.log("Tab hidden during focus session.");
             // saveState(); // Save distraction count if implemented
          } else if (!document.hidden && isFocusModeActive) {
             playLofi(); // Resume music when tab visible again
             // Resume timer if paused?
             // startTimer(timerRemaining * 1000, timerMode); // Example: Resume timer
             console.log("Tab visible during focus session.");
          }
        });

         // --- Save state before unloading ---
         window.addEventListener('beforeunload', () => {
             // Only save if logged in, otherwise state might be irrelevant
             if (isSignedIn && currentUser) {
                 // If focus mode is active, capture the current remaining time accurately
                 if (isFocusModeActive && countdownInterval) {
                     // timerRemaining is already updated each second by the interval
                 }
                 saveState();
                 console.log("State saved before unload.");
             }
         });


        console.log("Event listeners set up.");
      }

      // --- Initialization ---
      document.addEventListener("DOMContentLoaded", () => {
        console.log("DOM Loaded.");

        // Cache DOM elements
        topNavBar = document.getElementById('topNavBar');
        landingPage = document.getElementById('landingPage');
        signinForm = document.getElementById('signinForm');
        homePage = document.getElementById('homePage');
        youtubeLecturePage = document.getElementById('youtubeLecturePage');
        profilePage = document.getElementById('profilePage');
        focusStatsPage = document.getElementById('focusStatsPage');
        playerContainer = document.getElementById('playerContainer');
        playerDiv = document.getElementById('player');
        timerDisplay = document.getElementById('timerDisplay');
        timerText = document.getElementById('timerText');
        progressBar = document.getElementById('progressBar');
        progressFill = document.getElementById('progressFill');
        pointsDisplay = document.getElementById('pointsDisplay');
        achievementLevelDiv = document.getElementById('achievementLevel');
        lofiPlayer = document.getElementById('lofiPlayer');
        aiPopup = document.getElementById('aiPopup');
        fireBox = document.getElementById('fireBox');
        videoSidebar = document.getElementById('videoSidebar');
        videoThumbnailList = document.getElementById('videoThumbnailList');
        usernameInput = document.getElementById('username');
        passwordInput = document.getElementById('password');
        homeUsernameSpan = document.getElementById('homeUsername');
        dateTimeDisplaySpan = document.getElementById('dateTimeDisplay');
        focusStatusSpan = document.getElementById('focusStatus');
        playlistSelect = document.getElementById('playlistSelect');
        urlInputsContainer = document.getElementById('urlInputs');
        playlistNameInput = document.getElementById('playlistName');
        todoListPopup = document.getElementById('todoList');
        tasksContainer = document.getElementById('tasks');
        confirmationDialog = document.getElementById('confirmationDialog');
        streakShieldDialog = document.getElementById('streakShieldDialog');
        doublePointsDialog = document.getElementById('doublePointsDialog');
        deadlineDialog = document.getElementById('deadlineDialog');
        sessionCompleteDialog = document.getElementById('sessionCompleteDialog');
        mysteryBoxPopup = document.getElementById('mysteryBoxPopup');
        audioTracksStore = document.getElementById('audioTracksStore');
        pdfViewer = document.getElementById('pdfViewer');
        pomodoroOverlay = document.getElementById('pomodoroOverlay');
        gameSidebar = document.querySelector('.game-sidebar');
        sidebarTrigger = document.querySelector('.sidebar-trigger');
        navClockTime = document.getElementById('navClockTime');
        navClockPeriod = document.getElementById('navClockPeriod');
        topNavStreakBtn = document.getElementById('topNavStreakBtn');
         videoSidebarToggleBtn = document.getElementById('videoSidebarToggleBtn');


        loadSavedState(); // Load state first
        setupEventListeners(); // Then attach listeners
        setInterval(updateClock, 1000); // Start the main clock
        setInterval(checkTaskDeadlines, 60000); // Check deadlines every minute
         displayRandomMotivation(); // Show initial quote

        console.log("Initialization complete.");
      });

    })();
  </script>
</body>
</html>
