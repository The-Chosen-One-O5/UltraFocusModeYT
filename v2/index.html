```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Focus Mode YouTube Player</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #4169e1;
      --primary-dark: #1e3a8a;
      --secondary: #8e2de2;
      --accent: #ff4500;
      --accent-alt: #ff8c00;
      --bg-dark: #0f0f1b;
      --bg-medium: #1a1a2e;
      --bg-light: #252538;
      --text: #e0e0ff;
      --text-dim: #9090b0;
    }

    body {
      background-color: var(--bg-dark);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: monospace;
      color: var(--text);
      overflow: hidden;
      font-size: 18px;
      line-height: 1.4;
    }

    .game-container {
      width: 100%;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background-image: radial-gradient(circle at 10% 20%, rgba(142, 45, 226, 0.1) 0%, transparent 20%),
        radial-gradient(circle at 90% 80%, rgba(65, 105, 225, 0.1) 0%, transparent 20%),
        linear-gradient(to bottom, var(--bg-dark), var(--bg-medium));
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1;
    }

    .game-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' viewBox='0 0 6 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.05' fill-rule='evenodd'%3E%3Cpath d='M5 0h1L0 5v1H5V0zm1 5v1H5v-1h1z'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 2;
    }

    #landingPage,
    #signinForm,
    #inputForm {
      text-align: center;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding: 40px 20px;
      position: relative;
      z-index: 10;
      background-color: rgba(15, 15, 27, 0.8);
      border: 2px solid var(--secondary);
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(142, 45, 226, 0.3);
      pointer-events: auto;
    }

    .title {
      font-family: monospace;
      font-size: 32px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 20px;
      text-shadow: 3px 3px 0px var(--primary-dark);
      letter-spacing: 2px;
    }

    .title span {
      color: var(--secondary);
      position: relative;
      display: inline-block;
    }

    .title span::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
    }

    .subtitle {
      font-size: 20px;
      color: var(--text-dim);
      margin-bottom: 30px;
    }

    button {
      display: inline-block;
      padding: 12px 30px;
      font-size: 18px;
      font-family: monospace;
      font-weight: 600;
      background: var(--secondary);
      border: none;
      color: var(--text);
      border-radius: 0;
      cursor: pointer;
      margin: 0 10px 15px;
      transition: all 0.3s;
      position: relative;
      box-shadow: 4px 4px 0 var(--primary-dark);
      text-transform: uppercase;
      font-size: 14px;
      letter-spacing: 1px;
      z-index: 11;
      pointer-events: auto;
    }

    button:hover {
      background: var(--primary);
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 var(--primary-dark);
    }

    button:active {
      transform: translate(4px, 4px);
      box-shadow: none;
    }

    .github-btn {
      background: var(--bg-light);
      box-shadow: 4px 4px 0 var(--bg-medium);
    }

    .github-btn:hover {
      background: var(--bg-medium);
      box-shadow: 2px 2px 0 var(--bg-medium);
    }

    #features {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 40px;
      flex-wrap: wrap;
      z-index: 10;
    }

    .feature {
      background: var(--bg-light);
      padding: 15px 20px;
      border-radius: 0;
      width: 200px;
      box-shadow: 4px 4px 0 var(--bg-medium);
      border: 2px solid var(--primary);
      position: relative;
      overflow: hidden;
      z-index: 10;
    }

    .feature::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }

    .feature i {
      font-size: 24px;
      color: var(--secondary);
      margin-bottom: 10px;
    }

    .feature p {
      font-size: 16px;
      color: var(--text);
    }

    input,
    select {
      display: block;
      width: 100%;
      max-width: 320px;
      margin: 10px auto;
      padding: 12px;
      border-radius: 0;
      font-size: 16px;
      font-family: monospace;
      background: var(--bg-light);
      border: 2px solid var(--primary);
      color: var(--text);
      outline: none;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.2);
      z-index: 11;
      pointer-events: auto;
    }

    input:focus,
    select:focus {
      border-color: var(--secondary);
      box-shadow: 0 0 0 2px rgba(142, 45, 226, 0.3);
    }

    #inputForm {
      max-height: 80vh;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--secondary) var(--bg-medium);
    }

    #inputForm::-webkit-scrollbar {
      width: 8px;
    }

    #inputForm::-webkit-scrollbar-track {
      background: var(--bg-medium);
    }

    #inputForm::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 0;
      border: 2px solid var(--bg-medium);
    }

    #player {
      width: 100%;
      max-width: 1200px;
      aspect-ratio: 16 / 9;
      border-radius: 0;
      overflow: hidden;
      display: none;
      background: #000;
      border: 4px solid var(--primary);
      box-shadow: 0 0 20px rgba(65, 105, 225, 0.5);
      z-index: 5;
    }

    #timerDisplay {
      position: fixed;
      top: 10px;
      left: 10px;
      color: var(--text);
      font-size: 24px;
      z-index: 101;
      cursor: move;
      padding: 10px;
      background: var(--bg-medium);
      border: 2px solid var(--primary);
      font-family: monospace;
      font-size: 16px;
      pointer-events: auto;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      /* Ensure timer is hidden initially if focus not active */
      display: none;
    }

    #timerDisplay button {
      pointer-events: auto;
      padding: 5px 10px;
      margin: 0 5px;
      font-size: 12px;
      z-index: 102;
    }

    #pointsDisplay {
      position: fixed;
      top: 50px;
      left: 10px;
      font-size: 18px;
      color: var(--text);
      font-family: monospace;
      font-weight: 600;
      z-index: 101;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
      /* Ensure points are visible when logged in */
      display: none;
    }

    #clockDisplay {
      position: fixed;
      top: 90px;
      left: 10px;
      font-size: 20px;
      font-family: monospace;
      font-weight: bold;
      z-index: 101;
      padding: 8px 12px;
      background: var(--bg-medium);
      border: 2px solid var(--primary);
      display: none;
      pointer-events: none;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
    }

    #clockDisplay .time {
      color: var(--primary);
    }

    #clockDisplay .period {
      color: var(--secondary);
    }

    #progressBar {
      width: 200px;
      height: 10px;
      background: var(--bg-light);
      display: none;
      margin-top: 5px;
      border: 2px solid var(--primary);
      z-index: 101;
    }

    #progressFill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
    }

    #restartBtn {
      display: none;
      position: fixed;
      top: 10px;
      right: 10px;
      background: var(--accent);
      z-index: 103;
      pointer-events: auto;
    }

    #videoSidebar {
      position: fixed;
      right: -320px;
      top: 0;
      width: 300px;
      height: 100%;
      background: var(--bg-medium);
      transition: right 0.3s ease;
      padding: 20px;
      overflow-y: auto;
      z-index: 102;
      border-left: 4px solid var(--primary);
      pointer-events: auto;
    }

    .thumbnail {
      width: 100%;
      margin-bottom: 15px;
      cursor: pointer;
      border: 2px solid transparent;
      border-radius: 0;
      transition: all 0.3s;
      image-rendering: pixelated; /* Optional: for retro look */
      pointer-events: auto;
    }

    .thumbnail:hover {
      border-color: var(--secondary);
      transform: scale(1.05);
    }

    #minimizeBtn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: var(--accent);
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
      padding: 2px 6px;
      margin: 0;
      box-shadow: none;
      z-index: 102;
    }

    .url-container {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }

    .url-container button {
      margin-left: 10px;
      padding: 5px 10px;
      background: var(--accent);
      font-size: 14px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      z-index: 11;
    }

    #statsBtn,
    #todoBtn,
    #pyqBtn {
      padding: 8px 16px;
      font-size: 12px;
      margin: 0 5px 15px;
      z-index: 11;
    }

    #analytics,
    #todoList {
      position: absolute; /* Changed from fixed */
      left: 10px;
      background: var(--bg-medium);
      padding: 15px;
      border: 2px solid var(--secondary);
      display: none;
      z-index: 100;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: auto;
    }

    #analytics {
      top: 130px; /* Adjusted position relative to input form */
    }

    #todoList {
      top: 130px; /* Adjusted position relative to input form */
      width: 300px;
      max-height: 400px;
      /* Ensure it appears above analytics if both open? Adjust z-index if needed */
    }


    #tasks {
      overflow-y: auto;
      max-height: 320px;
      margin-bottom: 10px;
      background: none;
    }

    #analytics h3,
    #todoList h3 {
      font-size: 20px;
      margin-bottom: 10px;
      color: var(--secondary);
      font-family: monospace;
      font-size: 16px;
      text-align: center;
    }

    #analytics p {
      font-size: 16px;
      margin: 5px 0;
      border-bottom: 1px solid var(--bg-light);
      padding-bottom: 5px;
    }

    .task-line {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      background: var(--bg-light);
      padding: 5px;
      border: 1px solid var(--primary);
      pointer-events: auto; /* Ensure container allows events */
    }

    .task-line input[type="checkbox"] {
      margin-right: 10px;
      width: 16px;
      height: 16px;
      appearance: none;
      border: 2px solid var(--primary);
      background: var(--bg-medium);
      position: relative;
      cursor: pointer;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line input[type="checkbox"]:checked {
      background: var(--secondary);
    }

    .task-line input[type="checkbox"]:checked::after {
      content: "‚úì";
      position: absolute;
      color: var(--text);
      font-size: 12px;
      top: -2px;
      left: 2px;
    }

    .task-line input[type="text"] {
      flex-grow: 1;
      font-size: 16px;
      font-family: monospace;
      color: var(--text);
      background: transparent;
      border: none;
      border-bottom: 1px solid var(--text-dim);
      padding: 2px 0;
      outline: none;
      box-shadow: none;
      margin: 0;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line input[type="text"]:focus {
      border-bottom: 1px solid var(--secondary);
      box-shadow: none;
    }

    .task-line .remove-task {
      margin-left: 10px;
      color: var(--accent);
      font-size: 16px;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      line-height: 1;
      pointer-events: auto;
      z-index: 11;
    }

    .task-line .set-deadline {
      margin-left: 5px;
      color: var(--primary);
      font-size: 14px;
      cursor: pointer;
      background: none;
      border: none;
      padding: 2px 5px;
      border: 1px solid var(--primary);
      pointer-events: auto;
      z-index: 11;
    }

    .task-line .set-deadline:hover {
      background: var(--primary);
      color: var(--text);
    }

    .task-line .deadline-info {
      margin-left: 5px;
      font-size: 12px;
      color: var(--accent-alt);
    }

    .task-line .points-info {
      margin-left: 5px;
      font-size: 12px;
      color: var(--secondary);
    }

    #lofiPlayer {
      position: fixed;
      bottom: 10px;
      right: 10px;
      z-index: 101;
      display: none;
      background: var(--bg-medium);
      padding: 10px;
      border: 2px solid var(--primary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: auto;
    }

    #lofiPlayer button {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 5px 10px;
      margin: 0 2px;
      cursor: pointer;
      font-size: 12px;
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
      font-family: monospace;
      z-index: 102;
    }

    #achievementOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      color: gold;
      font-size: 32px;
      font-weight: bold;
      z-index: 104;
      display: none;
      font-family: monospace;
      text-align: center;
      text-shadow: 3px 3px 0 var(--primary-dark);
      background-image: url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%239C92AC' fill-opacity='0.1' fill-rule='evenodd'%3E%3Ccircle cx='3' cy='3' r='3'/%3E%3Ccircle cx='13' cy='13' r='3'/%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
    }

    #achievementLevel {
      position: fixed;
      top: 10px;
      right: 10px;
      font-size: 20px;
      font-weight: bold;
      z-index: 101;
      font-family: monospace;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
      /* Ensure visible when logged in */
      display: none;
    }

    #streakDisplay {
      position: fixed;
      top: 60px;
      right: 10px;
      font-size: 16px;
      color: var(--text);
      z-index: 101;
      background: var(--bg-medium);
      padding: 8px 12px;
      border: 2px solid var(--secondary);
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      pointer-events: none;
      font-family: monospace;
       /* Ensure visible when logged in */
      display: none;
    }

    .glow {
      text-shadow: 0 0 10px var(--text);
      animation: pulse 2s infinite;
    }

    .box-glow {
      border: 2px solid gold;
      padding: 5px;
      box-shadow: 0 0 10px gold;
      animation: pulse 2s infinite;
    }

    .rainbow {
      background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: rainbow 3s infinite;
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    #confirmationDialog,
    #streakShieldDialog,
    #doublePointsDialog,
    #deadlineDialog,
    #sessionCompleteDialog {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid var(--accent);
      box-shadow: 0 0 20px rgba(255, 69, 0, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
    }

    #confirmationDialog p,
    #streakShieldDialog p,
    #doublePointsDialog p,
    #deadlineDialog p,
    #sessionCompleteDialog p {
      font-size: 16px;
      margin-bottom: 20px;
    }

    #confirmationDialog button,
    #streakShieldDialog button,
    #doublePointsDialog button,
    #deadlineDialog button,
    #sessionCompleteDialog button {
      padding: 8px 20px;
      margin: 0 10px;
      font-size: 14px;
      pointer-events: auto;
      z-index: 106;
    }

    #confirmBtn,
    #streakShieldConfirmBtn,
    #doublePointsConfirmBtn,
    #deadlineConfirmBtn,
    #sessionContinueBtn {
      background: var(--accent);
    }

    #cancelBtn,
    #streakShieldCancelBtn,
    #doublePointsCancelBtn,
    #deadlineCancelBtn,
    #sessionEndBtn {
      background: var(--primary);
    }

    #deadlineDialog input,
    #deadlineDialog select {
      margin: 10px auto;
      width: 100%;
      max-width: 250px;
    }

    #pdfToggle {
      display: none;
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: var(--primary);
      z-index: 101;
      cursor: pointer;
      pointer-events: auto;
    }

    #pdfViewer {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      height: 500px;
      background: var(--bg-medium);
      padding: 15px;
      border: 4px solid var(--primary);
      box-shadow: 0 0 20px rgba(65, 105, 225, 0.5);
      z-index: 101;
      pointer-events: auto;
    }

    #pdfInput {
      margin-bottom: 10px;
      width: 100%;
      pointer-events: auto;
      z-index: 102;
    }

    #pdfFrame {
      width: 100%;
      height: 90%;
      border: none;
      background: #fff;
    }

    #fireBox {
      position: fixed;
      bottom: 10px;
      left: 10px;
      width: 40px;
      height: 40px;
      background: var(--primary);
      border-radius: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      cursor: pointer;
      z-index: 100;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      border: 2px solid var(--secondary);
      pointer-events: auto;
    }

    #fireBox:hover {
      background: var(--secondary);
      transform: translate(2px, 2px);
      box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
    }

    #aiPopup {
      position: fixed;
      bottom: 60px;
      left: 10px;
      width: 300px;
      height: 400px;
      background: var(--bg-medium);
      border-radius: 0;
      padding: 5px;
      display: none;
      z-index: 101;
      box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
      border: 4px solid var(--primary);
      pointer-events: auto;
    }

    #aiPopup iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    .game-sidebar {
      position: fixed;
      left: -250px;
      top: 0;
      width: 250px;
      height: 100vh;
      background: var(--bg-medium);
      border-right: 4px solid var(--primary);
      z-index: 200;
      transition: left 0.3s ease;
      padding: 20px 0;
      box-shadow: 4px 0 10px rgba(0, 0, 0, 0.3);
      overflow-y: auto;
      pointer-events: auto;
    }

    .sidebar-trigger:hover + .game-sidebar,
    .game-sidebar:hover {
      left: 0;
    }

    .sidebar-trigger {
      position: fixed;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 80px;
      background: var(--primary);
      z-index: 199;
      border-radius: 0 5px 5px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text);
      font-weight: bold;
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 12px;
      letter-spacing: 1px;
      pointer-events: auto;
    }

    .sidebar-section {
      padding: 15px;
      border-bottom: 2px solid var(--bg-dark);
    }

    .sidebar-section h3 {
      color: var(--secondary);
      font-size: 16px;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .sidebar-section a,
    .sidebar-section button {
      display: block;
      width: 100%;
      padding: 8px 10px;
      margin: 5px 0;
      background: var(--bg-light);
      color: var(--text);
      border: 1px solid var(--primary);
      text-align: left;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      pointer-events: auto;
      z-index: 201;
    }

    .sidebar-section a:hover,
    .sidebar-section button:hover {
      background: var(--primary);
      transform: translateX(5px);
    }

    .dashboard-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .dashboard-info p {
      font-size: 14px;
      display: flex;
      justify-content: space-between;
    }

    .dashboard-info p span:first-child {
      font-weight: bold;
      color: var(--primary);
    }

    #mysteryBoxPopup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid gold;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
      width: 300px;
    }

    #mysteryBoxPopup h3 {
      color: gold;
      font-size: 20px;
      margin-bottom: 15px;
    }

    #mysteryBoxPopup p {
      font-size: 16px;
      margin-bottom: 20px;
    }

    #mysteryBoxPopup button {
      padding: 8px 20px;
      background: var(--accent);
      font-size: 14px;
      pointer-events: auto;
    }

    /* Audio tracks store styles */
    #audioTracksStore {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 400px;
      max-height: 500px;
      background: var(--bg-medium);
      padding: 20px;
      border: 4px solid var(--secondary);
      box-shadow: 0 0 20px rgba(142, 45, 226, 0.5);
      z-index: 105;
      display: none;
      text-align: center;
      pointer-events: auto;
      font-family: monospace;
      overflow-y: auto;
    }

    #audioTracksStore h3 {
      color: var(--secondary);
      font-size: 20px;
      margin-bottom: 15px;
    }

    .audio-track-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px;
      margin-bottom: 10px;
      background: var(--bg-light);
      border: 1px solid var(--primary);
    }

    .audio-track-item.locked .track-name {
      color: var(--text-dim);
    }

    .audio-track-item.unlocked .track-name {
      color: var(--accent-alt);
    }

    .unlock-track-btn {
      padding: 5px 10px;
      background: var(--secondary);
      font-size: 12px;
      margin: 0; /* Reset margin */
    }

    .unlock-track-btn:disabled {
      background: var(--bg-light);
      color: var(--text-dim);
      cursor: not-allowed;
    }

     /* Quiet Pomodoro Styles */
    #quietPomodoroOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: rgba(15, 15, 27, 0.7); /* Semi-transparent background */
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px); /* For Safari */
      z-index: 250; /* High z-index */
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      flex-direction: column;
      pointer-events: auto;
    }

    #pomodoroTimerContainer {
      background-color: rgba(26, 26, 46, 0.9);
      padding: 40px;
      border: 4px solid var(--primary);
      box-shadow: 0 0 30px rgba(65, 105, 225, 0.6);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    #pomodoroModeDisplay {
      font-size: 24px;
      color: var(--secondary);
      font-weight: bold;
      letter-spacing: 1px;
    }

    #pomodoroTimeDisplay {
      font-size: 72px;
      font-weight: bold;
      color: var(--text);
      text-shadow: 2px 2px 0 var(--primary-dark);
      margin-bottom: 10px;
    }

    #pomodoroControls button {
       padding: 10px 25px;
       margin: 0 10px;
       font-size: 16px;
    }

    #pomodoroCloseBtn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: var(--accent);
        color: var(--text);
        border: none;
        font-size: 18px;
        cursor: pointer;
        padding: 5px 10px;
        box-shadow: 2px 2px 0 rgba(0, 0, 0, 0.3);
        z-index: 251; /* Above overlay content */
    }


    @media (max-width: 800px) {
      .title { font-size: 24px; }
      button { padding: 8px 16px; font-size: 12px; margin: 0 5px 10px; }
      #features { flex-direction: column; align-items: center; }
      .feature { width: 90%; max-width: 250px; }
      #timerDisplay, #pointsDisplay, #clockDisplay { font-size: 14px; padding: 5px 8px; }
      #achievementLevel, #streakDisplay { font-size: 14px; padding: 5px 8px; }
      #videoSidebar { width: 250px; }
      #lofiPlayer button { padding: 3px 6px; font-size: 10px; }
      #confirmationDialog, #streakShieldDialog, #doublePointsDialog { width: 90%; max-width: 300px; }
      #confirmationDialog p, #streakShieldDialog p, #doublePointsDialog p { font-size: 14px; }
      #pdfViewer { width: 90%; height: 80%; max-height: 500px; }
      #aiPopup { width: 90%; max-width: 300px; height: 350px; }
      #mysteryBoxPopup { width: 90%; max-width: 280px; }
      #audioTracksStore { width: 90%; max-width: 350px; }
       #pomodoroTimerContainer { padding: 20px; }
       #pomodoroTimeDisplay { font-size: 48px; }
       #pomodoroModeDisplay { font-size: 18px; }
       #pomodoroControls button { padding: 8px 15px; font-size: 14px; }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="sidebar-trigger">MENU</div>
    <div class="game-sidebar">
      <div class="sidebar-section">
        <h3>Dashboard</h3>
        <div class="dashboard-info">
          <p><span>Hero:</span> <span id="sidebarUsername">Guest</span></p>
          <p><span>Level:</span> <span id="sidebarLevel">Mortal</span></p>
          <p><span>XP:</span> <span id="sidebarXP">0</span></p>
          <p><span>Streak:</span> <span id="sidebarStreak">0 days</span></p>
        </div>
      </div>
      <div class="sidebar-section">
        <h3>Focus Tools</h3>
        <button id="quietPomodoroBtn">QUIET POMODORO</button>
        <a href="https://forestquest.vercel.app/" target="_blank" rel="noreferrer">FOREST QUEST - TASKS</a>
        <a href="https://focuswithpomodoro.netlify.app/" target="_blank" rel="noreferrer">POMODORO REALM</a>
        <a href="https://the-chosen-one-o5.github.io/Daily-Schedule/" target="_blank" rel="noreferrer">DAILY QUEST PLANNER</a>
      </div>
      <div class="sidebar-section">
        <h3>Shop</h3>
        <button id="streakShieldBtn">STREAK SHIELD</button>
        <button id="doublePointsBtn">DOUBLE POINTS</button>
        <button id="audioStoreBtn">AUDIO STORE</button>
      </div>
      <div class="sidebar-section">
        <h3>Account</h3>
        <button id="logoutBtn">LOGOUT</button>
      </div>
    </div>
    <div id="landingPage">
      <div class="title">QUEST FOR <span>FOCUS</span></div>
      <div class="subtitle">Begin your learning adventure!</div>
      <button data-action="start-game">START GAME</button>
      <button class="github-btn" data-action="github">GITHUB REPO</button>
      <div id="features">
        <div class="feature">
          <i class="fas fa-ad"></i>
          <p>Ad Free<br>No distractions on your quest</p>
        </div>
        <div class="feature">
          <i class="fas fa-moon"></i>
          <p>Dark Mode<br>Save your vision for the final boss</p>
        </div>
      </div>
    </div>

    <div id="signinForm" style="display: none;">
      <div class="title">ENTER THE <span>REALM</span></div>
      <div class="subtitle">Sign in or create your hero</div>
      <input type="text" id="username" placeholder="Hero Name" required />
      <input type="password" id="password" placeholder="Secret Code" required />
      <button data-action="sign-in">SIGN IN</button>
      <p>New adventurer? <button data-action="create-account">CREATE ACCOUNT</button></p>
    </div>

    <div id="inputForm" style="display: none;">
      <!-- Top right displays -->
      <div id="achievementLevel"></div>
      <div id="streakDisplay"></div>

      <!-- Action buttons -->
      <button id="todoBtn">TO-DO</button>
      <button id="statsBtn">HERO STATS</button>
      <button id="pyqBtn">TRAINING GROUNDS</button>

      <!-- Absolute positioned popups -->
      <div id="todoList">
        <h3>TO-DO LIST</h3>
        <div id="tasks">
          <!-- Task lines added dynamically -->
        </div>
        <button data-action="save-tasks">SAVE QUESTS</button>
      </div>

      <div id="analytics">
        <h3>HERO STATS</h3>
        <p>Focus Time: <span id="totalFocusTime">0</span> min</p>
        <p>Distractions Defeated: <span id="totalDistractions">0</span></p>
        <p>Videos Completed: <span id="totalVideosWatched">0</span></p>
      </div>

      <!-- Main content -->
      <div class="title">ENTER YOUR <span>YOUTUBE URL</span></div>
      <div class="subtitle">Add video or live stream links</div>
      <select id="playlistSelect">
        <option value="">Select a Saved Path</option>
      </select>
      <input type="text" id="playlistName" placeholder="Save Path As..." />
      <button data-action="save-playlist">SAVE PATH</button>
      <button data-action="remove-playlist">DELETE PATH</button>

      <div id="urlInputs">
        <div class="url-container">
          <input type="text" class="youtube-url" placeholder="YouTube URL (Video/Live/Shorts)" required />
          <!-- Remove button added dynamically for extra inputs -->
        </div>
      </div>

      <button data-action="add-url">ADD URL</button>
      <button data-action="start-playback">BEGIN FOCUS</button>
    </div>

    <!-- Player Area -->
    <div id="player" style="display: none;"></div>

    <!-- Fixed UI Elements for Focus Mode -->
    <div id="timerDisplay">
      <button id="minimizeBtn" title="Toggle Video Sidebar">-</button>
      <span id="timerText"></span>
      <div id="progressBar">
        <div id="progressFill"></div>
      </div>
    </div>

    <div id="pointsDisplay"><span style="color: #8e2de2;">‚≠ê</span> XP: 0</div>
    <div id="clockDisplay"></div>

    <button id="restartBtn" style="display: none;">EXIT FOCUS</button>

    <div id="videoSidebar">
      <button id="minimizeBtn">-</button>
      <!-- Thumbnails added dynamically -->
    </div>

    <!-- Fixed UI Elements always available when logged in -->
    <div id="lofiPlayer">
      <div style="text-align: center; margin-bottom: 5px;">LOFI MUSIC ‚ô¨</div>
      <button id="lofiPrev" title="Previous Track">‚óÑ</button>
      <button id="lofiPlay" title="Play">‚ñ∂</button>
      <button id="lofiPause" title="Pause">‚ùö‚ùö</button>
      <button id="lofiNext" title="Next Track">‚ñ∫</button>
    </div>

    <button id="pdfToggle">PDF UPLOAD</button>

    <div id="fireBox" title="AI Assistant">üßô</div>

    <!-- Overlays and Dialogs -->
    <div id="achievementOverlay"></div>

    <div id="confirmationDialog">
      <p>Are you sure you want to abandon your current focus quest?</p>
      <button id="confirmBtn">YES</button>
      <button id="cancelBtn">NO</button>
    </div>

    <div id="streakShieldDialog">
      <p>Are you sure you want to buy Streak Shield for 800 XP? (Protects streak for 1 week)</p>
      <button id="streakShieldConfirmBtn">BUY</button>
      <button id="streakShieldCancelBtn">CANCEL</button>
    </div>

    <div id="doublePointsDialog">
      <p>Are you sure you want to buy Double Points Power-Up for 800 XP? (Doubles points for 24 hours)</p>
      <button id="doublePointsConfirmBtn">BUY</button>
      <button id="doublePointsCancelBtn">CANCEL</button>
    </div>

    <div id="deadlineDialog">
      <h3>Set Task Deadline & Points</h3>
      <p>Set a deadline for your task to earn bonus points!</p>
      <input type="date" id="deadlineDate" />
      <input type="time" id="deadlineTime" />
      <select id="taskDifficulty">
        <option value="50">Easy (50 XP)</option>
        <option value="100">Medium (100 XP)</option>
        <option value="200">Hard (200 XP)</option>
        <option value="300">Very Hard (300 XP)</option>
      </select>
      <button id="deadlineConfirmBtn">SET DEADLINE</button>
      <button id="deadlineCancelBtn">CANCEL</button>
    </div>

    <div id="sessionCompleteDialog">
      <h3>Focus Session Complete!</h3>
      <p>Great work, hero! You've completed a focus session.</p>
      <p>Ready for another round? (+100 XP bonus)</p>
      <button id="sessionContinueBtn">CONTINUE (+100 XP)</button>
      <button id="sessionEndBtn">END SESSION</button>
    </div>

    <div id="pdfViewer">
      <input type="file" id="pdfInput" accept=".pdf" />
      <iframe id="pdfFrame"></iframe>
      <button onclick="togglePDFViewer()" style="background: var(--accent); margin-top: 10px;">CLOSE</button>
    </div>

    <div id="aiPopup">
      <iframe src="https://www.chatbase.co/chatbot-iframe/3dSdpryiYZlWipHUL8dNK" frameBorder="0"></iframe>
    </div>

    <div id="mysteryBoxPopup">
      <h3>Focus Mystery Box</h3>
      <p id="mysteryRewardText">Click to reveal your reward!</p>
      <button id="openMysteryBox">OPEN</button>
    </div>

    <div id="audioTracksStore">
      <h3>AUDIO TRACKS STORE</h3>
      <p>Unlock exclusive Lo-Fi tracks with your XP!</p>
      <div id="audioTracksList">
        <!-- Track items added dynamically -->
      </div>
      <button id="closeAudioStore" style="background: var(--accent); margin-top: 15px;">CLOSE</button>
    </div>

    <!-- Quiet Pomodoro Overlay -->
    <div id="quietPomodoroOverlay">
        <button id="pomodoroCloseBtn" title="Close Pomodoro">X</button>
        <div id="pomodoroTimerContainer">
            <div id="pomodoroModeDisplay">Work</div>
            <div id="pomodoroTimeDisplay">25:00</div>
            <div id="pomodoroControls">
                <button id="pomodoroStartBtn">START</button>
                <button id="pomodoroResetBtn">RESET</button>
            </div>
        </div>
    </div>

    <!-- Preload Audio -->
    <audio id="focusAudio" preload="auto" src="https://the-chosen-one-o5.github.io/UltraFocusModeYT/focus.mp3"></audio>
    <audio id="lofiAudio" preload="auto" loop></audio>
    <audio id="pomodoroCompleteAudio" preload="auto" src="https://www.dropbox.com/scl/fi/ihrcv1s3o4m4abhn6oa5z/level-up-4-243762.mp3?rlkey=qkaf4zrhipxtxpu51an0do45r&st=boipxpb5&dl=1"></audio>

  </div>

  <script>
    ;(() => {
      // --- State Variables ---
      let currentVideoIndex = 0;
      let player; // YouTube Player instance
      let videoIds = []; // Array of YouTube video IDs for current session
      let isFocusModeActive = false; // Is the main YouTube focus timer running?
      let countdownInterval; // Interval ID for the main focus timer
      let distractionCount = 0; // Distractions in current session (not heavily used)
      let points = 0; // User's XP
      let isSignedIn = false; // Is user logged in?
      let currentUser = null; // Logged-in username
      const focusDuration = 50 * 60 * 1000; // 50 minutes for main focus session
      // Break durations (kept for potential future use, currently using sessionCompleteDialog)
      // const firstBreakDuration = 15 * 60 * 1000;
      // const secondBreakDuration = 10 * 60 * 1000;
      let timerMode = "Focus Time"; // Current mode of the main timer
      let timerRemaining = focusDuration / 1000; // Remaining time in seconds for main timer
      let completedVideos = new Set(); // Set of completed video IDs in current session
      let allVideosCompleted = false; // Flag if all videos in the list were watched
      let totalFocusTime = 0; // Lifetime focus time in seconds
      let totalDistractions = 0; // Lifetime distractions counted
      let totalVideosWatched = 0; // Lifetime videos watched count
      let playlists = JSON.parse(localStorage.getItem("playlists") || "[]"); // User-saved playlists
      let tasks = []; // User's To-Do tasks (loaded on login)
      let previousPoints = 0; // Points before last update (for level up check)
      let streakDays = 0; // Current focus streak
      let lastFocusDate = null; // Date string of last focus session (from localStorage)
      let isYouTubeAPILoaded = false; // Flag for YouTube API load status
      let lofiAudio; // Reference to the lofi audio element
      let lofiSongs = []; // Array of available lofi song URLs (built dynamically)
      let currentLofiIndex = 0; // Index for current lofi track

      // Premium Audio Tracks Definition (with NEW URLs)
      const premiumLofiTracks = [
        { id: "track1", name: "Celestial Dreams", url: "https://www.dropbox.com/scl/fi/3xkks3j4tcmnloz46o03m/Kyle-Dixon-Michael-Stei-Kids.mp3?rlkey=6w97eurecqph68b8f2r7zn5pf&st=epeucz72&dl=1", unlocked: false, cost: 100 },
        { id: "track2", name: "Midnight Study", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=ui3kdsq5&dl=1", unlocked: false, cost: 100 },
        { id: "track3", name: "Rainy Day Focus", url: "https://www.dropbox.com/scl/fi/iaouozc1osse7h5ea9lon/thunder-chosic.com.mp3?rlkey=o7u0rarnh4kk657qhmcgyiolz&st=2r9f625j&dl=1", unlocked: false, cost: 100 },
        { id: "track4", name: "Epic Concentration", url: "https://www.dropbox.com/scl/fi/7vikjhsay7xayyab0tlvt/enchanted-metamorphosis-chronicles-264087.mp3?rlkey=mrdncvjr3g5bo8dksxywh9zxh&st=cq8j3dij&dl=1", unlocked: false, cost: 100 },
        // Keep track5 from original list if needed, or remove if replaced. Assuming replacement for now.
        // { id: "track5", name: "Zen Garden", url: "...", unlocked: false, cost: 100 },
      ];

      // Base free tracks (can be adjusted)
       const baseLofiSongs = [
        "https://www.dropbox.com/scl/fi/pe09xx1c680gzymsa2gdf/NEOTIC-Calm-Your-Anxiety.mp3?rlkey=2hp7su9j541mpcdkw4ccavx58&st=yles17dd&dl=1",
        "https://www.dropbox.com/scl/fi/lb5f47widcz8mwhg79jiz/Kate-Grove-SKYRIM-THEME-skyrim-elderscrolls-ocarina.mp3?rlkey=f8kpm1ipyowc1wv998myu06us&st=bm9qmodf&dl=1",
        "https://www.dropbox.com/scl/fi/8wf64nv0rwubt7hbs5x20/Kurate-Music-Best-of-Gibran-Alcocer-Beautiful-Piano-Mix.mp3?rlkey=i776feuxag0ebullqe0kjo0gp&st=bb3uyo3h&dl=1",
        "https://www.dropbox.com/scl/fi/7xoemzmrgq0wzbxc9i9tp/Jumping-_brick-Sidewalks-and-skeletons-goth-slowed-reverb-best-part-loop.mp3?rlkey=d4dt6rv6sdzteextqek29geug&st=4umnyp0c&dl=1",
        "https://www.dropbox.com/scl/fi/macw47c2kvur0yfi4r9up/St3phen-If-Youre-A-Gamer-This-Song-FOUND-You.mp3?rlkey=qudky54311tppavhvnpra89ff&st=7dgshk5k&dl=1",
        "https://www.dropbox.com/scl/fi/c1iy5yjmf3d57jrb1aokc/KestrelTapes-what-nostalgia-sounds-like...mp3?rlkey=qcdj1vpdnzwdb03fxp0vk0661&st=fyqrl6ge&dl=1",
        "https://www.dropbox.com/scl/fi/p303xk68pvu8sfrmtwzj2/rhawn-there-is-hopecore.mp3?rlkey=m6tva7g4dsva39ii1l0e8tnu0&st=6z218pii&dl=1",
        "https://www.dropbox.com/scl/fi/bw4n0ne8nli4dkp7p26po/Jaob-not-just-another-hopecore-playlist.mp3?rlkey=jy0umwkadkxj9cju1yf2wz7hw&st=yjxhzw0s&dl=1"
       ];

      let currentTaskForDeadline = null; // Element reference for deadline setting

      // Reminder feature variables
      let reminderInterval; // Interval ID for input form reminder
      let timeOnInputForm = 0; // Time spent on input form (in ms)
      const reminderIntervalTime = 20 * 60 * 1000; // 20 minutes interval
      const reminderThreshold = 20 * 60 * 1000; // 20 minutes threshold

      // Mystery Box and Power-Up feature variables
      let mysteryBoxCount = 0; // Number of unopened mystery boxes
      let activePowerUps = {
        doublePoints: { active: false, expiry: null },
        streakShield: { active: false, used: false, expiry: null },
      };
      const STREAK_SHIELD_COST = 800;
      const STREAK_SHIELD_DURATION = 7 * 24 * 60 * 60 * 1000; // 1 week
      const DOUBLE_POINTS_COST = 800;
      const DOUBLE_POINTS_DURATION = 24 * 60 * 60 * 1000; // 24 hours
      const MYSTERY_BOX_STREAK_INTERVAL = 14; // Earn box every 14 days streak
      const mysteryBoxRewards = [
        { type: "points", value: () => Math.floor(Math.random() * 451) + 50, message: (val) => `+${val} XP` },
        { type: "doublePoints", value: DOUBLE_POINTS_DURATION, message: () => "Double Points for 24 Hours" },
        { type: "streakShield", value: 1, message: () => "1-Use Streak Shield" },
      ];

      // Achievement Levels Definition
      const achievementLevels = [
         { points: 0, level: "Mortal", color: "white" },
         { points: 1000, level: "Soldier", color: "#4169E1" },
         { points: 2000, level: "Knight", color: "white", glow: true },
         { points: 3000, level: "KING", color: "#FF8C00", glow: true },
         { points: 4000, level: "GIGACHAD", color: "#FF4500", glow: true },
         { points: 5000, level: "Demigod", color: "gold", glow: true },
         { points: 6000, level: "Titan", color: "gold", glow: true, box: true },
         { points: 7000, level: "Immortal", color: "gold", glow: true, box: true, boxGlow: true },
         { points: 8000, level: "Celestial", color: "gold", glow: true, box: true, boxGlow: true },
         { points: 9000, level: "Divine", color: "rainbow" },
         { points: 10000, level: "Omnipotent", color: "rainbow", glow: true },
      ];

       // --- Quiet Pomodoro State Variables ---
       let isPomodoroActive = false; // Is the pomodoro timer running?
       let pomodoroMode = "Work"; // "Work" or "Break"
       const pomodoroWorkDuration = 25 * 60; // 25 minutes in seconds
       const pomodoroBreakDuration = 5 * 60; // 5 minutes in seconds
       let pomodoroTimeRemaining = pomodoroWorkDuration; // Time remaining in seconds
       let pomodoroInterval; // Interval ID for the pomodoro timer
       let pomodoroCompleteAudio; // Reference to the completion audio element


      // --- Initialization Functions ---
      function initAudio() {
          lofiAudio = document.getElementById("lofiAudio");
          pomodoroCompleteAudio = document.getElementById("pomodoroCompleteAudio");

          // Build the lofiSongs array dynamically based on unlocked tracks
          const unlockedPremiumUrls = premiumLofiTracks
              .filter(track => track.unlocked)
              .map(track => track.url);

          lofiSongs = [...new Set([...baseLofiSongs, ...unlockedPremiumUrls])]; // Combine base and unlocked, ensure uniqueness

          if (lofiAudio && lofiSongs.length > 0) {
              currentLofiIndex = currentLofiIndex % lofiSongs.length; // Ensure index is valid
              lofiAudio.src = lofiSongs[currentLofiIndex];
              console.log(`Initialized LoFi player with ${lofiSongs.length} tracks.`);
          } else if (lofiAudio) {
              console.warn("No LoFi songs available to initialize player.");
              lofiAudio.src = ''; // Clear source if no songs
          }

          // Ensure pomodoro audio exists
          if(!pomodoroCompleteAudio) {
              console.error("Pomodoro completion audio element not found!");
          }
      }

      // --- UI Update Functions ---
      function getAchievementLevel(currentPoints) {
        let currentLevel = achievementLevels[0]
        for (const level of achievementLevels) {
          if (currentPoints >= level.points) currentLevel = level
          else break
        }
        return currentLevel
      }

      function updateAchievementLevel() {
        const achievementDiv = document.getElementById("achievementLevel")
        if (!achievementDiv) return

        const level = getAchievementLevel(points);
        let baseStyle = `font-weight: bold; color: ${level.color};`; // Base styles
        achievementDiv.style = baseStyle; // Apply base styles first

        // Reset dynamic classes
        achievementDiv.classList.remove("rainbow", "glow", "box-glow");
        achievementDiv.style.border = ""; // Reset border
        achievementDiv.style.padding = ""; // Reset padding
        achievementDiv.style.boxShadow = ""; // Reset box shadow
        achievementDiv.style.textShadow = ""; // Reset text shadow

        // Apply conditional styles/classes
        if (level.glow) {
            achievementDiv.classList.add("glow");
             // Apply text-shadow directly if class doesn't cover it or for specificity
             achievementDiv.style.textShadow = `0 0 10px ${level.color === 'gold' ? 'gold' : 'var(--text)'}`;
        }
        if (level.box) {
            achievementDiv.style.border = `2px solid ${level.color === 'gold' ? 'gold' : 'var(--primary)'}`;
            achievementDiv.style.padding = "5px";
        }
        if (level.boxGlow) {
            achievementDiv.classList.add("box-glow");
             achievementDiv.style.boxShadow = `0 0 10px ${level.color === 'gold' ? 'gold' : 'var(--primary)'}`;
        }
        if (level.color === "rainbow") {
             achievementDiv.classList.add("rainbow");
             // Reset color style if rainbow class handles it via background-clip
             achievementDiv.style.color = "";
        }


        achievementDiv.innerHTML = level.level;
        updateSidebarDashboard(); // Update sidebar too
      }

      function showAchievementOverlay(level) {
        const overlay = document.getElementById("achievementOverlay")
        if (!overlay) return

        overlay.textContent = `LEVEL UP! ${level.toUpperCase()} UNLOCKED!`
        overlay.style.display = "flex"
        setTimeout(() => overlay.style.display = "none", 5000)
      }

      function updateClock() {
        const clockDisplay = document.getElementById("clockDisplay")
        if (!clockDisplay || clockDisplay.style.display === 'none') return; // Only update if visible

        const now = new Date()
        let hours = now.getHours()
        const minutes = now.getMinutes().toString().padStart(2, "0")
        const seconds = now.getSeconds().toString().padStart(2, "0")
        const period = hours >= 12 ? "PM" : "AM"
        hours = hours % 12 || 12
        hours = hours.toString().padStart(2, "0")
        clockDisplay.innerHTML = `<span class="time">${hours}:${minutes}:${seconds}</span> <span class="period">${period}</span>`
      }

      function updateStreak() {
          const streakDisplay = document.getElementById("streakDisplay");
          if (!streakDisplay) return;

          const today = new Date().toDateString();
          const lastDateStr = localStorage.getItem("lastFocusDate");
          let shouldUpdateStorage = false;
          let streakBroken = false;

          if (lastDateStr) {
              const last = new Date(lastDateStr);
              const diffTime = new Date(today).setHours(0, 0, 0, 0) - last.setHours(0, 0, 0, 0);
              const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

              if (diffDays === 1) {
                  streakDays++;
                  shouldUpdateStorage = true;
                  checkMysteryBoxMilestone(); // Check after incrementing
              } else if (diffDays > 1) {
                   streakBroken = true; // Mark as potentially broken
              } // else diffDays === 0 (same day) or diffDays < 0 (time travel?) - no change
          } else {
              // First focus session ever
              streakDays = 1;
              shouldUpdateStorage = true;
          }

          // Handle broken streak / shield usage
          if (streakBroken) {
              if (activePowerUps.streakShield.active && !activePowerUps.streakShield.used && Date.now() < activePowerUps.streakShield.expiry) {
                   activePowerUps.streakShield.used = true; // Consume the shield charge
                   streakDays++; // Preserve and increment streak
                   alert("Streak Shield protected your streak!");
                   shouldUpdateStorage = true; // Need to save shield status and streak
              } else {
                   // Reset streak if broken and no shield active/available
                   streakDays = 1; // Start new streak from today
                   shouldUpdateStorage = true;
              }
          }

          // Update local storage *only* if the streak was incremented or reset today
          if (shouldUpdateStorage) {
             localStorage.setItem("lastFocusDate", today);
             saveState(); // Save the potentially updated streakDays and shield status
          }

          // Update display
          streakDisplay.innerHTML = `<span style="color: #8e2de2;">üî•</span> ${streakDays} day${streakDays === 1 ? "" : "s"}`;
          updateSidebarDashboard();
      }


      function updateAnalytics() {
         document.getElementById("totalFocusTime").textContent = Math.floor(totalFocusTime / 60);
         document.getElementById("totalDistractions").textContent = totalDistractions;
         document.getElementById("totalVideosWatched").textContent = totalVideosWatched;
         updateSidebarDashboard();
      }

      function updateSidebarDashboard() {
        const sidebarUsername = document.getElementById("sidebarUsername")
        const sidebarLevel = document.getElementById("sidebarLevel")
        const sidebarXP = document.getElementById("sidebarXP")
        const sidebarStreak = document.getElementById("sidebarStreak")
        if (!sidebarUsername || !sidebarLevel || !sidebarXP || !sidebarStreak) return

        sidebarUsername.textContent = currentUser || "Guest";
        const levelData = getAchievementLevel(points);
        sidebarLevel.textContent = levelData.level;
        sidebarXP.textContent = points;
        sidebarStreak.textContent = `${streakDays} day${streakDays === 1 ? "" : "s"}`;
      }

      // --- Core Feature Logic ---

       function playLofi() {
          if (!lofiAudio || lofiSongs.length === 0) return;
          // Check if audio context needs resuming (required after user interaction)
          if (lofiAudio.paused && lofiAudio.readyState >= 2) { // Check if paused and ready
              lofiAudio.play().catch((err) => console.error("Lofi play error:", err));
          } else if (lofiAudio.src && lofiAudio.readyState === 0) {
              // If src is set but not loaded (e.g., after changing src), load it
              lofiAudio.load();
              lofiAudio.play().catch((err) => console.error("Lofi play after load error:", err));
          }
       }

       function pauseLofi() {
          if (!lofiAudio) return;
          lofiAudio.pause();
       }

       function prevLofi() {
          if (!lofiAudio || lofiSongs.length <= 1) return; // Need more than 1 song to cycle
          currentLofiIndex = (currentLofiIndex - 1 + lofiSongs.length) % lofiSongs.length;
          lofiAudio.src = lofiSongs[currentLofiIndex];
          playLofi();
          saveState(); // Save the current index if needed
       }

       function nextLofi() {
          if (!lofiAudio || lofiSongs.length <= 1) return;
          currentLofiIndex = (currentLofiIndex + 1) % lofiSongs.length;
          lofiAudio.src = lofiSongs[currentLofiIndex];
          playLofi();
          saveState(); // Save the current index if needed
       }


       function checkMysteryBoxMilestone() {
          // Check if streak is a multiple of the interval *and* greater than 0
          if (streakDays > 0 && streakDays % MYSTERY_BOX_STREAK_INTERVAL === 0) {
              mysteryBoxCount++;
              showMysteryBoxPopup();
              saveState(); // Save the incremented count immediately
          }
       }

       function showMysteryBoxPopup() {
          const popup = document.getElementById("mysteryBoxPopup");
          const rewardText = document.getElementById("mysteryRewardText");
          if (!popup || !rewardText) return;

          // Make sure the "Open" button is visible and the text is reset
          const openButton = document.getElementById("openMysteryBox");
          if(openButton) openButton.style.display = "inline-block"; // Ensure button is visible
          rewardText.textContent = `You earned a Focus Mystery Box! (${mysteryBoxCount} available)`;

          popup.style.display = "block";
       }

       function openMysteryBox() {
           if (mysteryBoxCount <= 0) return;

           const popup = document.getElementById("mysteryBoxPopup");
           const rewardText = document.getElementById("mysteryRewardText");
           const openButton = document.getElementById("openMysteryBox");
           if (!popup || !rewardText || !openButton) return;

           const reward = mysteryBoxRewards[Math.floor(Math.random() * mysteryBoxRewards.length)];
           let rewardValue = reward.value instanceof Function ? reward.value() : reward.value;
           let messagePrefix = "Reward: ";

           switch (reward.type) {
               case "points":
                   points += rewardValue;
                   break;
               case "doublePoints":
                    const nowDP = Date.now();
                    if (!activePowerUps.doublePoints.active || nowDP > activePowerUps.doublePoints.expiry) {
                        activePowerUps.doublePoints.active = true;
                        activePowerUps.doublePoints.expiry = nowDP + rewardValue;
                    } else {
                        activePowerUps.doublePoints.expiry += rewardValue; // Extend existing duration
                        messagePrefix = "Extended! ";
                    }
                    // Set timeout for expiry alert (optional)
                    setTimeout(() => {
                        if (activePowerUps.doublePoints.active && Date.now() >= activePowerUps.doublePoints.expiry) {
                            activePowerUps.doublePoints.active = false;
                            saveState();
                            // alert("Your Double Points Power-Up has expired!");
                        }
                    }, activePowerUps.doublePoints.expiry - nowDP + 1000);
                   break;
               case "streakShield":
                   // Grant one shield charge
                    if (!activePowerUps.streakShield.active || activePowerUps.streakShield.used || Date.now() >= activePowerUps.streakShield.expiry) {
                        // Only grant a new one if there isn't an active, unused one
                        activePowerUps.streakShield.active = true;
                        activePowerUps.streakShield.used = false;
                        activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION; // Give full duration for this charge
                         // Set timeout for expiry alert (optional)
                        setTimeout(() => {
                             if (!activePowerUps.streakShield.used && Date.now() >= activePowerUps.streakShield.expiry) {
                                 activePowerUps.streakShield.active = false;
                                 activePowerUps.streakShield.expiry = null;
                                 saveState();
                                 // alert("Your Streak Shield charge has expired!");
                             }
                        }, STREAK_SHIELD_DURATION + 1000);
                    } else {
                        messagePrefix = "Already Active: "; // Indicate they already had one
                    }
                   break;
           }

           rewardText.textContent = `${messagePrefix}${reward.message(rewardValue)}`;
           mysteryBoxCount--;
           document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
           openButton.style.display = "none"; // Hide button after opening

           saveState(); // Save changes immediately
           checkLevelUp(); // Check for level up due to points reward

           setTimeout(() => {
               if (mysteryBoxCount > 0) {
                   // If more boxes, reset the popup for the next one
                   showMysteryBoxPopup();
               } else {
                   popup.style.display = "none"; // Hide if no more boxes
               }
           }, 2500); // Show reward message for 2.5 seconds
       }

       function applyPowerUps(pointsEarned) {
           if (activePowerUps.doublePoints.active && Date.now() < activePowerUps.doublePoints.expiry) {
               console.log(`Double points applied: ${pointsEarned} * 2 = ${pointsEarned * 2}`);
               return pointsEarned * 2;
           }
           return pointsEarned;
       }


       function showStreakShieldDialog() {
          const dialog = document.getElementById("streakShieldDialog");
          if (!dialog) return;
          if (points < STREAK_SHIELD_COST) {
              alert(`Not enough XP! You need ${STREAK_SHIELD_COST} XP to buy a Streak Shield.`);
              return;
          }
          // Check if already active and not used
           if (activePowerUps.streakShield.active && !activePowerUps.streakShield.used && Date.now() < activePowerUps.streakShield.expiry) {
               alert("You already have an active Streak Shield charge!");
               return;
           }
          dialog.style.display = "block";
       }

       function handleStreakShieldConfirmation(choice) {
           const dialog = document.getElementById("streakShieldDialog");
           if (!dialog) return;

           dialog.style.display = "none";
           if (choice === "yes") {
               if (points >= STREAK_SHIELD_COST) {
                   points -= STREAK_SHIELD_COST;
                   // Grant one shield charge
                   activePowerUps.streakShield.active = true;
                   activePowerUps.streakShield.used = false;
                   activePowerUps.streakShield.expiry = Date.now() + STREAK_SHIELD_DURATION;

                   document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                   alert("Streak Shield activated! It will protect your next missed day within 1 week.");
                   saveState();

                   // Set timeout for expiry alert (optional)
                   setTimeout(() => {
                       if (!activePowerUps.streakShield.used && Date.now() >= activePowerUps.streakShield.expiry) {
                           activePowerUps.streakShield.active = false;
                           activePowerUps.streakShield.expiry = null;
                           saveState();
                            alert("Your purchased Streak Shield charge has expired!");
                       }
                   }, STREAK_SHIELD_DURATION + 1000);
               } else {
                   alert(`Not enough XP! You need ${STREAK_SHIELD_COST} XP.`); // Should have been caught by show dialog, but double check
               }
           }
       }

       function showDoublePointsDialog() {
          const dialog = document.getElementById("doublePointsDialog");
          if (!dialog) return;
          if (points < DOUBLE_POINTS_COST) {
              alert(`Not enough XP! You need ${DOUBLE_POINTS_COST} XP to buy Double Points.`);
              return;
          }
          dialog.style.display = "block";
       }

       function handleDoublePointsConfirmation(choice) {
           const dialog = document.getElementById("doublePointsDialog");
           if (!dialog) return;

           dialog.style.display = "none";
           if (choice === "yes") {
               if (points >= DOUBLE_POINTS_COST) {
                   points -= DOUBLE_POINTS_COST;
                   let message = "Double Points Power-Up activated for 24 hours!";
                   const now = Date.now();

                   if (activePowerUps.doublePoints.active && now < activePowerUps.doublePoints.expiry) {
                       // Extend duration
                       activePowerUps.doublePoints.expiry += DOUBLE_POINTS_DURATION;
                       message = `Double Points duration extended! Expires in ${Math.round((activePowerUps.doublePoints.expiry - now) / (60*60*1000))} hours.`;
                   } else {
                       // Activate new
                       activePowerUps.doublePoints.active = true;
                       activePowerUps.doublePoints.expiry = now + DOUBLE_POINTS_DURATION;
                   }

                   document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                   alert(message);
                   saveState();

                   // Set timeout for expiry alert (optional)
                   // Note: This only works if the browser tab stays open. Rely on checking expiry on point award.
                   setTimeout(() => {
                       if (activePowerUps.doublePoints.active && Date.now() >= activePowerUps.doublePoints.expiry) {
                           activePowerUps.doublePoints.active = false;
                           saveState();
                           alert("Your Double Points Power-Up has expired!");
                       }
                   }, activePowerUps.doublePoints.expiry - now + 1000);

               } else {
                   alert(`Not enough XP! You need ${DOUBLE_POINTS_COST} XP.`); // Double check
               }
           }
       }

      // --- Task Management ---
      function addTaskLine(taskData = { text: "", completed: false, deadline: null, points: null, deadlineChecked: false }) {
          const tasksDiv = document.getElementById("tasks");
          if (!tasksDiv) return null;

          const container = document.createElement("div");
          container.className = "task-line";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.className = "task-check";
          checkbox.checked = taskData.completed;
          checkbox.onchange = () => saveTasks(); // Save on check/uncheck

          const input = document.createElement("input");
          input.type = "text";
          input.className = "task-text";
          input.value = taskData.text;
          input.placeholder = "Add a quest...";
          input.onkeydown = (e) => {
              if (e.key === "Enter" && !e.shiftKey) { // Enter adds new task
                  e.preventDefault();
                  saveTasks(); // Save current task text first
                  const nextInput = addTaskLine(); // Add a new empty line
                  if (nextInput) nextInput.focus();
              }
          };
          input.onblur = () => saveTasks(); // Save when focus is lost

          const deadlineBtn = document.createElement("button");
          deadlineBtn.className = "set-deadline";
          deadlineBtn.textContent = "‚è∞";
          deadlineBtn.title = "Set Deadline & Points"; // Tooltip
          deadlineBtn.onclick = () => showDeadlineDialog(container);

          const removeBtn = document.createElement("span");
          removeBtn.className = "remove-task";
          removeBtn.textContent = "x";
          removeBtn.title = "Remove Task"; // Tooltip
          removeBtn.onclick = () => {
                if (tasksDiv.children.length > 1) { // Prevent removing the last line
                    tasksDiv.removeChild(container);
                    saveTasks(); // Save after removing
                } else {
                     // Clear the text of the last line instead of removing it
                     input.value = "";
                     checkbox.checked = false;
                     const deadlineInfo = container.querySelector(".deadline-info");
                     const pointsInfo = container.querySelector(".points-info");
                     if(deadlineInfo) deadlineInfo.remove();
                     if(pointsInfo) pointsInfo.remove();
                     saveTasks(); // Save the cleared state
                }
          };

          container.appendChild(checkbox);
          container.appendChild(input);
          container.appendChild(deadlineBtn); // Add deadline button

           // Add deadline/points info if it exists in taskData
           if (taskData.deadline) {
               try {
                  const deadlineDate = new Date(taskData.deadline);
                   // Check if date is valid before proceeding
                  if (!isNaN(deadlineDate.getTime())) {
                      const deadlineInfo = document.createElement("span");
                      deadlineInfo.className = "deadline-info";
                      deadlineInfo.textContent = `Due: ${deadlineDate.toLocaleDateString()} ${deadlineDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;
                      container.appendChild(deadlineInfo); // Append after deadline button

                      if(taskData.points) {
                          const pointsInfo = document.createElement("span");
                          pointsInfo.className = "points-info";
                          pointsInfo.textContent = `+${taskData.points}pts`;
                          container.appendChild(pointsInfo); // Append after deadline info
                      }
                  } else {
                       console.warn("Invalid deadline date found for task:", taskData.text);
                  }
               } catch (e) {
                   console.error("Error processing deadline date:", e);
               }
           }

          container.appendChild(removeBtn); // Append remove button last
          tasksDiv.appendChild(container);
          return input; // Return the input element for potential focus
      }

      function restoreTasks() {
          const tasksDiv = document.getElementById("tasks");
          if (!tasksDiv) return;

          tasksDiv.innerHTML = ""; // Clear existing task lines

          // Load tasks from the global 'tasks' variable (which should be populated on login)
          if (!tasks || tasks.length === 0) {
              // If no tasks are loaded, add one empty default task line
              addTaskLine();
          } else {
              // Restore tasks from the loaded data
              tasks.forEach((task) => {
                  // Ensure task object is valid before passing
                  if (task && typeof task === 'object') {
                     addTaskLine(task); // Use addTaskLine to create each row with its data
                  } else {
                     console.warn("Invalid task data found during restore:", task);
                  }
              });
          }

          // Check for any passed deadlines on load
          checkTaskDeadlines();
      }

      function saveTasks() {
          const taskLines = document.querySelectorAll("#tasks .task-line");
          const currentTasks = []; // Build a fresh array

          if (taskLines.length > 0) {
               taskLines.forEach(line => {
                   const checkbox = line.querySelector(".task-check");
                   const input = line.querySelector(".task-text");
                   const textValue = input ? input.value.trim() : "";
                   const completedValue = checkbox ? checkbox.checked : false;

                   // Only save tasks with text
                   if (textValue) {
                       // Find existing task data to preserve deadline/points/checked status
                       // This relies on the order remaining consistent, which it should
                       const index = Array.from(taskLines).indexOf(line);
                       const existingTaskData = tasks[index] || {};

                       currentTasks.push({
                           text: textValue,
                           completed: completedValue,
                           // Preserve existing metadata if not modified by dialogs
                           deadline: existingTaskData.deadline || null,
                           points: existingTaskData.points || null,
                           deadlineChecked: existingTaskData.deadlineChecked || false
                       });
                   }
               });
          }

          // If the list is now empty, add back the default empty task structure
          if (currentTasks.length === 0) {
              currentTasks.push({ text: "", completed: false, deadline: null, points: null, deadlineChecked: false });
               // If the UI also became empty, add the line back
               if (taskLines.length === 0) {
                   addTaskLine();
               } else if (taskLines.length === 1) {
                    // If the single line was just cleared, ensure its UI reflects the empty task
                    const input = taskLines[0].querySelector('.task-text');
                    const check = taskLines[0].querySelector('.task-check');
                    if(input) input.value = "";
                    if(check) check.checked = false;
                    taskLines[0].querySelector(".deadline-info")?.remove();
                    taskLines[0].querySelector(".points-info")?.remove();
               }
          }

          tasks = currentTasks; // Update the global tasks array

          // Save to localStorage and potentially user data
          saveState();
           // console.log("Tasks saved:", tasks);
      }


      function toggleTodo() {
        const todoList = document.getElementById("todoList")
        const analyticsList = document.getElementById("analytics");
        if (!todoList) return

        const isVisible = todoList.style.display === "block";
        todoList.style.display = isVisible ? "none" : "block";

        // Hide analytics if opening todo
        if (!isVisible && analyticsList) {
            analyticsList.style.display = "none";
        }

        // Ensure at least one task line exists when opening
        if (!isVisible) {
             const tasksDiv = document.getElementById("tasks");
             if (tasksDiv && tasksDiv.children.length === 0) {
                 addTaskLine(); // Add initial line if empty
             }
        }
      }

      function toggleAnalytics() {
        const analyticsList = document.getElementById("analytics");
        const todoList = document.getElementById("todoList");
        if (!analyticsList) return;

        const isVisible = analyticsList.style.display === "block";
        analyticsList.style.display = isVisible ? "none" : "block";

        // Hide todo list if opening analytics
        if (!isVisible && todoList) {
            todoList.style.display = "none";
        }
      }

      function showDeadlineDialog(taskElement) {
        const dialog = document.getElementById("deadlineDialog")
        if (!dialog) return
        
        currentTaskForDeadline = taskElement;
        // Find the corresponding task data
         const taskIndex = Array.from(document.querySelectorAll(".task-line")).indexOf(currentTaskForDeadline);
         const currentTaskData = tasks[taskIndex] || {};

        
        // Get UI elements
        const dateInput = document.getElementById("deadlineDate");
        const timeInput = document.getElementById("deadlineTime");
        const difficultySelect = document.getElementById("taskDifficulty");

        // Populate with existing data or defaults
        if (currentTaskData.deadline) {
            try {
               const deadline = new Date(currentTaskData.deadline);
               if (!isNaN(deadline.getTime())) {
                    dateInput.value = deadline.toISOString().split('T')[0];
                    timeInput.value = `${deadline.getHours().toString().padStart(2, '0')}:${deadline.getMinutes().toString().padStart(2, '0')}`;
               } else { throw new Error("Invalid date"); }
            } catch (e) {
                console.warn("Could not parse existing deadline, using defaults.", e);
                 // Set defaults if parsing fails
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                dateInput.value = tomorrow.toISOString().split('T')[0];
                const now = new Date();
                timeInput.value = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
            }
            difficultySelect.value = currentTaskData.points || 50;
        } else {
            // Set default date to tomorrow
            const tomorrow = new Date()
            tomorrow.setDate(tomorrow.getDate() + 1)
            dateInput.value = tomorrow.toISOString().split('T')[0]
            
            // Set default time to current time
            const now = new Date()
            timeInput.value = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`
            difficultySelect.value = 50; // Default difficulty
        }
                
        dialog.style.display = "block";
      }

      function handleDeadlineConfirmation(choice) {
        const dialog = document.getElementById("deadlineDialog");
        if (!dialog || !currentTaskForDeadline) return;

        dialog.style.display = "none"; // Hide dialog

        if (choice === "yes") {
            const dateInput = document.getElementById("deadlineDate").value;
            const timeInput = document.getElementById("deadlineTime").value;
            const difficultySelect = document.getElementById("taskDifficulty");
            const taskPoints = difficultySelect.value;

            if (!dateInput || !timeInput) {
                alert("Please select both date and time for the deadline.");
                currentTaskForDeadline = null; // Reset context
                return;
            }

            try {
                const deadlineDate = new Date(`${dateInput}T${timeInput}`);
                if (isNaN(deadlineDate.getTime())) {
                    throw new Error("Invalid date/time selected.");
                }

                // --- Update UI ---
                // Remove existing deadline info first
                currentTaskForDeadline.querySelector(".deadline-info")?.remove();
                currentTaskForDeadline.querySelector(".points-info")?.remove();

                // Add new deadline info elements
                const deadlineInfo = document.createElement("span");
                deadlineInfo.className = "deadline-info";
                deadlineInfo.textContent = `Due: ${deadlineDate.toLocaleDateString()} ${deadlineDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`;

                const pointsInfo = document.createElement("span");
                pointsInfo.className = "points-info";
                pointsInfo.textContent = `+${taskPoints}pts`;

                // Insert before the remove button
                const removeBtn = currentTaskForDeadline.querySelector(".remove-task");
                if (removeBtn) {
                    currentTaskForDeadline.insertBefore(deadlineInfo, removeBtn);
                    currentTaskForDeadline.insertBefore(pointsInfo, removeBtn);
                } else { // Fallback if remove button somehow missing
                    currentTaskForDeadline.appendChild(deadlineInfo);
                    currentTaskForDeadline.appendChild(pointsInfo);
                }

                // --- Update Data ---
                const taskIndex = Array.from(document.querySelectorAll(".task-line")).indexOf(currentTaskForDeadline);
                if (taskIndex !== -1 && tasks[taskIndex]) {
                    tasks[taskIndex].deadline = deadlineDate.getTime(); // Store timestamp
                    tasks[taskIndex].points = parseInt(taskPoints);
                    tasks[taskIndex].deadlineChecked = false; // Reset checked status
                    saveTasks(); // Save the updated tasks array
                } else {
                    console.error("Could not find task data to update deadline.");
                }

            } catch (error) {
                alert(error.message || "Invalid date or time selected.");
            }
        }

        currentTaskForDeadline = null; // Reset context
      }


      function checkTaskDeadlines() {
          const now = Date.now();
          let tasksUpdated = false;
          let pointsChanged = false;

          tasks.forEach((task, index) => {
              // Skip tasks without deadline, already checked, or somehow invalid
              if (!task || !task.deadline || task.deadlineChecked) return;

              if (now > task.deadline) {
                  // Deadline passed
                  const basePoints = parseInt(task.points) || 50; // Get points value

                  if (task.completed) {
                      // Task completed on time (assume completed before this check if checkbox is ticked)
                      const earnedPoints = applyPowerUps(basePoints);
                      points += earnedPoints;
                      console.log(`Task "${task.text}" deadline met! +${earnedPoints} XP`);
                      // Optional: Alert user
                      // alert(`Quest "${task.text}" completed on time! +${earnedPoints} XP`);
                      pointsChanged = true;
                  } else {
                      // Task not completed on time
                      const lostPoints = Math.floor(basePoints / 2);
                      points = Math.max(0, points - lostPoints); // Don't go below 0
                      console.log(`Task "${task.text}" deadline MISSED! -${lostPoints} XP`);
                       // Optional: Alert user
                       alert(`Quest "${task.text}" deadline missed! -${lostPoints} XP`);
                      pointsChanged = true;
                  }

                  // Mark as checked to prevent re-processing
                  tasks[index].deadlineChecked = true;
                  tasksUpdated = true;
              }
          });

          if (pointsChanged) {
              document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
              checkLevelUp(); // Check level up if points changed
          }

          if (tasksUpdated) {
              saveTasks(); // Save changes to task objects (deadlineChecked)
              // saveState(); // saveState is called within saveTasks implicitly
          }
      }

      // --- Playlist Management ---
      function addUrlInput() {
        const urlInputs = document.getElementById("urlInputs")
        if (!urlInputs) return

        const container = document.createElement("div")
        container.className = "url-container"
        
        const newInput = document.createElement("input")
        newInput.type = "text"
        newInput.className = "youtube-url"
        newInput.placeholder = "YouTube URL (Video/Live/Shorts)"
        
        const removeBtn = document.createElement("button")
        removeBtn.textContent = "X"
        removeBtn.title = "Remove URL"
        removeBtn.onclick = () => {
          // Only allow removal if it's not the last input field
          if (urlInputs.children.length > 1) {
              urlInputs.removeChild(container);
          } else {
              alert("You must have at least one URL input field.");
          }
        }
        
        container.appendChild(newInput)
        container.appendChild(removeBtn) // Add remove button next to the input
        urlInputs.appendChild(container)
        newInput.focus(); // Focus the newly added input field
      }

      function restoreUrlInputs() {
        const urlInputs = document.getElementById("urlInputs")
        if (!urlInputs) return

        urlInputs.innerHTML = "" // Clear existing inputs
        
        if (videoIds.length === 0) {
            // If no video IDs are loaded, show one empty input field
             addUrlInput(); // Use the function to create the initial input correctly
             // Ensure the first input doesn't have a remove button
             const firstRemoveBtn = urlInputs.querySelector('.url-container button');
             if(firstRemoveBtn) firstRemoveBtn.remove();

        } else {
            // Restore inputs based on loaded videoIds
            videoIds.forEach((id, index) => {
                const container = document.createElement("div");
                container.className = "url-container";
                
                const input = document.createElement("input");
                input.type = "text";
                input.className = "youtube-url";
                input.placeholder = "YouTube URL (Video/Live/Shorts)";
                // Reconstruct a plausible full URL for display
                input.value = id ? `https://www.youtube.com/watch?v=${id}` : "";
                container.appendChild(input);

                // Add remove button for all inputs if there's more than one initially
                 if (videoIds.length > 1) {
                    const removeBtn = document.createElement("button");
                    removeBtn.textContent = "X";
                    removeBtn.title = "Remove URL";
                    removeBtn.onclick = () => {
                        if (urlInputs.children.length > 1) {
                             urlInputs.removeChild(container);
                        } else {
                             alert("You must have at least one URL input field.");
                        }
                    };
                    container.appendChild(removeBtn);
                }
                 urlInputs.appendChild(container);
            });
             // If after restoring, there's only one input left, ensure it has no remove button
            if(urlInputs.children.length === 1) {
                 const firstRemoveBtn = urlInputs.querySelector('.url-container button');
                 if(firstRemoveBtn) firstRemoveBtn.remove();
            }
        }
      }

      function savePlaylist() {
          const playlistNameInput = document.getElementById("playlistName");
          const playlistName = playlistNameInput.value.trim();
          const urlInputs = document.querySelectorAll("#urlInputs .youtube-url");
          
          if (!playlistName) {
              alert("Please enter a name to save this path.");
              playlistNameInput.focus();
              return;
          }
          if (!urlInputs.length) return; // Should not happen if restoreUrlInputs works

          const urls = Array.from(urlInputs)
                           .map((input) => input.value.trim())
                           .filter((url) => url);

          if (!urls.length) {
              alert("Please add at least one valid YouTube URL to save.");
              return;
          }

          const videoIdsForPlaylist = urls.map((url) => extractVideoId(url)).filter((id) => id);

          if (videoIdsForPlaylist.length === 0) {
              alert("No valid YouTube video IDs found. Path not saved.");
              return;
          }

          // Overwrite confirmation
          const existingPlaylistIndex = playlists.findIndex(p => p.name === playlistName);
          if (existingPlaylistIndex !== -1) {
               if (!confirm(`A path named "${playlistName}" already exists. Overwrite it?`)) {
                   return; // User cancelled
               }
               playlists.splice(existingPlaylistIndex, 1); // Remove old one
          }

          playlists.push({ name: playlistName, videoIds: videoIdsForPlaylist });
          
          try {
             localStorage.setItem("playlists", JSON.stringify(playlists)); // Save updated list
             console.log(`Path "${playlistName}" saved.`);
          } catch (e) {
              console.error("Error saving playlists:", e);
              alert("Could not save path due to storage error.");
              return;
          }

          populatePlaylistSelect(); // Refresh dropdown
          
          // Select the newly saved playlist
          const playlistSelect = document.getElementById("playlistSelect");
          if(playlistSelect) playlistSelect.value = playlistName;

          playlistNameInput.value = ""; // Clear name input
          alert(`Path "${playlistName}" saved!`);
      }

      function removePlaylist() {
          const playlistSelect = document.getElementById("playlistSelect");
          const selectedName = playlistSelect.value;
          
          if (!selectedName) {
              alert("Please select a saved path from the dropdown to remove.");
              return;
          }

          if (!confirm(`Are you sure you want to delete the path "${selectedName}"?`)) {
              return; // User cancelled
          }

          const initialLength = playlists.length;
          playlists = playlists.filter((p) => p.name !== selectedName);

          if (playlists.length < initialLength) {
              try {
                  localStorage.setItem("playlists", JSON.stringify(playlists)); // Save updated list
                  console.log(`Path "${selectedName}" removed.`);
              } catch (e) {
                  console.error("Error removing playlist:", e);
                  alert("Could not remove path due to storage error.");
                  // Attempt to revert
                  playlists = JSON.parse(localStorage.getItem("playlists") || "[]");
                  populatePlaylistSelect();
                  return;
              }

              populatePlaylistSelect(); // Update dropdown
              
              // Clear inputs if the deleted playlist was loaded
               videoIds = [];
               restoreUrlInputs();
               document.getElementById("playlistName").value = ""; // Clear name input field
               alert(`Path "${selectedName}" deleted.`);

          } else {
               alert(`Could not find the path "${selectedName}" to delete.`);
          }
      }

      function populatePlaylistSelect() {
          const playlistSelect = document.getElementById("playlistSelect");
          if (!playlistSelect) return;

          const currentSelectedValue = playlistSelect.value; // Preserve selection

          playlistSelect.innerHTML = '<option value="">Select a Saved Path</option>'; // Default

          if(playlists && playlists.length > 0) {
              // Sort playlists alphabetically by name for better UX
              playlists.sort((a, b) => a.name.localeCompare(b.name));
              playlists.forEach((playlist) => {
                  const option = document.createElement("option");
                  option.value = playlist.name;
                  option.textContent = playlist.name;
                  playlistSelect.appendChild(option);
              });
          }

          // Restore selection if it still exists
           if (playlists.some(p => p.name === currentSelectedValue)) {
               playlistSelect.value = currentSelectedValue;
           } else {
                playlistSelect.value = ""; // Reset if previous selection deleted
           }

          // Ensure listener is attached (or use addEventListener once in DOMContentLoaded)
          playlistSelect.onchange = handlePlaylistSelection;
      }

      function handlePlaylistSelection() {
          const playlistSelect = document.getElementById("playlistSelect");
          const selectedName = playlistSelect.value;
          
          if (selectedName) {
              const selectedPlaylist = playlists.find((p) => p.name === selectedName);
              if (selectedPlaylist && selectedPlaylist.videoIds) {
                  console.log(`Loading path: "${selectedName}"`);
                  videoIds = selectedPlaylist.videoIds; // Load IDs
                  restoreUrlInputs(); // Update input fields
                  document.getElementById("playlistName").value = selectedName; // Pre-fill name for potential save/overwrite
              } else {
                   console.warn(`Selected path "${selectedName}" not found or invalid.`);
              }
          } else {
               // "Select a Saved Path" chosen - perhaps clear inputs?
               // videoIds = [];
               // restoreUrlInputs();
               document.getElementById("playlistName").value = "";
          }
      }

       // --- Premium Audio Store Logic ---
       function showAudioTracksStore() {
          const store = document.getElementById("audioTracksStore");
          const tracksList = document.getElementById("audioTracksList");
          if (!store || !tracksList) return;

          tracksList.innerHTML = ""; // Clear previous list

          // Ensure premium tracks data is up-to-date (it should be global)
          premiumLofiTracks.forEach(track => {
              const trackItem = document.createElement("div");
              trackItem.className = `audio-track-item ${track.unlocked ? 'unlocked' : 'locked'}`;

              const trackName = document.createElement("div");
              trackName.className = "track-name";
              trackName.textContent = track.name;

              const unlockBtn = document.createElement("button");
              unlockBtn.className = "unlock-track-btn";

              if (track.unlocked) {
                  unlockBtn.textContent = "UNLOCKED";
                  unlockBtn.disabled = true;
              } else {
                  unlockBtn.textContent = `UNLOCK (${track.cost} XP)`;
                  unlockBtn.disabled = points < track.cost; // Disable if not enough points
                  unlockBtn.onclick = () => unlockAudioTrack(track.id); // Use closure for track ID
              }

              trackItem.appendChild(trackName);
              trackItem.appendChild(unlockBtn);
              tracksList.appendChild(trackItem);
          });

          store.style.display = "block";
       }

       function closeAudioTracksStore() {
          const store = document.getElementById("audioTracksStore");
          if (store) store.style.display = "none";
       }

       function unlockAudioTrack(trackId) {
           const track = premiumLofiTracks.find(t => t.id === trackId);
           if (!track) {
               console.error("Track not found:", trackId);
               return;
           }
           if (track.unlocked) {
                console.warn("Track already unlocked:", trackId);
                return; // Already unlocked
           }
           if (points < track.cost) {
               alert("Not enough XP to unlock this track!");
               return; // Not enough points
           }

           // Deduct points and unlock
           points -= track.cost;
           track.unlocked = true; // Update the master definition
           console.log(`Unlocked track: "${track.name}"`);

           // Add to the playable lofiSongs array (ensure no duplicates)
           if (!lofiSongs.includes(track.url)) {
               lofiSongs.push(track.url);
               // Optional: Immediately switch to the new track?
               // currentLofiIndex = lofiSongs.length - 1;
               // lofiAudio.src = lofiSongs[currentLofiIndex];
               // playLofi();
               console.log(`Added "${track.name}" to playable tracks.`);
           }

           // Update UI
           document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
           alert(`Successfully unlocked "${track.name}"!`);

           // Refresh the store display
           showAudioTracksStore();
           saveState(); // Save the new points and track unlock status
       }


      // --- YouTube Player Logic ---
      function extractVideoId(url) {
        if (!url) return null;
        try {
          let videoId = null;
          // Handle full URLs (youtube.com/watch?v=...)
          if (url.includes("youtube.com/watch")) {
             videoId = new URL(url).searchParams.get("v");
          }
          // Handle short URLs (youtu.be/...)
          else if (url.includes("youtu.be/")) {
             videoId = url.split("youtu.be/")[1]?.split(/[?&]/)[0];
          }
          // Handle live URLs (youtube.com/live/...)
          else if (url.includes("/live/")) {
             videoId = url.split("/live/")[1]?.split(/[?&/]/)[0];
          }
           // Handle shorts URLs (youtube.com/shorts/...)
           else if (url.includes("/shorts/")) {
             videoId = url.split("/shorts/")[1]?.split(/[?&]/)[0];
          }
          // Handle embed URLs (youtube.com/embed/...)
          else if (url.includes("/embed/")) {
             videoId = url.split("/embed/")[1]?.split(/[?&]/)[0];
          }
           // Basic check for raw ID (11 chars, no slashes typical)
           else if (url.length === 11 && !url.includes('/') && !url.includes('.')) {
                videoId = url;
           }


          // Validate ID format (basic check)
          if (videoId && /^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
             return videoId;
          }

          console.warn("Could not extract valid video ID from URL:", url);
          return null;

        } catch (e) {
          console.error("Error parsing URL:", url, e);
          return null;
        }
      }

      function startPlayback() {
        try {
          const urlInputs = document.querySelectorAll("#urlInputs .youtube-url");
          if (!urlInputs.length) return;

          const urls = Array.from(urlInputs)
                           .map((input) => input.value.trim())
                           .filter((url) => url);

          if (!urls.length) {
            alert("Please enter at least one YouTube URL.");
            return;
          }

          videoIds = urls.map((url) => extractVideoId(url)).filter((id) => id);

          if (videoIds.length === 0) {
            alert("No valid YouTube video IDs found in the provided URLs.");
            return;
          }

          // Reset session state
          currentVideoIndex = 0;
          completedVideos.clear();
          allVideosCompleted = false;

          // Update UI for focus mode
          document.getElementById("inputForm").style.display = "none";
          document.getElementById("player").style.display = "block";
          document.getElementById("restartBtn").style.display = "block";
          document.getElementById("pdfToggle").style.display = "block"; // Show PDF toggle during focus
          document.getElementById("clockDisplay").style.display = "none"; // Hide clock
          document.getElementById("lofiPlayer").style.display = "none"; // Hide lofi player
          document.getElementById("timerDisplay").style.display = "block"; // Show focus timer
          stopReminderTimer(); // Stop input form reminder
          pauseLofi(); // Pause lofi music when video starts

          loadYouTubeAPI()
            .then(() => {
              setupYouTubePlayer(); // Setup player with the first video ID
              startTimer(focusDuration, "Focus Time"); // Start the main focus timer
              saveState(); // Save initial focus state
            })
            .catch((err) => {
              console.error("YouTube API load failed:", err);
              alert("Failed to load YouTube player. Please check connection and try again.");
              handleRestartConfirmation("yes"); // Reset UI if API fails critically
            });
        } catch (err) {
          console.error("Start playback error:", err);
          alert("An error occurred while starting playback.");
        }
      }

      function loadYouTubeAPI() {
          return new Promise((resolve, reject) => {
              if (typeof YT !== 'undefined' && YT.Player) {
                  isYouTubeAPILoaded = true; resolve(); return;
              }
              if (document.querySelector('script[src="https://www.youtube.com/iframe_api"]')) {
                    // Script exists, wait for YT object or callback
                   const checkYTReady = setInterval(() => {
                        if (typeof YT !== 'undefined' && YT.Player) {
                             clearInterval(checkYTReady);
                             isYouTubeAPILoaded = true; resolve();
                        }
                   }, 100);
                   // Define callback just in case it hasn't fired yet
                   window.onYouTubeIframeAPIReady = () => {
                         clearInterval(checkYTReady); // Ensure interval is cleared if callback fires
                         isYouTubeAPILoaded = true; resolve();
                   };
                   return;
              }

              console.log("Loading YouTube API script...");
              window.onYouTubeIframeAPIReady = () => { isYouTubeAPILoaded = true; resolve(); };
              const tag = document.createElement("script");
              tag.src = "https://www.youtube.com/iframe_api";
              tag.onerror = (error) => { reject(new Error("Failed to load YouTube API script")); };
              document.head.appendChild(tag);
          });
      }

      function setupYouTubePlayer() {
          if (!videoIds || videoIds.length === 0 || currentVideoIndex >= videoIds.length) {
               console.error("Cannot setup player: Invalid video IDs or index.");
               handleRestartConfirmation("yes"); return;
          }
          const playerDivId = "player";
          const playerDiv = document.getElementById(playerDivId);
          if (!playerDiv) { console.error("Player div not found."); return; }

          if (player && typeof player.destroy === 'function') { player.destroy(); player = null; }
          
          console.log(`Setting up player for ID: ${videoIds[currentVideoIndex]} (Index: ${currentVideoIndex})`);
          try {
              player = new YT.Player(playerDivId, {
                 // Height/width managed by CSS aspect-ratio on #player div
                 videoId: videoIds[currentVideoIndex],
                 playerVars: { 'autoplay': 1, 'controls': 1, 'modestbranding': 1, 'rel': 0, 'showinfo': 0, 'iv_load_policy': 3, 'fs': 1 },
                 events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange, 'onError': onPlayerError }
              });
              setupVideoSidebar(); // Update sidebar thumbnails
          } catch (error) {
               console.error("Error creating YT.Player:", error);
               alert("Could not create YouTube player.");
               handleRestartConfirmation("yes");
          }
      }

      function onPlayerReady(event) {
         console.log("Player ready.");
         event.target.playVideo(); // Ensure playback starts
      }

       function onPlayerStateChange(event) {
           const state = event.data;
           if (state === YT.PlayerState.ENDED) {
               console.log(`Video ended: ${videoIds[currentVideoIndex]}`);
               if (!completedVideos.has(videoIds[currentVideoIndex])) {
                   completedVideos.add(videoIds[currentVideoIndex]);
                   totalVideosWatched++;
                   const videoPoints = applyPowerUps(50); // Award points
                   points += videoPoints;
                   document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                   checkLevelUp();
                   updateAnalytics();
                   saveState();
               }

               currentVideoIndex++; // Move to next video

               if (currentVideoIndex < videoIds.length) {
                   console.log(`Loading next video: ${videoIds[currentVideoIndex]}`);
                   if (player && typeof player.loadVideoById === 'function') {
                       player.loadVideoById(videoIds[currentVideoIndex]);
                   } else {
                       console.error("Player invalid, cannot load next video.");
                       handleRestartConfirmation("yes");
                   }
               } else {
                   console.log("All videos completed.");
                   allVideosCompleted = true;
                   endFocusSession();
                   alert("Congratulations! You've completed all videos in this session.");
                   handleRestartConfirmation("yes"); // Return to input screen
               }
           }
           // Add other state handling if needed (e.g., PAUSED, PLAYING)
       }


       function onPlayerError(event) {
           console.error("YouTube Player Error:", event.data, `Video ID: ${videoIds[currentVideoIndex]}`);
           let errorMsg = `Player error (${event.data}). Skipping video.`;
           // Specific error messages can be added here based on event.data codes
           alert(errorMsg);

           // Attempt to skip to the next video
           currentVideoIndex++;
           if (currentVideoIndex < videoIds.length) {
                if (player && typeof player.loadVideoById === 'function') {
                   player.loadVideoById(videoIds[currentVideoIndex]);
                } else { handleRestartConfirmation("yes"); } // Cannot recover
           } else {
                // Error on the last video
                allVideosCompleted = true;
                endFocusSession();
                alert("Finished session due to error on the last video.");
                handleRestartConfirmation("yes");
           }
           saveState(); // Save state after handling error
       }

      function setupVideoSidebar() {
        const sidebar = document.getElementById("videoSidebar")
        if (!sidebar) return

        sidebar.innerHTML = '<button id="minimizeBtn" title="Toggle Video Sidebar">-</button>'; // Reset with button
        const minimizeBtn = sidebar.querySelector("#minimizeBtn");
        if (minimizeBtn) minimizeBtn.onclick = toggleVideoSidebar; // Re-attach listener


        if(!videoIds || videoIds.length === 0) {
           sidebar.style.right = "-320px"; return; // Hide if no videos
        }

        videoIds.forEach((id, index) => {
          const thumbnail = document.createElement("img")
          thumbnail.src = `https://img.youtube.com/vi/${id}/mqdefault.jpg`
          thumbnail.alt = `Video ${index + 1} Thumbnail`;
          thumbnail.className = "thumbnail"
          thumbnail.title = `Play Video ${index + 1}`;
          thumbnail.loading = "lazy";
          thumbnail.onclick = () => {
             if (player && typeof player.loadVideoById === 'function') {
                if (index !== currentVideoIndex) {
                    currentVideoIndex = index;
                    player.loadVideoById(id);
                    saveState();
                }
             }
          }
          sidebar.appendChild(thumbnail)
        });
        sidebar.style.right = "0"; // Show sidebar
      }

      function toggleVideoSidebar() {
        const sidebar = document.getElementById("videoSidebar")
        if (!sidebar) return
        sidebar.style.right = sidebar.style.right === "0px" ? "-320px" : "0px";
      }


      // --- Main Focus Timer Logic ---
      function startTimer(durationMs, mode) {
          const timerDisplay = document.getElementById("timerDisplay");
          const timerTextSpan = document.getElementById("timerText");
          const progressFill = document.getElementById("progressFill");
          const progressBar = document.getElementById("progressBar");
          if (!timerDisplay || !timerTextSpan || !progressFill || !progressBar) return;

          clearInterval(countdownInterval); // Clear existing timer

          isFocusModeActive = true;
          timerMode = mode;
          timerRemaining = Math.max(0, durationMs / 1000); // In seconds
          const totalDurationSeconds = durationMs / 1000;

          timerDisplay.style.display = "block"; // Ensure timer is visible
          progressBar.style.display = "block"; // Show progress bar

          if (mode === "Focus Time") {
               updateStreak(); // Update streak when starting focus
          }

          console.log(`Starting timer: ${mode}, Duration: ${timerRemaining}s`);

          countdownInterval = setInterval(() => {
              const minutes = Math.floor(timerRemaining / 60);
              const seconds = Math.floor(timerRemaining % 60);
              timerTextSpan.textContent = `${timerMode}: ${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;

              const progress = totalDurationSeconds > 0 ? ((totalDurationSeconds - timerRemaining) / totalDurationSeconds) * 100 : 0;
              progressFill.style.width = `${Math.min(100, progress)}%`;

              if (timerMode === "Focus Time") {
                  totalFocusTime++; // Increment lifetime focus time (seconds)
              }

              timerRemaining--;

              if (timerRemaining < 0) {
                  clearInterval(countdownInterval);
                  progressBar.style.display = "none";
                  console.log(`Timer finished: ${timerMode}`);

                  if (timerMode === "Focus Time") {
                      const focusPoints = applyPowerUps(100); // Points for focus session
                      points += focusPoints;
                      document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                      checkLevelUp();
                      updateAnalytics();
                      playFocusAudio();
                      showSessionCompleteDialog(); // Ask user to continue or end
                  }
                  // No automatic break start - handled by session complete dialog

                  saveState(); // Save state after cycle completion
              }
          }, 1000);
      }

       function playFocusAudio() {
           const audio = document.getElementById("focusAudio");
           if (audio) {
               audio.currentTime = 0; // Rewind before playing
               audio.play().catch(e => console.error("Focus audio play error:", e));
           }
       }


      function endFocusSession() {
          clearInterval(countdownInterval);
          isFocusModeActive = false;
          const timerDisplay = document.getElementById("timerDisplay");
          const timerTextSpan = document.getElementById("timerText");
          const progressBar = document.getElementById("progressBar");

          if(timerDisplay) timerDisplay.style.display = "none"; // Hide timer display
          if(progressBar) progressBar.style.display = "none";
          document.getElementById("progressFill").style.width = '0%';

          if (player && typeof player.stopVideo === 'function') {
               try { player.stopVideo(); } catch(e) {}
          }

          console.log("Focus session ended.");
          saveState(); // Save inactive state
          updateAnalytics();
      }

       function showSessionCompleteDialog() {
           const dialog = document.getElementById("sessionCompleteDialog");
           if (dialog) dialog.style.display = "block";
           // Optionally pause the player if it exists and is playing
           if (player && typeof player.pauseVideo === 'function' && player.getPlayerState() === YT.PlayerState.PLAYING) {
                player.pauseVideo();
           }
       }

       function handleSessionContinue(choice) {
           const dialog = document.getElementById("sessionCompleteDialog");
           if (!dialog) return;
           dialog.style.display = "none";

           if (choice === "continue") {
               const bonusPoints = applyPowerUps(100);
               points += bonusPoints;
               document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
               checkLevelUp();
               saveState();
               // Resume player if paused by dialog
               if (player && typeof player.playVideo === 'function' && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                    player.playVideo();
               }
               // Start a new focus timer cycle
               startTimer(focusDuration, "Focus Time");
           } else {
               // End the session - effectively means return to input screen
               endFocusSession(); // Clean up focus state
               handleRestartConfirmation("yes"); // Use restart logic to go back to input form
           }
       }

      function restartSession() {
        const dialog = document.getElementById("confirmationDialog")
        if (!dialog) return

        // Pause player and timer while confirming
        if (isFocusModeActive && player && typeof player.pauseVideo === 'function') {
            try { player.pauseVideo(); } catch(e) {}
        }
        if(countdownInterval) {
           clearInterval(countdownInterval); // Pause timer visually
        }
        dialog.style.display = "block"
      }

      function handleRestartConfirmation(choice) {
          const dialog = document.getElementById("confirmationDialog");
          if (!dialog) return;
          dialog.style.display = "none";

          if (choice === "yes") {
              console.log("Exiting focus mode / Restarting session...");
              clearInterval(countdownInterval); countdownInterval = null;
              isFocusModeActive = false;

              // Reset video state
              videoIds = []; currentVideoIndex = 0; completedVideos.clear(); allVideosCompleted = false;
              timerRemaining = focusDuration / 1000; timerMode = "Focus Time";

              // Destroy YouTube player
              if (player && typeof player.destroy === 'function') { try { player.destroy(); } catch (e) {} finally { player = null; } }
              const playerDiv = document.getElementById("player");
              if(playerDiv) { playerDiv.innerHTML = ""; playerDiv.style.display = "none"; }


              // Reset UI elements to 'Input Form' state
              document.getElementById("restartBtn").style.display = "none";
              document.getElementById("pdfToggle").style.display = "none";
              document.getElementById("videoSidebar").style.right = "-320px";
              document.getElementById("timerDisplay").style.display = "none"; // Hide timer
              const progressBar = document.getElementById("progressBar");
              if(progressBar) progressBar.style.display = "none";
              document.getElementById("progressFill").style.width = '0%';

              document.getElementById("inputForm").style.display = "block";
              if(isSignedIn) { // Only show these if logged in
                   document.getElementById("clockDisplay").style.display = "block";
                   document.getElementById("lofiPlayer").style.display = "block";
              }

              restoreUrlInputs(); // Reset URL inputs
              saveState(); // Save the reset state
              if(isSignedIn) startReminderTimer(); // Start reminder only if logged in and on input form
              playLofi(); // Optionally resume lofi if user wants

          } else {
               // User chose 'No', resume playback and timer
               console.log("Exit cancelled.");
               if (player && typeof player.playVideo === 'function' && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                   try { player.playVideo(); } catch (e) {}
               }
               // Resume timer only if it was active before confirmation
               if(timerRemaining >= 0 && !isFocusModeActive) { // Check if timer was paused by dialog
                  // Recalculate duration based on remaining time and restart
                  startTimer(timerRemaining * 1000, timerMode);
               }
          }
      }

      // --- Quiet Pomodoro Logic ---
      function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }

       function updatePomodoroDisplay() {
           const timeDisplay = document.getElementById("pomodoroTimeDisplay");
           const modeDisplay = document.getElementById("pomodoroModeDisplay");
           if (timeDisplay) timeDisplay.textContent = formatTime(pomodoroTimeRemaining);
           if (modeDisplay) modeDisplay.textContent = pomodoroMode; // Displays "Work" or "Break"
       }

       function showQuietPomodoro() {
           const overlay = document.getElementById("quietPomodoroOverlay");
           if (!overlay) return;

           console.log("Showing Quiet Pomodoro.");
           // Stop main focus mode if active
           if (isFocusModeActive) {
                clearInterval(countdownInterval);
                isFocusModeActive = false;
                document.getElementById("timerDisplay").style.display = 'none'; // Hide YT timer
                if (player && typeof player.pauseVideo === 'function') {
                    try{ player.pauseVideo(); } catch(e){}
                }
                console.log("Main focus mode paused for Pomodoro.");
           }
           pauseLofi(); // Pause lofi music

           // Reset Pomodoro state to start
           isPomodoroActive = false;
           pomodoroMode = "Work";
           pomodoroTimeRemaining = pomodoroWorkDuration;
           clearInterval(pomodoroInterval); // Ensure no previous interval running
           updatePomodoroDisplay();

           // Reset button states
           const startBtn = document.getElementById("pomodoroStartBtn");
           const resetBtn = document.getElementById("pomodoroResetBtn");
           if (startBtn) startBtn.disabled = false; startBtn.textContent = "START";
           if (resetBtn) resetBtn.disabled = true; // Reset initially disabled


           overlay.style.display = "flex"; // Show the overlay
       }

       function hideQuietPomodoro() {
           const overlay = document.getElementById("quietPomodoroOverlay");
           if (!overlay) return;

           if (isPomodoroActive) {
                if (!confirm("A Pomodoro timer is active. Are you sure you want to close it? Progress will be lost.")) {
                    return; // User cancelled closing
                }
           }

           console.log("Hiding Quiet Pomodoro.");
           clearInterval(pomodoroInterval); // Stop timer
           isPomodoroActive = false;
           overlay.style.display = "none"; // Hide the overlay

           // Decide whether to resume main focus or lofi?
           // For simplicity, let's not auto-resume. User can restart focus manually.
           // if (wasFocusModeActiveBeforePomodoro) { ... } // Requires another flag
           // playLofi(); // Or resume lofi?
       }


       function startPomodoroTimer() {
           if (isPomodoroActive) return; // Prevent multiple starts

           isPomodoroActive = true;
           console.log(`Starting Pomodoro: ${pomodoroMode}`);

           const startBtn = document.getElementById("pomodoroStartBtn");
           const resetBtn = document.getElementById("pomodoroResetBtn");
           if(startBtn) startBtn.disabled = true; // Disable start while running
           if(resetBtn) resetBtn.disabled = false; // Enable reset


           pomodoroInterval = setInterval(() => {
               pomodoroTimeRemaining--;
               updatePomodoroDisplay();

               if (pomodoroTimeRemaining < 0) {
                   clearInterval(pomodoroInterval);
                   isPomodoroActive = false;
                   if(startBtn) startBtn.disabled = false; // Re-enable start
                   // if(resetBtn) resetBtn.disabled = true; // Disable reset again? Or leave enabled?

                   console.log(`Pomodoro cycle finished: ${pomodoroMode}`);

                   if (pomodoroMode === "Work") {
                       // Play completion sound
                       if (pomodoroCompleteAudio) {
                            pomodoroCompleteAudio.currentTime = 0;
                            pomodoroCompleteAudio.play().catch(e=>console.error("Pomodoro audio error:", e));
                       }
                       // Award points (1 per minute of work cycle)
                       const workMinutes = pomodoroWorkDuration / 60;
                       const earnedPoints = applyPowerUps(workMinutes); // Apply potential double points
                       points += earnedPoints;
                       document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                       console.log(`Awarded ${earnedPoints} XP for Pomodoro work cycle.`);
                       checkLevelUp();
                       saveState();

                       // Switch to Break mode
                       pomodoroMode = "Break";
                       pomodoroTimeRemaining = pomodoroBreakDuration;
                       updatePomodoroDisplay();
                       alert("Work cycle complete! Time for a short break.");
                       // Automatically start the break timer? Yes.
                       startPomodoroTimer();

                   } else { // pomodoroMode === "Break"
                       // Switch back to Work mode
                       pomodoroMode = "Work";
                       pomodoroTimeRemaining = pomodoroWorkDuration;
                       updatePomodoroDisplay();
                       alert("Break's over! Ready for the next work cycle?");
                       // Do NOT auto-start work, let user click Start again.
                       if(startBtn) startBtn.disabled = false;
                       if(resetBtn) resetBtn.disabled = true; // Reset becomes disabled until started
                   }
               }
           }, 1000);
       }

       function resetPomodoroTimer() {
           clearInterval(pomodoroInterval);
           isPomodoroActive = false;
           pomodoroMode = "Work"; // Reset to work mode
           pomodoroTimeRemaining = pomodoroWorkDuration; // Reset time
           updatePomodoroDisplay();
           console.log("Pomodoro timer reset.");

           const startBtn = document.getElementById("pomodoroStartBtn");
           const resetBtn = document.getElementById("pomodoroResetBtn");
           if (startBtn) startBtn.disabled = false; startBtn.textContent = "START";
           if (resetBtn) resetBtn.disabled = true; // Reset is disabled until started
       }

      // --- Utility & Other Functions ---
       function checkLevelUp() {
           const currentLevelData = getAchievementLevel(previousPoints);
           const newLevelData = getAchievementLevel(points);
           if (newLevelData.level !== currentLevelData.level) {
               console.log(`Level Up! ${currentLevelData.level} -> ${newLevelData.level}`);
               showAchievementOverlay(newLevelData.level);
           }
           previousPoints = points; // Update baseline for next check
           updateAchievementLevel(); // Update display regardless
       }

      function togglePDFViewer() {
        const pdfViewer = document.getElementById("pdfViewer")
        if (!pdfViewer) return
        const isVisible = pdfViewer.style.display === "block";
        pdfViewer.style.display = isVisible ? "none" : "block";
        if (isVisible) {
            document.getElementById("pdfInput").value = null;
            document.getElementById("pdfFrame").src = 'about:blank';
        }
      }

      function handlePDFUpload(event) {
          const file = event.target.files[0];
          const pdfFrame = document.getElementById("pdfFrame");
          const pdfViewer = document.getElementById("pdfViewer");
          if (!pdfFrame || !pdfViewer) return;
          if (!file) { return; } // No file selected
          if (file.type !== "application/pdf") {
              alert("Please upload a valid PDF file (.pdf).");
              event.target.value = null; return;
          }
          try {
             const url = URL.createObjectURL(file);
             pdfFrame.src = url;
             pdfViewer.style.display = "block";
             // Consider revoking URL later, e.g., when closing viewer or loading new PDF
             // pdfFrame.addEventListener('load', () => URL.revokeObjectURL(url), { once: true }); // Example
          } catch (error) {
              console.error("Error handling PDF upload:", error);
              alert("Could not display the PDF file.");
              event.target.value = null; pdfFrame.src = 'about:blank';
          }
      }

      function toggleAIPopup() {
        const aiPopup = document.getElementById("aiPopup")
        if (!aiPopup) return
        aiPopup.style.display = aiPopup.style.display === "block" ? "none" : "block"
      }

      function redirectToPYQs() {
          window.open("https://room.examgoal.com/", "_blank");
      }


      // --- State Management (Save/Load) ---
      function saveState() {
          const state = {
              // Core gameplay state
              points, isFocusModeActive, timerMode, timerRemaining, currentVideoIndex, videoIds, completedVideos: Array.from(completedVideos), allVideosCompleted,
              // User profile state (partially managed here, also in user object)
              isSignedIn, currentUser, streakDays, mysteryBoxCount, activePowerUps,
               // User stats
              totalFocusTime, totalDistractions, totalVideosWatched,
              // Configuration / Unlockables
              premiumLofiTracks: premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked })),
              currentLofiIndex // Save current lofi track index
              // Note: 'tasks' and 'playlists' are saved separately or within the user object below
          };

          try {
             // Save general state (useful even if not logged in)
             localStorage.setItem("focusModeState", JSON.stringify(state));

             // Save user-specific data if logged in
             if (isSignedIn && currentUser) {
                const users = JSON.parse(localStorage.getItem("users") || "{}");
                if (users[currentUser]) {
                    users[currentUser] = {
                        ...users[currentUser], // Preserve password, etc.
                        points: points,
                        totalFocusTime: totalFocusTime,
                        totalDistractions: totalDistractions,
                        totalVideosWatched: totalVideosWatched,
                        tasks: tasks, // Save current tasks to user object
                        streakDays: streakDays,
                        mysteryBoxCount: mysteryBoxCount,
                        activePowerUps: activePowerUps,
                        premiumLofiTracks: premiumLofiTracks.map(t => ({ id: t.id, unlocked: t.unlocked })) // Save unlocks specific to user
                    };
                    localStorage.setItem("users", JSON.stringify(users));
                }
             }
              // console.log("State saved."); // Reduce console noise
          } catch (e) {
               console.error("Error saving state to localStorage:", e);
               // Optionally alert user if storage fails
               // alert("Warning: Could not save progress. Storage might be full.");
          }
      }

       function loadSavedState() {
           try {
               // Load global state first
               const savedGlobalState = localStorage.getItem("focusModeState");
               const state = savedGlobalState ? JSON.parse(savedGlobalState) : {};

               // Load user data if previously signed in according to state
               isSignedIn = state.isSignedIn || false;
               currentUser = state.currentUser || null;
               let userData = {};
               if (isSignedIn && currentUser) {
                    const users = JSON.parse(localStorage.getItem("users") || "{}");
                    userData = users[currentUser] || {}; // Get specific user data or empty object
                    console.log(`Loading state for user: ${currentUser}`);
               } else {
                   console.log("Loading state as Guest.");
               }

               // Restore variables, prioritizing user data if available
               points = userData.points ?? state.points ?? 0;
               previousPoints = points; // Sync for level check
               totalFocusTime = userData.totalFocusTime ?? state.totalFocusTime ?? 0;
               totalDistractions = userData.totalDistractions ?? state.totalDistractions ?? 0;
               totalVideosWatched = userData.totalVideosWatched ?? state.totalVideosWatched ?? 0;
               tasks = userData.tasks || []; // Load tasks from user data
               streakDays = userData.streakDays ?? state.streakDays ?? 0;
               lastFocusDate = localStorage.getItem("lastFocusDate"); // Always load global last date
               mysteryBoxCount = userData.mysteryBoxCount ?? state.mysteryBoxCount ?? 0;
               activePowerUps = userData.activePowerUps ?? state.activePowerUps ?? { doublePoints: { active: false, expiry: null }, streakShield: { active: false, used: false, expiry: null } };

               // Load premium track unlock status (prioritize user data)
               const trackUnlocks = userData.premiumLofiTracks || state.premiumLofiTracks;
               if (trackUnlocks) {
                    trackUnlocks.forEach(savedTrack => {
                        const track = premiumLofiTracks.find(t => t.id === savedTrack.id);
                        if (track) track.unlocked = savedTrack.unlocked;
                    });
               } else {
                    premiumLofiTracks.forEach(track => track.unlocked = false); // Default to locked if no data found
               }
               currentLofiIndex = state.currentLofiIndex || 0; // Restore lofi index
               initAudio(); // Initialize audio based on loaded unlocks


               // Restore focus session state if applicable
               isFocusModeActive = state.isFocusModeActive || false;
               videoIds = state.videoIds || [];
               currentVideoIndex = state.currentVideoIndex || 0;
               timerMode = state.timerMode || "Focus Time";
               timerRemaining = state.timerRemaining || focusDuration / 1000;
               completedVideos = new Set(state.completedVideos || []);
               allVideosCompleted = state.allVideosCompleted || false;

               // Update UI based on loaded state
               updateUIBasedOnState();


           } catch (err) {
               console.error("Load saved state error:", err);
               localStorage.removeItem("focusModeState"); // Clear potentially corrupted state
               localStorage.removeItem("users");
               alert("Error loading saved data. Resetting application state.");
               logout(); // Reset to default logged-out state
           }
       }

        function updateUIBasedOnState() {
            // Always hide progress bar initially
            const progressBar = document.getElementById("progressBar");
            if (progressBar) progressBar.style.display = "none";

            // Update displays common to logged-in state
            if (isSignedIn) {
                document.getElementById("pointsDisplay").innerHTML = `<span style="color: #8e2de2;">‚≠ê</span> XP: ${points}`;
                document.getElementById("pointsDisplay").style.display = 'block';
                document.getElementById("achievementLevel").style.display = 'block';
                document.getElementById("streakDisplay").style.display = 'block';
                document.getElementById("lofiPlayer").style.display = 'block';
                 document.getElementById("fireBox").style.display = 'flex'; // Show AI helper
                updateAchievementLevel();
                updateStreak(); // Recalculates based on loaded lastFocusDate
                updateAnalytics(); // Includes sidebar update
                populatePlaylistSelect();
                restoreTasks(); // Load user's tasks
                 if (mysteryBoxCount > 0) showMysteryBoxPopup();
            } else {
                 document.getElementById("pointsDisplay").style.display = 'none';
                 document.getElementById("achievementLevel").style.display = 'none';
                 document.getElementById("streakDisplay").style.display = 'none';
                 document.getElementById("lofiPlayer").style.display = 'none';
                 document.getElementById("fireBox").style.display = 'none';
                 updateSidebarDashboard(); // Show Guest
                 restoreTasks(); // Show default task line
            }


            // Handle view (Landing vs Input vs Focus)
            if (isFocusModeActive && videoIds.length > 0) {
                // Resume focus mode
                document.getElementById("landingPage").style.display = "none";
                document.getElementById("signinForm").style.display = "none";
                document.getElementById("inputForm").style.display = "none";
                document.getElementById("player").style.display = "block";
                document.getElementById("restartBtn").style.display = "block";
                document.getElementById("pdfToggle").style.display = "block";
                document.getElementById("clockDisplay").style.display = "none";
                document.getElementById("lofiPlayer").style.display = "none"; // Hide lofi during YT focus
                document.getElementById("timerDisplay").style.display = "block"; // Show YT timer
                stopReminderTimer();

                // Load API, setup player, and restart timer
                loadYouTubeAPI()
                    .then(() => {
                        setupYouTubePlayer();
                        startTimer(timerRemaining * 1000, timerMode); // Resume timer
                    })
                    .catch((err) => {
                        console.error("Failed to resume YouTube player:", err);
                        alert("Failed to resume focus session. Please restart.");
                        handleRestartConfirmation("yes"); // Force back to input
                    });

            } else if (isSignedIn) {
                // Show input form (already handled by isSignedIn block above)
                document.getElementById("landingPage").style.display = "none";
                document.getElementById("signinForm").style.display = "none";
                document.getElementById("inputForm").style.display = "block";
                document.getElementById("clockDisplay").style.display = "block";
                document.getElementById("player").style.display = "none"; // Ensure player hidden
                document.getElementById("restartBtn").style.display = "none";
                document.getElementById("pdfToggle").style.display = "none"; // Hide PDF toggle on input screen
                document.getElementById("timerDisplay").style.display = "none"; // Hide YT timer
                restoreUrlInputs(); // Ensure URL inputs are ready
                startReminderTimer(); // Start reminder for input form

            } else {
                // Show landing page (not signed in, not focusing)
                document.getElementById("landingPage").style.display = "block";
                document.getElementById("signinForm").style.display = "none";
                document.getElementById("inputForm").style.display = "none";
                document.getElementById("clockDisplay").style.display = "none";
                document.getElementById("player").style.display = "none";
                document.getElementById("restartBtn").style.display = "none";
                document.getElementById("pdfToggle").style.display = "none";
                document.getElementById("timerDisplay").style.display = "none";
                stopReminderTimer();
            }
        }


      // --- Authentication ---
      function showSignIn() {
          document.getElementById("landingPage").style.display = "none";
          document.getElementById("signinForm").style.display = "block";
          document.getElementById("inputForm").style.display = "none";
          document.getElementById("clockDisplay").style.display = "none";
          document.getElementById("lofiPlayer").style.display = "none";
           document.getElementById("pointsDisplay").style.display = 'none';
           document.getElementById("achievementLevel").style.display = 'none';
           document.getElementById("streakDisplay").style.display = 'none';
           document.getElementById("fireBox").style.display = 'none';
          stopReminderTimer();
      }

      function signIn() {
        try {
          const usernameInput = document.getElementById("username");
          const passwordInput = document.getElementById("password");
          const username = usernameInput.value.trim();
          const password = passwordInput.value;

          if (!username || !password) { alert("Please enter Hero Name and Secret Code."); return; }

          const users = JSON.parse(localStorage.getItem("users") || "{}");

          if (users[username] && users[username].password === password) {
             // --- Successful Login ---
             console.log(`Signing in as ${username}`);
             currentUser = username;
             isSignedIn = true;
             const userData = users[username];

             // Load user data into global state
             points = userData.points || 0; previousPoints = points;
             totalFocusTime = userData.totalFocusTime || 0;
             totalDistractions = userData.totalDistractions || 0;
             totalVideosWatched = userData.totalVideosWatched || 0;
             tasks = userData.tasks || [];
             streakDays = userData.streakDays || 0;
             lastFocusDate = localStorage.getItem("lastFocusDate"); // Get global date
             mysteryBoxCount = userData.mysteryBoxCount || 0;
             activePowerUps = userData.activePowerUps || { doublePoints: { active: false, expiry: null }, streakShield: { active: false, used: false, expiry: null } };

             // Load user's track unlocks
             const userTracks = userData.premiumLofiTracks;
             if (userTracks) {
                  userTracks.forEach(savedTrack => {
                      const track = premiumLofiTracks.find(t => t.id === savedTrack.id);
                      if (track) track.unlocked = savedTrack.unlocked;
                  });
             } else { premiumLofiTracks.forEach(track => track.unlocked = false); } // Reset if no data
             initAudio(); // Rebuild song list


             // Update UI
             updateUIBasedOnState(); // Central function to set UI visibility/content

             saveState(); // Save the new logged-in status

             // Clear password field
             passwordInput.value = "";

          } else {
              alert("Invalid Hero Name or Secret Code.");
              passwordInput.value = ""; // Clear password on failure
          }
        } catch (err) {
          console.error("Sign-in error:", err)
          alert("Error during sign-in. Please try again.")
        }
      }

      function createAccount() {
        try {
          const usernameInput = document.getElementById("username");
          const passwordInput = document.getElementById("password");
          const username = usernameInput.value.trim();
          const password = passwordInput.value;

           if (!username || !password) { alert("Please enter both Hero Name and Secret Code."); return; }
           if (password.length < 4) { alert("Secret Code must be at least 4 characters."); return; }

          const users = JSON.parse(localStorage.getItem("users") || "{}");

          if (users[username]) {
              alert("Hero Name already exists. Please choose another.");
          } else {
             // --- Create New User ---
             console.log(`Creating account for ${username}`);
             users[username] = {
                password: password, // Store password (consider hashing in production)
                points: 0, totalFocusTime: 0, totalDistractions: 0, totalVideosWatched: 0,
                tasks: [], streakDays: 0, mysteryBoxCount: 0,
                activePowerUps: { doublePoints: { active: false, expiry: null }, streakShield: { active: false, used: false, expiry: null } },
                premiumLofiTracks: premiumLofiTracks.map(t => ({ id: t.id, unlocked: false })) // Start all locked
             };
             localStorage.setItem("users", JSON.stringify(users));

             // --- Auto Sign In ---
             currentUser = username;
             isSignedIn = true;

             // Reset global state for new user
             points = 0; previousPoints = 0; totalFocusTime = 0; totalDistractions = 0; totalVideosWatched = 0;
             tasks = []; streakDays = 0; mysteryBoxCount = 0;
             activePowerUps = { doublePoints: { active: false, expiry: null }, streakShield: { active: false, used: false, expiry: null } };
             lastFocusDate = null; // No focus history yet
             localStorage.removeItem("lastFocusDate"); // Clear global date too
             premiumLofiTracks.forEach(track => track.unlocked = false); // Reset in-memory tracks
             initAudio(); // Initialize audio with base tracks

             // Update UI
             updateUIBasedOnState();

             saveState(); // Save initial state for new user

             // Clear form
             usernameInput.value = "";
             passwordInput.value = "";

             alert(`Account "${username}" created successfully! Welcome!`);
          }
        } catch (err) {
          console.error("Account creation error:", err);
          alert("Error creating account. Please try again.");
        }
      }

      function logout() {
          console.log("Logging out...");
          if (isSignedIn && currentUser) {
             saveState(); // Save current user's progress before logging out
          }

          // Reset global state variables
          isSignedIn = false; currentUser = null;
          points = 0; previousPoints = 0; totalFocusTime = 0; totalDistractions = 0; totalVideosWatched = 0;
          tasks = []; streakDays = 0; mysteryBoxCount = 0;
          activePowerUps = { doublePoints: { active: false, expiry: null }, streakShield: { active: false, used: false, expiry: null } };
          // lastFocusDate persists globally unless explicitly cleared
          premiumLofiTracks.forEach(track => track.unlocked = false); // Reset unlocks
          initAudio(); // Re-init with base tracks

          // Clear video/focus state
          videoIds = []; currentVideoIndex = 0; completedVideos.clear(); allVideosCompleted = false;
          clearInterval(countdownInterval); countdownInterval = null; isFocusModeActive = false;
          if (player && typeof player.destroy === 'function') { try { player.destroy(); } catch (e) {} finally { player = null; } }
          stopReminderTimer();
          hideQuietPomodoro(); // Ensure Pomodoro is hidden if open

          // Update UI to logged-out state (Landing Page)
          updateUIBasedOnState(); // Should default to landing page view

          // Clear sensitive fields
           const usernameInput = document.getElementById("username");
           const passwordInput = document.getElementById("password");
           if(usernameInput) usernameInput.value = "";
           if(passwordInput) passwordInput.value = "";

           // Clear the session-specific global state, keep users and playlists
           localStorage.removeItem("focusModeState");

           console.log("Logout complete.");
      }

      // --- Event Listeners Setup ---
      document.addEventListener("DOMContentLoaded", () => {
          initAudio(); // Initialize audio elements and track list
          loadSavedState(); // Load previous state or set defaults
          setInterval(updateClock, 1000); // Start live clock
          setInterval(checkTaskDeadlines, 60000); // Check task deadlines periodically

          // --- General Action Buttons ---
          document.querySelectorAll("button[data-action]").forEach(btn => {
              btn.addEventListener("click", () => {
                  const action = btn.getAttribute("data-action");
                  switch (action) {
                      case "start-game": showSignIn(); break;
                      case "github": window.open("https://github.com/The-Chosen-One-o5/UltraFocusModeYT", "_blank"); break;
                      case "sign-in": signIn(); break;
                      case "create-account": createAccount(); break;
                      case "add-url": addUrlInput(); break;
                      case "start-playback": startPlayback(); break;
                      case "save-playlist": savePlaylist(); break;
                      case "remove-playlist": removePlaylist(); break;
                      case "save-tasks": saveTasks(); break; // Manual save option
                  }
              });
          });

          // --- Specific Element Listeners ---
          document.getElementById("restartBtn")?.addEventListener("click", restartSession);
          document.getElementById("confirmBtn")?.addEventListener("click", () => handleRestartConfirmation("yes"));
          document.getElementById("cancelBtn")?.addEventListener("click", () => handleRestartConfirmation("no"));
          // Minimize button listener attached in setupVideoSidebar

          // LoFi Controls
          document.getElementById("lofiPlay")?.addEventListener("click", playLofi);
          document.getElementById("lofiPause")?.addEventListener("click", pauseLofi);
          document.getElementById("lofiPrev")?.addEventListener("click", prevLofi);
          document.getElementById("lofiNext")?.addEventListener("click", nextLofi);

          // UI Toggles
          document.getElementById("statsBtn")?.addEventListener("click", toggleAnalytics);
          document.getElementById("todoBtn")?.addEventListener("click", toggleTodo);
          document.getElementById("pyqBtn")?.addEventListener("click", redirectToPYQs);
          document.getElementById("pdfToggle")?.addEventListener("click", togglePDFViewer);
          document.getElementById("pdfInput")?.addEventListener("change", handlePDFUpload);
          document.getElementById("fireBox")?.addEventListener("click", toggleAIPopup);
          document.getElementById("quietPomodoroBtn")?.addEventListener("click", showQuietPomodoro);


          // Shop/Power-up Dialogs
          document.getElementById("streakShieldBtn")?.addEventListener("click", showStreakShieldDialog);
          document.getElementById("streakShieldConfirmBtn")?.addEventListener("click", () => handleStreakShieldConfirmation("yes"));
          document.getElementById("streakShieldCancelBtn")?.addEventListener("click", () => handleStreakShieldConfirmation("no"));
          document.getElementById("doublePointsBtn")?.addEventListener("click", showDoublePointsDialog);
          document.getElementById("doublePointsConfirmBtn")?.addEventListener("click", () => handleDoublePointsConfirmation("yes"));
          document.getElementById("doublePointsCancelBtn")?.addEventListener("click", () => handleDoublePointsConfirmation("no"));
          document.getElementById("audioStoreBtn")?.addEventListener("click", showAudioTracksStore);
          document.getElementById("closeAudioStore")?.addEventListener("click", closeAudioTracksStore);

          // Account
          document.getElementById("logoutBtn")?.addEventListener("click", logout);

          // Mystery Box
          document.getElementById("openMysteryBox")?.addEventListener("click", openMysteryBox);

          // Deadline Dialog
          document.getElementById("deadlineConfirmBtn")?.addEventListener("click", () => handleDeadlineConfirmation("yes"));
          document.getElementById("deadlineCancelBtn")?.addEventListener("click", () => handleDeadlineConfirmation("no"));

          // Session Complete Dialog
          document.getElementById("sessionContinueBtn")?.addEventListener("click", () => handleSessionContinue("continue"));
          document.getElementById("sessionEndBtn")?.addEventListener("click", () => handleSessionContinue("end"));

          // Quiet Pomodoro Controls
          document.getElementById("pomodoroStartBtn")?.addEventListener("click", startPomodoroTimer);
          document.getElementById("pomodoroResetBtn")?.addEventListener("click", resetPomodoroTimer);
          document.getElementById("pomodoroCloseBtn")?.addEventListener("click", hideQuietPomodoro);


          // Timer Dragging
          const timerDisplay = document.getElementById("timerDisplay");
          if (timerDisplay) {
              let isDragging = false; let initialX, initialY;
              timerDisplay.style.cursor = 'move';
              timerDisplay.addEventListener("mousedown", (e) => {
                  if (e.target.tagName === 'BUTTON') return; // Ignore clicks on buttons within
                  isDragging = true;
                  initialX = e.clientX - timerDisplay.offsetLeft;
                  initialY = e.clientY - timerDisplay.offsetTop;
                  timerDisplay.style.cursor = 'grabbing';
              });
              document.addEventListener("mousemove", (e) => {
                  if (!isDragging) return;
                  e.preventDefault();
                  const currentX = e.clientX - initialX;
                  const currentY = e.clientY - initialY;
                  // Optional: Add boundary checks if needed
                  timerDisplay.style.left = `${currentX}px`;
                  timerDisplay.style.top = `${currentY}px`;
              });
              document.addEventListener("mouseup", () => {
                  if (isDragging) {
                      isDragging = false;
                      timerDisplay.style.cursor = 'move';
                  }
              });
          }

          // Distraction Detection
          document.addEventListener("visibilitychange", () => {
              if (document.hidden && isFocusModeActive) {
                  console.log("Distraction: Tab hidden.");
                  distractionCount++; totalDistractions++;
                  saveState(); updateAnalytics();
              }
          });

      }); // End DOMContentLoaded

    })(); // End IIFE
  </script>
</body>
</html>
```
